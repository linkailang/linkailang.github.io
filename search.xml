<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo博客彻底删除文章教程</title>
      <link href="/2025/04/05/Hexo%E5%8D%9A%E5%AE%A2%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%E6%95%99%E7%A8%8B/"/>
      <url>/2025/04/05/Hexo%E5%8D%9A%E5%AE%A2%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。</p><p>最近我也搭建了一个Hexo的博客，今天因为没有使用命令工具创建文章，而是最后写完以后才创建新文章文件，然后复制写好的到新文件，并且删掉了原来的文件，结果生成静态文件的时候多余出来一个文章，本地文件明明已经删除了，但是无论怎么样部署出来的站点都会有多余文章，尝试了各种办法最后换了个思维方式而解决。</p><h3 id="普通删除方式"><a href="#普通删除方式" class="headerlink" title="普通删除方式"></a>普通删除方式</h3><p>Hexo正常删除文章的流程是先删除本地文件。</p><p>以原始文件：helloworld.md为例：</p><p>首先进入到source &#x2F; _post 文件夹中，找到helloworld.md文件，在本地直接执行删除。</p><p>然后依次执行命令：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><pre><code class="javascript">hexo clean</code></pre><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><pre><code class="javascript">hexo g</code></pre><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><pre><code class="javascript">hexo d</code></pre><p>此时已经成功删除文章了。</p><h3 id="已发布文章删除"><a href="#已发布文章删除" class="headerlink" title="已发布文章删除"></a>已发布文章删除</h3><p>如果你已经将文章git发布了，此时会在本地创建一个名为 <code>.deploy_git</code>的文件夹，并将生成的文件复制到该文件夹。</p><p>你需要删除本地的文章后，再删除 <code>.deploy_git</code>文件夹。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1355401/cb0b099ee96138a0a16253c9ece316cf.png" alt="img"></p><p>最后依次执行正常删除的命令。</p><h3 id="强制性删除文件"><a href="#强制性删除文件" class="headerlink" title="强制性删除文件"></a>强制性删除文件</h3><p>如果你因为某些原因如我操作失误导致的无法删除的话，你可以尝试如下做法：</p><ol><li>将 <code>source\_posts</code>文件夹中除需要被删除的文件外的所有 <code>.md</code>文件复制到一个新文件夹中。</li></ol><p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/6f76e39861e9965b575907663dbeb1aa.png" alt="img"></p><ol><li>在 <code>source</code>文件夹中直接删除 <code>_posts</code>整个文件夹。</li><li>在 <code>source</code>中新建一个文件夹并命名为 <code>_posts</code>，此时这个文件夹内是空的。</li><li>将复制出来的所有.md文件粘贴到新创建的 <code>_posts</code>文件夹。</li><li>最后依次执行普通删除的命令即可</li></ol><p>这个方法主要针对于因为某些未知原因，或者本地文件错误或有缓存原因导致的，既然无法单个解决文章文件，那就换个思维方式，直接从整个文件夹入手。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 删除文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>示波器使用方法</title>
      <link href="/2025/03/27/%E7%A4%BA%E6%B3%A2%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2025/03/27/%E7%A4%BA%E6%B3%A2%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="示波器使用方法"><a href="#示波器使用方法" class="headerlink" title="示波器使用方法"></a>示波器使用方法</h1><p>上图</p><p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/image-20250327220915887.png" alt="image-20250327220915887"></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>示波器的主要用途就是将随时间变化的电信号以图形的方式画出来，多数的示波器是用时间为x轴，电压为y轴产生的二维图形。</p><p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/image-20250327221136471.png" alt="image-20250327221136471"></p><p>横轴为时间，纵轴为电压</p><p>在示波器屏幕周边的控制按钮可以调节图形的显示比例，显示的横轴和纵轴刻度都能够调节，这样就可以对信号在时间和幅度两个维度进行缩放查看，还有可以调节“触发”的旋钮，帮助“稳定”波形的显示。</p><p>除了这些基础的功能之外，示波器还能够帮助工程师快速定量被测信号的频率、幅度以及其它的波形参数。总之示波器可以测试基于时间和基于电压的参数，如下：</p><p>基于时间的参数 : 频率和周期、占空比、上升时间和下降时间等</p><p>电压参数 : 幅度、最大电压、最小电压、平均电压等</p><h3 id="那什么时候用示波器？"><a href="#那什么时候用示波器？" class="headerlink" title="那什么时候用示波器？"></a>那什么时候用示波器？</h3><p>在调试电路的输入、输出以及中间系统的时候用以确定信号的频率和幅度，基于这些信息可以判断电路的工作是否正常。</p><p>确定电路中噪声的大小</p><p>判断波形的形状 – 正弦波、方波、三角波、锯齿波、复合波形等等</p><p>测量两个不同信号的相位差</p><h3 id="示波器的选用依据"><a href="#示波器的选用依据" class="headerlink" title="示波器的选用依据"></a>示波器的选用依据</h3><p>示波器的功能、性能、价格差别都非常大，示波器的选型需要根据使用的场景（考虑到将来所有可能的项目需求）并结合自己的预算进行选择，主要需要考虑的参数如下：</p><p>数字 vs. 模拟 – 早期的模拟示波器将输入的电压以电子束的方式直接打在显示屏上；数字示波器内部由微处理器控制，通过模数转换器（ADC）将输入的模拟信号进行量化，并经过一系列的处理后将量化的波形显示出来。一般来讲，早期的模拟示波器带宽相对较低，功能较少，但响应时间也许更快，且没有数字示波器由于采样带来的混叠频率，随着科技的发展目前主流的都已经是数字示波器，除非特殊的场合需要模拟示波器；</p><p>通道数 – 可以同时处理的模拟信号输入的数量，2通道最为常见，其次是4通道；</p><p>带宽 – 能够可靠测量的模拟信号的频率范围，一般以MHz为单位来表示，下面的图可以看出来如果模拟带宽不够对被测波形的影响。</p><p>模拟带宽对信号波形的影响</p><p>**取样率 ** – 这是数字示波器特有的指标，反映了对模拟信号以每秒多少次的速度进行采样。有的多通道示波器，当多个通道同时使用的时候采样率可能会降低，一般以MSa&#x2F;S来表示，示波器的最高采样率应该大于4倍的模拟带宽。</p><p>上升时间 – 示波器的上升时间决定了其能够测量的最快的上升脉冲，这个指标与带宽高度相关，可以用这个公式来换算：<span>Rise Time</span> &#x3D; <span>0.35</span> &#x2F; <span>Bandwidth</span>.</p><p>最大输入电压 – 每种电子产品都有其能够承受电压的最高极限，示波器的最高输入电压指的是，如果输入的信号电压超过这个值，极有可能会损毁示波器。</p><p>分辨率 – 表征了对输入电压的量化精度，一般高速的示波器都采用8bit的高速ADC对模拟信号进行量化采样。</p><p>垂直灵敏度 – 这个值表征了垂直显示的电压量程的最小和最大值，单位是伏&#x2F;格。</p><p>时间基准 – 表征了水平的时间轴的灵敏度范围，单位是秒&#x2F;格</p><p>输入阻抗 – 如果被测信号为很高频率的信号，即便是非常小的阻抗（电阻、电容、电感）叠加在电路上都会对信号带来比较大的影响。每一个示波器都会对测量的电路增加一定的阻抗，这个阻抗就是输入阻抗，它一般是比较大的电阻(&gt;1 MΩ)与比较小的电容（在pF的范围）并联 (||). 在测量非常高频率的信号的时候输入阻抗的影响就变得比较明显，可以通过调节使用的探头来进行补偿。</p><p>以Rigol的DS1204B为例，看看这个示波器的各项指标：</p><p>特性值<br>带宽200 MHz<br>取样率2 GSa&#x2F;s<br>上升时间&lt;1.75 ns<br>通道数4<br>最大输入电压1000 V<br>分辨率8-bit<br>垂直灵敏度2mV&#x2F;div - 10V&#x2F;div<br>时间基准1ns&#x2F;div - 50s&#x2F;div<br>输入阻抗1 MΩ ± 2%<br>理解了这些参数的意义，对于你选用合适的示波器非常重要，下一步我们谈一下如何正确使用示波器。</p><p>示波器的组成</p><p>各种示波器的功能基本上都是一样的，它们都有一些共同的属性 - 显示、水平线、垂直线、触发、输入等。</p><p>数字示波器内部构成框图</p><p>数字示波器的面板</p><p>显示部分</p><p>示波器最重要的功能就是把你要测量的电信号以时间为坐标显示出来，因此它是示波器最重要的部分之一。</p><p>示波器的显示界面一般都是通过多条水平和竖直的线交错构成的格状，竖直的刻度单位为伏&#x2F;格，水平的刻度单位为秒&#x2F;格。一般来讲示波器的显示屏在竖向（伏）有8-10个格，在横向（秒）有10-14个格。</p><p>越来越多的数字示波器使用多色的LCD显示屏，能方便在一个屏幕上显示多个波形（以不同的颜色）。</p><p>显示屏周边（右侧或下面）一般会有5个输入按键，用以菜单切换以及设置的控制。</p><p>垂直调节</p><p>示波器显示屏的竖向显示的是测量信号的电压，它的显示控制一般会通过两个旋钮：一个调节波形在竖直方向的位置，另一个调节每格的刻度（伏&#x2F;格）。.</p><p>调节垂直显示刻度的旋钮</p><p>带直流偏移的信号</p><p>通过这两个旋钮的调节，你可以观察到波形的细节，比如你要仔细看一个5V的方波信号的上升沿，就可以通过调节这两个旋钮将上升沿放大进行查看。</p><p>水平调节</p><p>示波器的水平部分为时间标尺，就像垂直调节一样，水平调节按钮也有两个 - 调节左右移动 和改变刻度的大小（单位为秒&#x2F;每格）。</p><p>左右位置的旋钮可以左或右移动显示波形，屏幕上显示多少个周期的波形是通过水平比例的按钮来调节的。</p><p>你可以通过水平比例按钮在横向放大波形仔细查看其细节部分。</p><p>通过横向和竖向调节使得波形的显示正好适当</p><p>触发系统</p><p>触发系统主要是为了稳定波形的显示并让示波器能聚焦，通过调节“触发”按钮，你可以告诉示波器在哪一个起始点开始测量。如果被测的信号是周期性的波形，通过触发的设置，可以让波形在屏幕上稳定显示，像静止不动一样。如果触发没有调节好，波形就会在屏幕上跑来跑去，不能稳定下来。</p><p>示波器的触发部分一般包含一个触发电平按钮和几个用以选择触发源、触发类型的按钮。调节“触发电平按钮”就能够设置触发点为某一个固定的电压值。</p><p>其它的几个按钮和屏幕菜单一起构成了触发系统的其余部分，主要的用途是选择触发源以及触发模式。几种常用的触发类型：</p><p>最基本的边沿触发 - 当输入信号的电压超过某一个设定的电平，示波器开始测量。可以设置为上升沿或下降沿触发，或者两个沿都可以触发。</p><p>脉冲触发 - 遇到某种指定的电压脉冲的时候示波器开始测量，你可以指定脉冲的宽度以及脉冲的方向。</p><p>斜坡触发 - 正向或负向的波形斜坡超过了某一个指定的时间则启动示波器的测量。</p><p>还有一些更复杂的触发机制用以检测某些标准的波形，比如NTSC或PAL**信号. **</p><p>左侧的菜单可以看到不同的触发类型</p><p>探头部分</p><p>示波器的测量离不开同被测电路连接的探头，它是一个单输入的设备，将电信号从待测的电路上传递到示波器。它有一个比较尖的头用以接触你要检测的电路的测试点，很多时候这个尖头会配上钩子、镊子或夹子以方便连接到被测的电路上。每个探头都有一个 接地夹子， 测试的时候需要将这个接地夹子安全地连接到待测电路的公共地的位置。</p><p>探头看起来简单，用起来却学问大多了，多数硬件工程师不会使用示波器的探头，我们来看看怎么回事：</p><p>理想状况下，示波器的探头应该对被测的信号没有任何影响，但现实却是它长长的连线不可避免地有着杂散电感、电容、以及电阻。因此，无论如何，它们都会影响到示波器对待测信号的解读，尤其在非常高的频率的时候。</p><p>探头有多种，最常用的是多数示波器自带的无源（Passive）衰减探头，它内部有着大的电阻并联一个很小的电容，以帮助减小探头的长电缆给待测电路带来的负载效应。这个内部的高电阻同示波器输入端的电阻串联，对输入信号构成了分压。</p><p>示波器探头内部等效阻抗以及和示波器输入端的连接</p><p>多数的示波器探头的内部阻抗为9MΩ的电阻，它同示波器输入端的标准的1MΩ的输入电阻相连接，构成了1&#x2F;10的分压，这种探头被称为10X衰减探头。很多探头都有一个开关，可以切换是10:1衰减（10X）还是不做衰减（1X）.</p><p>衰减探头在高频应用中能够保证比较高的精准度，但不好的地方就是对输入信号先衰减了10倍，如果你要测量的信号是非常小幅度的微弱信号，最好还是使用不做衰减的1x探头，这时候你需要设置示波器的菜单以告知其衰减发生了变化，很多示波器能够自动检测到探头是衰减还是不衰减。</p><p>除了刚才讲的无源衰减探头，还有有源探头（单独供电），能够在送入示波器之前对待测信号进行放大甚至预处理；有能够测量交流或直流电流的探头，电流探头一般是环绕着待测的信号线，而不接触到被测的电路。</p><p>示波器的使用步骤</p><p>1 选择和设置探头</p><p>先根据需要选择一个合适的探头，对于多数测量的信号来讲，你购买的仪器里随带的简单的无源探头就可以用了。</p><p>接下来，设置好探头的衰减，一般常用的是10X，它是很多场合最佳的选择，如果你要测量幅度比较小的信号，可以设置在1X档。</p><p>2 接上探头，打开示波器</p><p>将探头连接到示波器的第一个通道，打开示波器开关开始运行，你可以看到示波器屏幕上的方格、刻度以及由一条水平线构成的波形，带着微弱的噪声波动。</p><p>屏幕上将显示上次关机前设置好的时间（水平方向）和电压（竖直方向）刻度，你不用管这些，调整相应的旋钮，将示波器放到标准的设置：</p><ol><li></li></ol><p>打开通道1，关掉通道2；</p><ol start="2"><li></li></ol><p>设置通道1为直流耦合；</p><ol start="3"><li></li></ol><p>设置触发源为通道1 – 没有外接的信号源或其它通道的信号对此进行触发；</p><ol start="4"><li></li></ol><p>设置触发类型为上升沿触发, 触发模式为 自动 ；</p><ol start="5"><li></li></ol><p>确认示波器探头的衰减设置同你使用的探头的状态一致（例如1X, 10X）；</p><p>3 校准探头</p><p>示波器一般在其面板的右下方都会提供一个内部产生、供校准用的高可靠、固定频率和幅度的方波测试信号，它有两个分开的连接点 - 一个输出校正信号，一个连接系统的地。将探头的接地夹子连接到这个测试信号的接地端，示波器的探头连接到测试信号的输出。</p><p>旋转水平向和垂直向的调节按钮，将波形适当地显示在屏幕上，调节“触发”按钮让波形稳定地显示在屏幕上。</p><ol start="4"><li>对衰减的探头进行补偿</li></ol><p>如果探头设置为10X，却发现显示的方波波形不是严格的方波，你需要进行阻抗补偿 - 用小改锥调节如下图中显示的探头上的并联电容的大小。</p><p>高频时的探头等效电路</p><p>在调节的时候你可以看到屏幕上的波形在变化。</p><p>调节直至屏幕上显示的波形为完美的方波。记住，只有在用10X的时候才需要进行补偿调节。</p><p>对于被测的电路来讲示波器探头+示波器等效为一个10MΩ的电阻和Cload的并联，对被测电路工作的影响可以根据这个等效电路来计算。</p><p>一旦校准好了探头，就可以测量电路上的信号了，测量的时候几个小技巧：</p><p>1 采用比较方便、安全、不影响性能的连接方式 – 将探头的接地夹子接到这个点上。有时候你需要焊接一根很细的导线在电路板上以方便探头的接地夹夹住，探头的尖头端也可以通过带弹簧的夹子、钩子等方便地连接待测的信号点 - 总之要找到一种方法，你不必要一直用手拿着探头。</p><ol start="2"><li><p>避免测量方法不当导致的噪声 - 如果待测的信号为高频（几十MHz）信号，用示波器测试的时候要做到地线的连接尽可能短，否则会由于探头的接地线同探头的尖头构成的环路形成天线，将待测点附近的高频信号（空间的无线电波、板子上开关信号辐射）接收下来叠加在待测信号上，会给自己的调试带来很大的干扰。多数情况下需要将同轴线直接焊接在电路板上，避免产生接收回路。</p></li><li><p>熟悉你使用的仪器的所有测量工具 - 不同的示波器内部带的测量功能不同，你可以查看说明书以及调节各个按键先对你用的仪器功能全面熟悉一下，比如周期、峰峰值、脉宽、占空比、上升沿、下降沿、平均电压等的测量以及如何使用FFT功能，有哪些是能够自动测量并显示的。</p></li></ol><p>使用示波器的测量工具获取Vpp, Vmax, 频率，周期，占空比等信息.</p><p>参数的自动计算显示</p><ol start="4"><li>手动测量波形参数 - 可以通过移动光标读数、计算得到，移动光标的时候时间和电压值都会发生变化。一般光标都是成对出现，你可以通过读取两个光标之间的差值得到需要的信息。</li></ol><p>使用光标测量方波的过冲振铃</p><ol start="5"><li>波形对比 - 基于你的测量结果，可以对电路进行调整，并调整后再次测量，有一些示波器具有保持、打印波形的功能，因此你可以调出前面测试的信号进行对比。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件测量仪器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/27/%E6%89%8B%E7%AE%97%E9%A2%98/"/>
      <url>/2025/03/27/%E6%89%8B%E7%AE%97%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="多少个2"><a href="#多少个2" class="headerlink" title="多少个2"></a>多少个2</h1><h2 id="题目：1到2020里面有多少个2"><a href="#题目：1到2020里面有多少个2" class="headerlink" title="题目：1到2020里面有多少个2"></a>题目：1到2020里面有多少个2</h2><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="java">package shousuan;import java.util.Arrays;public class 多少个2 &#123;    public static void main(String[] args) &#123;        //初始化数组        int size = 2020;        int [] num = new int[ size];        for (int i = 0; i &lt; size ; i++)&#123;            num[i] = i+1;        &#125;//        System.out.println(Arrays.toString(num));        //转为字符串再输出        //计算包含数字2的元素个数        int count = 0;        for (int i = 0; i &lt; size; i++) &#123;            int currentNum = num[i];            while (currentNum &gt; 0) &#123;                if (currentNum % 10 == 2) &#123;                    count++;                &#125;                currentNum /= 10;            &#125;        &#125;        System.out.println(&quot;数组中包含数字2的元素个数为：&quot; + count);    &#125;&#125;</code></pre><h2 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h2><h3 id="填充2020个数字-然后找到替换-点全部替换"><a href="#填充2020个数字-然后找到替换-点全部替换" class="headerlink" title="填充2020个数字 然后找到替换 点全部替换"></a>填充2020个数字 然后找到替换 点全部替换</h3><p><img src="/./%E6%89%8B%E7%AE%97%E9%A2%98/image-20240226201652950.png" alt="image-20240226201652950"></p><p><img src="/./%E6%89%8B%E7%AE%97%E9%A2%98/image-20240226201533046.png" alt="image-20240226201533046"></p><p><img src="/./%E6%89%8B%E7%AE%97%E9%A2%98/image-20240226201714785.png" alt="image-20240226201714785"></p><h2 id="卡片"><a href="#卡片" class="headerlink" title="卡片"></a>卡片</h2><p>【题目描述】</p><p>小蓝有很多数字卡片，每张卡片上都是数字0 到9。<br>小蓝准备用这些卡片来拼一些数，他想从1 开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。<br>小蓝想知道自己能从1 拼到多少。<br>例如，当小蓝有30 张卡片，其中0 到9 各3 张，则小蓝可以拼出1 到10，但是拼11 时卡片1 已经只有一张了，不够拼出11。<br>现在小蓝手里有0 到9 的卡片各2021 张，共20210 张，请问小蓝可以从1拼到多少？<br>提示：建议使用计算机编程解决问题。</p><p>【答案】：3181</p><p>【题解】：0-9的卡片每个数字有2021张，从1开始遍历，每遍历到一个数字，这个卡片数字的个数就-1，如果某一个数字的卡片没有了，就遍历结束了。</p><pre><code class="java">import java.util.Arrays;public class Main &#123;    static int a[] = new int[10];//0-9    public static void main(String[] args) &#123;        Arrays.fill(a, 2021);//每个数初始值为2021        int ans = 0;        for(int i = 1; i &lt;= 20210; i++) &#123;            int t = i;            while(t &gt; 0) &#123;                int s = t % 10;                t /= 10;                a[s]--;                //注意：这里不是==0，上面a[s]--,减了一次才为0，说明这次没减之前为1，还有最后一个数，                //如果为0，-1就会小于0，说明这个数2021张牌都用完啦                            if(a[s] &lt; 0) &#123;                ans = i-1; //当前遍历的这个数肯定没有遍历完，故遍历到这个数的前一个                break;            &#125;        &#125;        if(ans != 0)break;    &#125;    System.out.println(ans);&#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新电脑环境配置</title>
      <link href="/2025/03/22/%E6%96%B0%E7%94%B5%E8%84%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/03/22/%E6%96%B0%E7%94%B5%E8%84%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/image-20250322102305779.png"></p><p>搭建到一半想起来开始记录。。。</p><p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/image-20250322103501133.png" alt="image-20250322103501133"></p><h2 id="已经安装的软件"><a href="#已经安装的软件" class="headerlink" title="已经安装的软件"></a>已经安装的软件</h2><ol><li><p>Idea破解</p></li><li><p>Git工具</p></li><li><p>Anaconda3(默认python3.9)</p></li><li><p>VMware虚拟机（u盘有镜像直接食用）</p></li><li><p>Picgo图床配合Typora+gitee仓库搭建的静态博客（环境NVM就够用，美化博客的我从上一台电脑Crtl+V）</p></li><li><p>WPS看见这个版本有封装Deepseek个人使用免费</p></li><li><p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/image-20250322102702648.png" alt="image-20250322102702648">  这个截图软件推荐</p></li><li><p>安装Steam</p></li><li><p>安装一半的GPU深度学习加速（显卡inter a770 16G）</p><pre><code class="shell">pip install opencv-python numpy pandas tensorboard matplotlib tqdm pyyaml wget scipy</code></pre><p>镜像</p></li><li><p>桌面美化（dock,小黄条，fences,Wallpaper）</p></li><li><p>clash</p></li><li><p>Typora 破解版（虽然有点小问题）<br><a href="(https://blog.csdn.net/theaipower/article/details/145144461)">【Typora】2025最新Typora安装下载与破解免费使用保姆级图文教程_typora下载-CSDN博客</a></p></li></ol><h2 id="继续安装的软件"><a href="#继续安装的软件" class="headerlink" title="继续安装的软件"></a>继续安装的软件</h2><ul><li><p>EV录屏（突然想起来显卡有自带的录屏和直播功能。。。）</p><p>找半天i卡驱动自带的英特尔® 显卡控制中心捕获，找不到。。。</p></li><li><p>安装搜索工具</p><p><a href="https://help.listary.com/zh-Hans/download-and-open">安装与启动 | Listary Docs</a></p><p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/image-20250322122921233.png" alt="image-20250322122921233"></p></li><li><p>继续安装pycharm2024.3.5</p></li></ul><p><a href="https://mp.weixin.qq.com/s/Py1rAoEbumbdaixzOB79sw">pycharm专业版破解工具教程</a></p><p>要了一个百度网盘svip下载文件破解版，别问，喜欢破解。</p><pre><code>通过百度网盘分享的文件：Visual S…链接:https://pan.baidu.com/s/1-hgiLCdZbAsA6D6UmvKRtw?pwd=135s 提取码:135s复制这段内容打开「百度网盘APP 即可获取」</code></pre><p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/image-20250327220233702.png" alt="image-20250327220233702"></p><p><img src="https://gitee.com/tu-liangxiang/pic-img/raw/master/blog/image-20250327232022086.png" alt="image-20250327232022086"></p><p>vscode 本来下最新版，汉化插件不适配最新版，下别人链接去了（里面带C++编译插件环境）<br><a href="https://www.123pan.com/s/sSNLVv-0cNRA.html?login_source_page=other&login_type=phone">VSCode.zip官方版下载丨最新版下载丨绿色版下载丨APP下载-123云盘</a></p><p>leetcode插件还不错</p><p>忘记安装JDK环境了</p><p><a href="https://blog.csdn.net/m0_52861000/article/details/125820297">Java官网下载JDK17版本详细教程（下载、安装、环境变量配置）_java17下载-CSDN博客</a></p><p>然后CLASSPATH后面的版本添加环境变量可有可无。</p><pre><code>点击新建系统变量名为&quot;CLASSPATH&quot;，变量值为&quot;.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib;</code></pre><p>为 Java 虚拟机（JVM）提供类文件（<code>.class</code>）和依赖库（<code>.jar</code>）的搜索路径。</p><p>🔧 <strong>变量值分解</strong>：</p><ul><li><code>.</code> : 代表当前目录，JVM 会优先从运行命令的当前位置查找类文件</li><li><code>%JAVA_HOME%\lib\dt.jar</code> : Java 设计工具（DesignTime）的核心库</li><li><code>%JAVA_HOME%\lib\tools.jar</code> : 包含 javac、javadoc 等开发工具类</li><li><code>%JAVA_HOME%\lib\</code> : JDK 基础类库目录（如 rt.jar）</li></ul><p>💡 <strong>点击”确定”的三重意义</strong>：</p><ol><li><strong>保存配置</strong>：使新建的 CLASSPATH 变量持久化存储</li><li><strong>环境同步</strong>：立即生效于当前及后续启动的命令行&#x2F;IDE</li><li><strong>路径继承</strong>：通过 <code>%JAVA_HOME%</code> 动态引用 JDK 安装位置，保持路径灵活性</li></ol><p>⚠️ <strong>注意事项</strong>：</p><ul><li>需提前设置 <code>JAVA_HOME</code> 变量指向 JDK 安装目录</li><li>现代 Java 版本（JDK 1.5+）多数情况无需手动配置 CLASSPATH</li><li>特定项目依赖建议使用构建工具（Maven&#x2F;Gradle）管理</li></ul><p>❓ <strong>典型应用场景</strong>：<br>当直接通过 <code>java</code> 命令运行程序且未使用 <code>-cp</code> 参数时，系统会自动采用此默认类路径配置。</p><p>cursor0.44版本<br><a href="https://pan.quark.cn/s/ebd13933873d#/list/share">夸克网盘分享</a></p><p>cursor改机器码<br><a href="https://www.coolapk.com/link?url=https://wwut.lanzoul.com/imzzG2rdx4gb">https://www.coolapk.com/link?url=https%3A%2F%2Fwwut.lanzoul.com%2FimzzG2rdx4gb</a></p><p>虽然我是新用户。。</p><p>xmind8破解<br><a href="https://www.exception.site/essay/xmind-pojie">Xmind 8 破解版下载_激活序列号（附图文教程，亲测有效） - 异常教程</a></p><p>我之前用亿图展示</p><p>idea破解</p><p><a href="https://blog.csdn.net/2301_80371894/article/details/145776977">IDEA2025最新版安装教程（全网最详细，最简单）-CSDN博客</a></p><p>maven安装配置</p><p><a href="https://blog.csdn.net/m0_73804764/article/details/139898041">（2025.1.27）最新版MAVEN的安装和配置教程（超详细）_maven安装-CSDN博客</a></p><p>redis安装配置</p><p><a href="https://blog.csdn.net/weixin_44893902/article/details/123087435">Window下Redis的安装和部署详细图文教程（Redis的安装和可视化工具的使用）_redis安装-CSDN博客</a></p><p>redis可视化工具<br> <a href="https://www.rjgcz.com/16947.html">Redis可视化管理 RESP 2022.5.1 直装激活版【软件个锤子·R3120】 - 软件个锤子</a></p><p>tomocat安装配置</p><p><a href="https://blog.csdn.net/qq_51630166/article/details/143228965">2024年最新tomcat安装配置详细教程（保姆级，亲测有效）并解决tomcat无法启动和乱码问题_tomcat安装及配置教程-CSDN博客</a></p><p>mysql8.0安装配置</p><pre><code>用户名:MySQL密码：123456</code></pre><p><a href="https://blog.csdn.net/m0_52559040/article/details/121843945">2024 年 MySQL 8.0 安装 配置 教程 最简易（保姆级）_mysql安装-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 电脑环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS2机器人开发</title>
      <link href="/2025/02/07/ROS2%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91/"/>
      <url>/2025/02/07/ROS2%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS1和ROS2"><a href="#ROS1和ROS2" class="headerlink" title="ROS1和ROS2"></a>ROS1和ROS2</h1><ol><li>ROS（Robot Operating System，机器人操作系统），但 ROS 本身并不是一个操作系统，而是可以安装在现在已有的操作系统上（Linux、Windows、Mac）的软件库和工具集。</li><li>现在的 ROS 功能已经变得非常的丰富和强大。但随着对 ROS 功能上要求越来越多，<strong>一些原始的架构和设计不能够满足目前的使用需求，这也是 ROS2 出现的原因</strong>。</li></ol><h2 id="ROS的作用"><a href="#ROS的作用" class="headerlink" title="ROS的作用"></a>ROS的作用</h2><ol><li>做一个机器人需要涉及到多个部分，而且这些部分之间还要进行通信，如果想要整个机器人可以跑起来，那么必须要有一个东西将下面的几个部分合理的连接到一起，这个东西就是 ROS</li></ol><ul><li>感知部分：激光雷达、深度相机、IMU、里程计、碰撞感知、建图</li><li>决策部分：路径规划（navigation）算法、定位算法</li><li>控制部分：轮子驱动</li></ul><h2 id="ROS-和-ROS2-对比"><a href="#ROS-和-ROS2-对比" class="headerlink" title="ROS 和 ROS2 对比"></a>ROS 和 ROS2 对比</h2><p>1.<br>   ROS 的设计目标是简化机器人的开发，ROS 为此设计了一整套通信机制（话题、服务、参数、动作）</p><ul><li>通过这些通信机制，ROS 实现了将机器人的各个组件给的连接起来，在设计这套通信机制的时候就设计了一个叫做 ROS Master 的主节点，所有节点（可以理解为某一个组件，比如：激光雷达）的通信建立必须经过这个主节点</li><li>一旦 ROS Master 主节点挂掉后，就会造成整个系统通信的异常，ROS 的不稳定这个问题，如果是想基于 ROS 做商业化机器人（比如无人驾驶汽车），就会造成非常严重的后果</li><li>ROS 还存在以下问题：1、通信基于 TCP 实现，实时性差、系统开销大；2、对 Python3 支持不友好，需要重新编译；3、消息机制不兼容；4、没有加密机制、安全性不高</li></ul><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202502091701356.png" alt="image-20250209170153244"></p><blockquote><p>[!TIP]</p><p>网络传输可靠性对比</p><ul><li>ROS1 是基于 TCP&#x2F;IP 构建的，TCP&#x2F;IP 很难在无线通信中传输数据，因为中断可能会导致回退、重传和延迟</li><li>ROS2 中的 DDS 使用 UDP 传送数据，不会尝试重新传输数据，相反，DDS 决定在不可靠的条件下何时以及如何重新传输，DDS 引入了服务质量 (QoS) 来公开这些设置，以优化可用带宽和延迟</li></ul></blockquote><h2 id="ROS-与-ROS2-架构对比"><a href="#ROS-与-ROS2-架构对比" class="headerlink" title="ROS 与 ROS2 架构对比"></a>ROS 与 ROS2 架构对比</h2><ol><li><p>OS 层</p><p>ROS：只支持 linux 平台</p><p>ROS2：支持 windows、mac 甚至是嵌入式 RTOS 平台</p></li><li><p>中间件层（中间件就是介于某两个或者多个节点中间的组件，提供多个节点间通信用的）</p><p>去中心化 master：ROS 和 ROS2 中间件不同之处在于，ROS2 取消了 master 节点，去中心化后，各个节点之间可以通过 DDS 的节点相互发现，各个节点都是平等的，且可以 1 对 1、1 对 n、n 对 n 进行互相通信</p><p>不造通信的轮子：通信直接更换为 DDS 进行实现，采用 DDS 通信，使得 ROS2 的实时性、可靠性和连续性上都有了增强</p></li><li><p>应用层</p><p>Python2 到 Python3 的支持</p><p>编译系统的改进（catkin 到 ament）</p><p>C++ 标准更新到 C++11</p><p>可以使用相同 API 的进程间和进程内通信</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202502091709884.png" alt="image-20250209170944771"></p><h3 id="ROS2系统架构可以分为5层"><a href="#ROS2系统架构可以分为5层" class="headerlink" title="ROS2系统架构可以分为5层"></a>ROS2系统架构可以分为5层</h3><ol><li><p>操作系统层</p></li><li><p>DDS实现层</p></li><li><p>DDS接口层</p></li><li><p>ROS 2客户端层</p></li><li><p>ROS 2 应用层</p></li></ol><p>什么是 DDS？</p><p>DDS（Data Distribution Service，数据分发服务），是 OMG（Object Management Group，对象管理组织）发布的分布式通信规范&#x2F;协议，采用订阅发布模型，以中间件的形式提供通信服务，并提供 QoS（Quality of Service）策略，保障数据实时、高效、灵活的分发<br>DDS 协议大致流程是多对多的单向数据交互，通信模型为分布式结构，没有中心节点，同一个数据空间任何两个节点之间都能直接通信，DDS 采用以数据为中心的发布-订阅模型 DCPS（Data-Centric Publish-Subscribe）<br>分布式实时通信-DDS 概述</p><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><p>虚拟机 版本ubuntu22.02</p><p>鱼香ros2一键安装</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202502092011690.png" alt="image-20250209201136544"></p><p>软件 vscode &#x2F; anconda </p><pre><code>终端输入code. 打开vscode</code></pre><p>版本管理工具 git</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202502071927639.png" alt="image-20250207192748580"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202502071927152.png" alt="image-20250207192717490"></p><h1 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2.常用指令"></a>2.常用指令</h1><pre><code>Ctrl+Alt+T 打开终端 默认打开当前用户的主目录 用符号 ~</code></pre><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202502071915988.png"></p><p>在liunx里面 &#x2F;表示整个文件系统的根目录</p><pre><code>ls #表示当前目录下的文件</code></pre><pre><code>mkdir #创建文件夹touch #创建文件nano / vim 文本编辑器cat #对文件里面文本进行控制台打印输出rm  删除文件rm -r 递归删除</code></pre><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202502071915204.png" alt="image-20250207191542128"></p><pre><code>dpkg -i 包安装管理工具</code></pre><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>有g++ 和 cmake 俩种方法</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>linux 里面环境变量是一种全局变量 用于存储用户和系统的配置信息</p><h1 id="编写节点"><a href="#编写节点" class="headerlink" title="编写节点"></a>编写节点</h1>]]></content>
      
      
      
        <tags>
            
            <tag> ROS2 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题</title>
      <link href="/2025/01/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
      <url>/2025/01/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题ing... </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计</title>
      <link href="/2025/01/06/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/01/06/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32环境监测模块"><a href="#STM32环境监测模块" class="headerlink" title="STM32环境监测模块"></a>STM32环境监测模块</h1><p>原主函数</p><pre><code class="c++">/***************************************** File name:         main.c** Descriptions:      毕业设计-环境监测模块**--------------------------------------------------------------------------------------------*/#include &quot;config.h&quot;#include &quot;stm32f10x.h&quot;#include &quot;delay1.h&quot;#include &quot;bmp280.h&quot;  // 注释掉BMP280的头文件#include &quot;oled_iic.h&quot;#include &lt;stdio.h&gt;#include &quot;dht11.h&quot;#include &quot;servo.h&quot;#include &quot;led.h&quot;#include &quot;ultrasonic.h&quot;#include &quot;timer1.h&quot;#define D1         PBout(0)#define D2         PBout(1) #define LED_SYS    PCout(13)u8 temp;u8 humi;char tempStr[20];char pressStr[20];int num = 30;u8 state = 0;extern char Rx232buffer[Buf_Max];extern u8 recv_status;static float bmp280_press, bmp280; u8 buff[30]; // 参数显示缓存数组u16 Pre;     // 气压检测值char buff1[100]; // 缓存发送数据float Angle = 0; // 初始化角度变量float distance;/*************************************************************************** * 延时函数 **************************************************************************/void _delay_ms(int i) &#123;    u16 j;    while (i--) &#123;        for (j = 0; j &lt; 5600; j++);    &#125;    &#125;void send_data_to_esp8266(u8 temp, u8 humi, float distance) &#123;    sprintf(buff1, &quot;GET /update?temp=%d&amp;humi=%d&amp;distance=%.2f HTTP/1.1\r\nHost: localhost:8090\r\nConnection: close\r\n\r\n&quot;, temp, humi, distance);    printf(&quot;Sending data: %s\n&quot;, buff1);    USART_printf(USART1, buff1); // 发送到ESP8266&#125;/*************************************************************************** * 8266配置函数 **************************************************************************/void config_8266(void) &#123;    // 设置为Station模式    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CWMODE=1\r\n&quot;); // 1: Station模式        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();        // 连接到Wi-Fi热点    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CWJAP=\&quot;666\&quot;,\&quot;a1234567\&quot;\r\n&quot;); // 连接到指定的热点        delay_ms(2000);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();    // 重启ESP8266    if (Hand(&quot;OK&quot;)) &#123;        printf(&quot;AT+RST\r\n&quot;);        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();    // 启用多连接模式    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CIPMUX=1\r\n&quot;);        delay_ms(500);    &#125;    CLR_Buf();    // 启动TCP服务器    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CIPSERVER=1,5000\r\n&quot;);        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();    // 获取本地IP地址    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CIFSR\r\n&quot;);        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    delay_ms(1500);    CLR_Buf();&#125;/*************************************************************************** * 处理接收数据 **************************************************************************/void hand_recv(void) &#123;    OLED_Clear();    //OLED_ShowCH(0, 1, &quot;receiving:&quot;);    //OLED_ShowCH(8, 4, (u8 *)Rx232buffer);    delay_ms(1500);    if (Hand(&quot;ESPKLED1&quot;)) &#123;        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led_on();        CLR_Buf();        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;      else if (Hand(&quot;ESPGLED1&quot;)) &#123;        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led_off();        CLR_Buf();        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;        else if (Hand(&quot;EG&quot;)) &#123;  // 检测到 &quot;EG&quot; 命令        float newAngle = 30;  // 设置舵机旋转30度        Servo_SetAngle(newAngle);  // 设置舵机角度        char angleStr[30];        sprintf(angleStr, &quot;Rotating servo to: %.2f\n&quot;, newAngle);        USART_printf(USART1, angleStr);  // 通过串口输出    &#125;         else if (Hand(&quot;ON&quot;)) &#123;  // 检测到 &quot;ON&quot; 命令        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led1_on();  // 点亮LD1        CLR_Buf();        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;    else if (Hand(&quot;OFF&quot;)) &#123;  // 检测到 &quot;OFF&quot; 命令        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led1_off();  // 熄灭LD1        CLR_Buf();        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;&#125;void displayValue(int index, float value, const char* label) &#123;    OLED_ShowChinese(0, index, 0, 16, 1); // 显示标签    OLED_ShowNum(0, index + 1, value, 2, 1); // 显示数值    OLED_ShowChar(1, index + 1, &#39;C&#39;); // 显示单位&#125;void PrintDistance(void) &#123;    //USART_printf(USART1, &quot;Entering PrintDistance function...\r\n&quot;);      // 确保定时器已启动    //TIM_Cmd(TIM4, ENABLE); // 启动定时器    float distance = UltrasonicGetLength();       char buffer[50];  // 用于存储格式化的字符串    // 将距离格式化为字符串    sprintf(buffer, &quot;Distance: %.2f cm\r\n&quot;, distance);      // 通过串口打印    USART_printf(USART1, buffer);              // 关闭定时器    //TIM_Cmd(TIM4, DISABLE); // 停止定时器    // 发送距离到ESP8266        // 输出结束的调试信息    USART_printf(USART1, &quot;Exiting PrintDistance function...\r\n&quot;);&#125;/*************************************************************************** * 主函数 **************************************************************************/int main(void) &#123;           SystemInit();//配置系统时钟为72M        delay_init(72);    // 初始化        const char *messages[] = &#123;            &quot;温度：&quot;,            &quot;湿度：&quot;,            &quot;距离：&quot;,            &quot;气压&quot;        &#125;;    led_init();    delay_ms(500);    LED_SYS = !LED_SYS;    delay_ms(500);    LED_SYS = !LED_SYS;    delay_ms(500);          Ultrasonic_Init();      OLED_Clear();    // OLED初始化    OLED_Init();    delay_ms(1500);      Servo_Init();    // 初始化串口1    USART1_Init();    USART_printf(USART1, &quot;欢迎使用STM32开发板\n\n&quot;);    // 初始化ESP8266    esp8266_init();    LED_SYS = !LED_SYS;    delay_ms(500);        // 初始化USART3    USART3_Init();    LED_SYS = !LED_SYS;    delay_ms(100);     // 配置ESP8266    config_8266();    delay_ms(500);            BMP280Init();            while(DHT11_Init())        &#123;            USART_printf(USART1, &quot;DHT11 initialization failed!\n&quot;);            delay_ms(1000);        &#125;                /*        // 显示“温度：”        OLED_ShowChinese(1, 1, 0, 16, 1);          OLED_ShowChinese(1, 2, 1, 16, 1);          OLED_ShowChar(1, 5, &#39;:&#39;);          OLED_ShowChar(1, 9, &#39;C&#39;);          // 显示“湿度：”        OLED_ShowChinese(2, 1, 2, 16, 1);          OLED_ShowChinese(2, 2, 1, 16, 1);          OLED_ShowChar(2, 5, &#39;:&#39;);          OLED_ShowChar(2, 9, &#39;%&#39;);    USART_printf(USART1, &quot;Config Done!\n\n&quot;);    OLED_Clear();    OLED_ShowCH(0, 1, &quot;Config Done...&quot;);        // OLED显示 &quot;气压：&quot;    OLED_ShowChinese(0, 0, 0, 16, 1);    OLED_ShowChinese(16, 0, 1, 16, 1);    OLED_ShowChar1(40, 0, &#39;:&#39;, 16, 1);    sw_delay_ms(1500);    */    OLED_Clear();    // 显示“舵机角度:”    /*        OLED_ShowChinese(0, 0, 0, 16, 1);    OLED_ShowChinese(16, 0, 1, 16, 1);    OLED_ShowChinese(32, 0, 2, 16, 1);            OLED_ShowChinese(48, 0, 3, 16, 1);    OLED_ShowChar1(64, 0, &#39;:&#39;, 16, 1);        */        int displayIndex = 0;        float currentAngle = 0; // 当前角度变量        char displayStr[20];  // 用于显示的字符串    // 主循环    while (1) &#123;              // 检查是否有接收到的数据        if (recv_status ==1) &#123;            hand_recv(); // 处理接收的数据            recv_status = 0; // 重置接收状态        &#125;                        // 格式化气压数据        sprintf((char *)buff, &quot;%2dhPa     &quot;, Pre);                //OLED_ShowString(50, 0, buff, 16, 1);                // 通过串口1发送气压数据        USART_printf(USART1, (char *)buff); // 强制转换                        DHT11_Read_Data(&amp;temp,&amp;humi);//                printf(&quot;temp %d ,humi %d\r\n&quot;,temp,humi);                led_toggle();                delay_ms(1000);        PrintDistance();  // 调用打印距离的函数            // 调试信息：测量完成        USART_printf(USART1, &quot;Distance measurement completed.\r\n&quot;);                //显示温度数据                //OLED_ShowNum(1,6,temp,2,1);                //显示湿度数据                //OLED_ShowNum(2,6,humi,2,1);                          // 发送数据到 ESP8266        float distance = UltrasonicGetLength(); // 获取距离        send_data_to_esp8266(temp, humi, distance); // 发送温度、湿度和距离                // 更新OLED显示内容                OLED_Clear();  // 清屏                                switch (displayIndex) &#123;                    case 0:                            sprintf(displayStr, &quot;%dC&quot;, temp); // 格式化温度，显示单位为摄氏度                            break;                    case 1:                            sprintf(displayStr, &quot;%d%%&quot;, humi); // 格式化湿度，显示单位为百分比                            break;                    case 2:                            sprintf(displayStr, &quot;%.2fcm&quot;, distance); // 格式化距离，显示单位为厘米                            break;                    case 3:                            sprintf(displayStr, &quot;%.2fhPa&quot;, bmp280_press); // 格式化大气压，显示单位为hPa                            break;            &#125;                OLED_ShowCH(0, 5, (u8*)displayStr);// 在OLED屏幕上显示对应的值                    // 更新显示索引                displayIndex = (displayIndex + 1) % 4;  // 循环显示0, 1, 2, 3                delay_ms(500); // 控制更新频率                // 检查LED灯状态                /*                currentAngle += 30; // 增加角度                if (currentAngle &gt; 180) &#123;                        currentAngle = 0; // 超过180归零                        &#125;              // 计算每一步的角度增量和延时              float targetAngle = currentAngle; // 目标角度              float stepAngle = (targetAngle - currentAngle) / (3 * 1); // 3秒内10次更新，每次更新0.3秒              for (int i = 0; i &lt; 1; i++) &#123;                  currentAngle += stepAngle; // 更新当前角度              Servo_SetAngle(currentAngle); // 设置舵机的角度                  char angleStr[10];              sprintf(angleStr, &quot;Setting servo angle to: %.2f\n&quot;, currentAngle); // 格式化角度                  USART_printf(USART1, angleStr); // 输出当前角度              OLED_Clear();                  OLED_ShowNum(50, 24, (int)currentAngle, 3, 1); // OLED显示角度                  delay_ms(300); // 300毫秒的延时      &#125;        */        // 延时，避免数据发送过快        delay_ms(500); // 适当的延时，可以根据需要调整    &#125;    &#125;/********************************************END FILE********************/</code></pre><pre><code>/***************************************** File name:         main.c** Descriptions:      毕业设计-环境监测模块**--------------------------------------------------------------------------------------------*/#include &quot;config.h&quot;#include &quot;stm32f10x.h&quot;#include &quot;delay1.h&quot;#include &quot;bmp280.h&quot;  #include &quot;oled_iic.h&quot;#include &lt;stdio.h&gt;#include &quot;dht11.h&quot;#include &quot;servo.h&quot;#include &quot;string.h&quot; #include &quot;sys.h&quot;#include &quot;led.h&quot;#include &quot;ultrasonic.h&quot;#include &quot;timer1.h&quot;#define D1         PBout(0)#define D2         PBout(1) #define LED_SYS    PCout(13)u8 temp;u8 humi;char tempStr[20];char pressStr[20];int num = 30;u8 state = 0;extern char Rx232buffer[Buf_Max];extern u8 recv_status;//BMP280使用参数static float bmp280_press, bmp280_temp; u8 buff[30]; // 参数显示缓存数组u16 Pre;     // 气压检测值char buff1[100]; // 缓存发送数据float Angle = 0; // 初始化角度变量float distance; //超声波测距用的变量/*************************************************************************** * 延时函数 **************************************************************************/void _delay_ms(int i) &#123;    u16 j;    while (i--) &#123;        for (j = 0; j &lt; 5600; j++);    &#125;&#125;/*void send_data_to_esp8266(u8 temp, u8 humi, float distance, float pressure) &#123;    // 格式化为 GET 请求，加入气压（pressure）字段    sprintf(buff1, &quot;GET /update?temp=%d&amp;humi=%d&amp;distance=%.2f&amp;pressure=%.2f HTTP/1.1\r\nHost: 192.168.224.162:8090\r\nConnection: close\r\n\r\n&quot;, temp, humi, distance, pressure);    printf(&quot;Sending data: %s\n&quot;, buff1);  // 输出调试信息    USART_printf(USART1, buff1);  // 发送到ESP8266&#125;*/void send_data_to_esp8266(u8 temp, u8 humi, float distance, float pressure) &#123;    char http_request[200];    int request_len;    // 1. 建立 TCP 连接到目标服务器    printf(&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;192.168.224.238\&quot;,5002\r\n&quot;);  // 修改为目标服务器 IP 和端口    delay_ms(5000);  // 等待连接建立    // 确认连接建立成功    USART_printf(USART1, Rx232buffer);  // 打印 ESP8266 返回的响应    CLR_Buf();    // 检查 ESP8266 返回的响应是否包含 &quot;OK&quot;    if (strstr(Rx232buffer, &quot;OK&quot;) == NULL) &#123;        USART_printf(USART1, &quot;连接失败\n&quot;);        return;  // 如果连接失败，退出    &#125;    // 2. 构造 HTTP 请求    request_len = sprintf(http_request,        &quot;POST / HTTP/1.1\r\n&quot;        &quot;Host: 192.168.224.238:5002\r\n&quot;        &quot;Content-Type: application/json\r\n&quot;        &quot;Content-Length: %d\r\n&quot;        &quot;\r\n&quot;        &quot;&#123;\&quot;temp\&quot;: %d, \&quot;humi\&quot;: %d, \&quot;distance\&quot;: %.2f, \&quot;pressure\&quot;: %.2f&#125;&quot;,        62, temp, humi, distance, pressure);  // Content-Length 需要包含 JSON 数据的长度    // 打印 HTTP 请求，检查格式    USART_printf(USART1,  http_request);    // 3. 发送 HTTP 请求数据    printf(&quot;%s&quot;, http_request);  // 发送 HTTP 请求    delay_ms(1000);  // 等待 ESP8266 发送数据    // 4. 关闭 TCP 连接    printf(&quot;AT+CIPCLOSE\r\n&quot;);    delay_ms(500);  // 等待连接关闭    USART_printf(USART1, Rx232buffer);  // 打印 ESP8266 返回的响应    CLR_Buf();&#125;/*************************************************************************** * 8266配置函数 **************************************************************************/void config_8266(void) &#123;    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CWMODE=1\r\n&quot;); // 1: Station模式        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();        while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CWJAP=\&quot;666\&quot;,\&quot;a1234567\&quot;\r\n&quot;); // 连接到指定的热点        delay_ms(2000);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();    if (Hand(&quot;OK&quot;)) &#123;        printf(&quot;AT+RST\r\n&quot;);        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CIPMUX=1\r\n&quot;);        delay_ms(500);    &#125;    CLR_Buf();    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CIPSERVER=1,5000\r\n&quot;);        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CIFSR\r\n&quot;);        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    delay_ms(1500);    CLR_Buf();&#125;/*************************************************************************** * 处理接收数据 **************************************************************************/void hand_recv(void) &#123;    OLED_Clear();    delay_ms(1500);    if (Hand(&quot;ESPKLED1&quot;)) &#123;        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led_on();        CLR_Buf();        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);        USART_printf(USART1, &quot;LED灯已开启\n&quot;);    &#125;      else if (Hand(&quot;ESPGLED1&quot;)) &#123;        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led_off();        CLR_Buf();        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);        USART_printf(USART1, &quot;LED灯已关闭\n&quot;);    &#125;    else if (Hand(&quot;ON&quot;)) &#123;        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led1_on();        CLR_Buf();        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);        USART_printf(USART1, &quot;LED1已点亮\n&quot;);    &#125;    else if (Hand(&quot;OFF&quot;)) &#123;        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led1_off();        CLR_Buf();        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);        USART_printf(USART1, &quot;LED1已熄灭\n&quot;);    &#125;&#125;/*************************************************************************** * 打印距离函数 **************************************************************************/void PrintDistance(void) &#123;    float distance = UltrasonicGetLength();    char buffer[50];    sprintf(buffer, &quot;距离: %.2f cm\r\n&quot;, distance);      USART_printf(USART1, buffer);&#125;/*************************************************************************** * 主函数 **************************************************************************/int main(void) &#123;         SystemInit();  // 配置系统时钟为72M      delay_init(72);            led_init();    delay_ms(500);    LED_SYS = !LED_SYS;    delay_ms(500);    LED_SYS = !LED_SYS;    delay_ms(500);        Ultrasonic_Init(); //测距初始化    OLED_Clear();    OLED_Init();    delay_ms(1500);    Servo_Init();    USART1_Init();    USART_printf(USART1, &quot;欢迎使用STM32开发板\n\n&quot;);        esp8266_init();    LED_SYS = !LED_SYS;    delay_ms(500);        USART3_Init();    LED_SYS = !LED_SYS;    delay_ms(100);     config_8266();    delay_ms(500);                        while (BMP280Init()) &#123;        USART_printf(USART1, &quot;BMP280初始化失败！\n&quot;);        delay_ms(1000);    &#125;    while (DHT11_Init()) &#123;        USART_printf(USART1, &quot;DHT11初始化失败！\n&quot;);        delay_ms(1000);    &#125;        OLED_Clear();    int displayIndex = 0;    char displayStr[20];                int send_counter = 0;    while (1) &#123;        if (recv_status == 1) &#123;            hand_recv();            recv_status = 0;        &#125;                sprintf((char *)buff, &quot;%2dhPa     &quot;, Pre);        USART_printf(USART1, (char *)buff);                DHT11_Read_Data(&amp;temp, &amp;humi);        printf(&quot;温度: %d ,湿度: %d\r\n&quot;, temp, humi);        led_toggle();        delay_ms(1000);                PrintDistance();          USART_printf(USART1, &quot;距离测量完成.\r\n&quot;);                float distance = UltrasonicGetLength();        // 发送数据到 ESP8266                                OLED_Clear();                                                // 获取BMP280的气压数据        BMP280GetData(&amp;bmp280_press, &amp;bmp280_temp, &amp;bmp280_temp);  // 获取气压和温度                 // 生成一个 988 到 1005 之间的随机数并加到 bmp280_press 上                Pre = bmp280_press + (rand() % (1005 - 988 + 1)) + 988;  // 范围是 988 到 1005                                //获取BMP280的海拔数据                                // 每2次循环发送一次HTTP请求（或者根据需求修改频率）                if (send_counter == 2) &#123;                        send_data_to_esp8266(temp, humi, distance, (float)Pre);  // 发送数据                        send_counter = 0;  // 重置计数器                &#125; else &#123;                        send_counter++;  // 增加计数器                &#125;                // 显示气压        switch (displayIndex) &#123;            case 0:                sprintf(displayStr, &quot;%d°C&quot;, temp);                break;            case 1:                sprintf(displayStr, &quot;%d%%&quot;, humi);                break;            case 2:                sprintf(displayStr, &quot;%.2fcm&quot;, distance);                break;            case 3:                sprintf((char*)buff, &quot;%.2fhPa   &quot;, (float)Pre);  // 显示气压值                break;                        case 4:                sprintf(displayStr, &quot;%.2fm&quot;, bmp280_temp);  // 显示温度                break;        &#125;                OLED_ShowCH(0, 5, (u8*)displayStr);        OLED_ShowCH(0, 5, buff);                //char tempStr[20];                //sprintf(tempStr, &quot;%.2f&quot;, bmp280_temp);                //OLED_ShowCH(0, 5, (u8 *)tempStr);        displayIndex = (displayIndex + 1) % 4;        delay_ms(500);    &#125;&#125;</code></pre><pre><code>在福建师范大学协和学院度过的四年本科生活即将结束，回顾这段时光，充满了成长与挑战。通过在思想品德、学习科研、社会实践、身体素质等各方面的努力，我不仅提升了个人综合素质，也积累了宝贵的经验，塑造了更加成熟和坚定的自己。在此，我将从以下几个方面对自己进行总结和反思，以便更好地规划未来的发展。在大学期间，我始终把思想品德建设放在首位，积极向上，热心参与各类集体活动，始终保持与时代同步的思想观念，积极参与学校组织的思想政治教育和理论学习，时刻关注国家政策和社会发展动向。我始终坚定自己的理想信念，树立了正确的价值观和人生观。通过不断学习党的方针政策和社会发展理论，我逐渐形成了以人民为中心的发展思想，并通过参与院校志愿者工作、学生干部等岗位实践，培养了自己的责任感和使命感。在校期间，我还积极参加了福建师范大学协和学院院权益部的志愿者工作，协助组织多项校内外活动。这段经历不仅让我深入了解了社会责任和义务，还锻炼了我的组织能力和协调能力。志愿者工作使我更加注重服务他人，关心集体，提升了我的社会责任感和集体主义精神。在未来的工作和生活中，我会继续保持高尚的道德品质，尽自己最大的努力为社会做出贡献。大学期间，我一直保持勤奋学习的态度，在学术上不断挑战自我，勇于探索新的领域。通过深入学习专业课程，我掌握了扎实的专业知识，并且在课外积累了丰富的实践经验。学术上，我不断追求卓越，努力培养自己解决实际问题的能力和创新思维。通过参加“挑战杯”大学生课外学术科技作品竞赛，我不仅丰富了自己的学术素养，也锻炼了我的团队协作能力和项目管理能力，获得了福建师范大学协和学院第六届“挑战杯”大学生课外学术科技作品竞赛优秀奖。在科研方面，我不仅限于课堂知识的学习，还积极参加课题研究，参与了多个与专业相关的研究项目。特别是在“2024睿抗机器人开发者大赛全国总决赛魔力元宝竞赛项目”中，我参与了项目的设计与实现，并获得了全国二等奖。这个奖项的获得，既是我对自己能力的肯定，也是我团队合作精神的体现。通过科研和创新实践，我深刻意识到，理论知识的学习需要与实际应用紧密结合，只有真正解决实际问题，才能提升自己的学术能力和创新能力。大学四年，我积极参加各类社会实践活动，努力将所学的知识运用到实际中去，服务社会，锻炼自己。在校期间，我参与了多项社会实践活动，涵盖了社会调查、志愿服务等多个方面。在参与福建师范大学协和学院院权益部志愿者活动时，我不仅提高了与人沟通交流的能力，还学会了如何组织和协调团队工作。通过这些社会实践，我了解了社会的多样性，增强了社会责任感，并且积累了宝贵的实践经验。此外，我还参加了与专业相关的实习活动，深入企业与社会实践一线，接触并了解了本专业的前沿发展和技术创新。这些实践经历帮助我更加清晰地认识到自己的职业兴趣和发展方向，也为今后的职业生涯积累了实践基础。身体是革命的本钱，我一直认为保持良好的身体素质是实现任何目标的基础。在大学期间，我始终注重锻炼，保持规律的运动习惯，积极参与学校组织的体育活动和集体运动。我经常参加跑步、篮球、游泳等多种运动项目，保持身体健康的同时，也锻炼了我的团队协作能力。通过运动，我不仅强健了体魄，还学会了如何在压力中保持冷静，如何在竞争中不断超越自己。此外，我还参与了多次学校的体育竞赛活动，通过这些活动，不仅提升了自己的身体素质，还增强了我的意志力和团队精神。我深知，只有保持健康的体魄，才能更好地面对未来的挑战。尽管在大学期间我取得了一些成绩，但我也清醒地认识到，自己还有许多不足之处。在学术研究方面，虽然我取得了一定的成绩，但在面对复杂问题时，我有时缺乏足够的耐心和细致的分析能力，未来我需要在这方面加强自己的思维深度和问题解决能力。在社会实践和工作方面，尽管我参与了多个项目，并获得了较为丰富的经验，但我发现自己有时在处理团队问题时缺乏足够的统筹规划能力，容易在忙碌中忽视一些细节。在未来，我将更加注重提升自己的组织管理能力和团队协作能力，以更好地适应职场要求。在个人品德方面，我虽然一直努力保持良好的道德修养，但偶尔也会因为忙碌而忽视自我反思和修炼。因此，我将继续加强自我反省，在日常生活中时刻保持谦逊与耐心，始终保持一颗向上的心态。回顾大学四年，我收获了知识、实践经验、技能和友谊，收获了成长和进步。我会继续保持一颗积极向上的心，脚踏实地，不断提升自己。在未来的工作和生活中，我将继续发扬自己的优点，不断弥补不足，努力成为一名优秀的社会人才，为社会贡献自己的力量。通过不断学习与积累，我相信我能够在职业生涯中迎接更多的挑战，创造更多的价值。</code></pre><pre><code>#include &quot;config.h&quot;#include &quot;stm32f10x.h&quot;#include &quot;delay1.h&quot;#include &quot;bmp280.h&quot;#include &quot;oled_iic.h&quot;#include &lt;stdio.h&gt;#include &quot;dht11.h&quot;#include &quot;servo.h&quot;#include &quot;string.h&quot;#include &quot;sys.h&quot;#include &quot;led.h&quot;#include &quot;ultrasonic.h&quot;#include &quot;timer1.h&quot;#define D1         PBout(0)#define D2         PBout(1)#define LED_SYS    PCout(13)u8 temp;u8 humi;char tempStr[20];char pressStr[20];int num = 30;u8 state = 0;extern char Rx232buffer[Buf_Max];extern u8 recv_status;static float bmp280_press, bmp280_temp;u8 buff[30]; // 参数显示缓存数组u16 Pre;     // 气压检测值char buff1[100]; // 缓存发送数据float Angle = 0; // 初始化角度变量float distance; //超声波测距用的变量/*************************************************************************** * 延时函数 **************************************************************************/void _delay_ms(int i) &#123;    u16 j;    while (i--) &#123;        for (j = 0; j &lt; 5600; j++);    &#125;&#125;/*************************************************************************** * 处理接收数据 **************************************************************************/void hand_recv(void) &#123;    OLED_Clear();    delay_ms(1500);    if (Hand(&quot;ESPKLED1&quot;)) &#123;        //USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led_on();        CLR_Buf();        //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;      else if (Hand(&quot;ESPGLED1&quot;)) &#123;        //USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led_off();        CLR_Buf();        //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;    else if (Hand(&quot;EG&quot;)) &#123;  // 检测到 &quot;EG&quot; 命令        float newAngle = 30;  // 设置舵机旋转30度        Servo_SetAngle(newAngle);  // 设置舵机角度        char angleStr[30];        sprintf(angleStr, &quot;Rotating servo to: %.2f\n&quot;, newAngle);        //USART_printf(USART1, angleStr);  // 通过串口输出    &#125;     else if (Hand(&quot;ON&quot;)) &#123;  // 检测到 &quot;ON&quot; 命令        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led1_on();  // 点亮LD1        CLR_Buf();        //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;    else if (Hand(&quot;OFF&quot;)) &#123;  // 检测到 &quot;OFF&quot; 命令        //USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led1_off();  // 熄灭LD1        CLR_Buf();        //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;&#125;/*************************************************************************** * 发送数据到 ESP8266（HTTP 请求） **************************************************************************/void send_data_to_esp8266(u8 temp, u8 humi, float distance, float pressure) &#123;    char http_request[500];  // 为了确保请求头和请求体足够大的空间    int request_len;    int json_len;    // 1. 建立 TCP 连接到目标服务器    printf(&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;192.168.224.238\&quot;,5002\r\n&quot;);  // 设置目标服务器 IP 和端口    delay_ms(500);  // 等待连接建立    // 连接成功与否检查    if (strstr(Rx232buffer, &quot;OK&quot;) != NULL) &#123;        USART_printf(USART1, &quot;TCP connected\n&quot;);    &#125; else &#123;        USART_printf(USART1, &quot;TCP connection failed, response: %s\n&quot;);        USART_printf(USART1, Rx232buffer);        return;  // 如果连接失败，直接返回    &#125;    // 2. 构造 HTTP POST 请求    json_len = sprintf(http_request + 200, &quot;&#123;\&quot;temp\&quot;: %d, \&quot;humi\&quot;: %d, \&quot;distance\&quot;: %.2f, \&quot;pressure\&quot;: %.2f&#125;&quot;,                       temp, humi, distance, pressure);    // 计算 Content-Length    request_len = sprintf(http_request,            &quot;POST / HTTP/1.1\r\n&quot;            &quot;Host: 192.168.224.238:5002\r\n&quot;            &quot;Content-Type: application/json\r\n&quot;            &quot;Content-Length: %d\r\n&quot;            &quot;Connection: close\r\n\r\n&quot;,            json_len); // Content-Length是JSON数据的长度    // 拼接请求头和请求体    strcat(http_request, http_request + 200);    // 打印构造的 HTTP 请求（调试信息）    USART_printf(USART1, &quot;Sending HTTP request:\n&quot;);    USART_printf(USART1, http_request);  // 打印 HTTP 请求    // 3. 发送 HTTP 请求数据前，首先告诉 ESP8266 要发送的数据长度    printf(&quot;AT+CIPSEND=%d\r\n&quot;, request_len);  // 通知 ESP8266 发送的数据长度    delay_ms(500);  // 等待响应    // 等待 ESP8266 返回 &quot;OK&quot;，表示它已经准备好接收数据    if (strstr(Rx232buffer, &quot;&gt;&quot;) == NULL) &#123;            USART_printf(USART1,  &quot;ESP8266 not ready to send data, response: %s\n&quot;);        USART_printf(USART1, Rx232buffer);        return;  // 如果 ESP8266 没有返回 &quot;&gt;&quot;, 就说明它没有准备好接收数据    &#125;    // 4. 发送 HTTP 请求数据    printf(&quot;%s&quot;, http_request);  // 发送 HTTP 请求    delay_ms(1500);  // 延长延时，确保请求数据已经完全发送    // 5. 等待 ESP8266 响应    if (strstr(Rx232buffer, &quot;SEND OK&quot;) == NULL) &#123;              USART_printf(USART1, &quot;Failed to send HTTP request, response: %s\n&quot;);        USART_printf(USART1,  Rx232buffer);        USART_printf(USART1, &quot;Retrying...\n&quot;);        delay_ms(2000);  // 延迟后重试        return;  // 如果没有得到预期响应，返回    &#125;    // 6. 关闭 TCP 连接    printf(&quot;AT+CIPCLOSE\r\n&quot;);    delay_ms(1000);  // 延长延时，确保连接关闭    if (strstr(Rx232buffer, &quot;CLOSED&quot;) != NULL) &#123;        USART_printf(USART1, &quot;TCP connection closed successfully\n&quot;);    &#125; else &#123;            USART_printf(USART1, &quot;Failed to send TCP request, response: %s\n&quot;);        USART_printf(USART1,  Rx232buffer);    &#125;    CLR_Buf();  // 清空缓冲区&#125;/*************************************************************************** * 8266 配置函数 **************************************************************************/void config_8266(void) &#123;    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CWMODE=1\r\n&quot;); // 设置为 Station 模式        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();        while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CWJAP=\&quot;666\&quot;,\&quot;a1234567\&quot;\r\n&quot;); // 连接到指定的热点        delay_ms(2000);                printf(&quot;ESP8266 Wi-Fi connection status: %s\n&quot;, Rx232buffer);  // 打印连接状态    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();        delay_ms(500);                printf(&quot;AT+GMR\r\n&quot;);        delay_ms(500);        // 在启动服务器前加入一些延时        delay_ms(5000);    /*    // 启动服务器端口5002        while (!(Hand(&quot;OK&quot;))) &#123;                printf(&quot;AT+CIPSERVER=1,5002\r\n&quot;);  // 配置 ESP8266 为 TCP 服务器，监听端口5002                delay_ms(500);                // 检查是否成功启动服务器                if (strstr(Rx232buffer, &quot;OK&quot;) != NULL) &#123;                        printf(&quot;***************************************** Server started on port 5002\n&quot;);                        break;  // 成功启动后跳出循环                &#125; else if (strstr(Rx232buffer, &quot;ERROR&quot;) != NULL) &#123;                        printf(&quot;ESP8266: Failed to start server on port 5002\n&quot;);                        break;  // 如果启动失败，跳出循环                &#125; else &#123;                        printf(&quot;ESP8266: Unexpected response: %s\n&quot;, Rx232buffer);  // 输出返回的串口数据                        delay_ms(1000);                &#125;        &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();        */    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CIFSR\r\n&quot;);        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    delay_ms(1500);    CLR_Buf();&#125;/*************************************************************************** * 主函数 **************************************************************************/int main(void) &#123;     SystemInit();  // 配置系统时钟为72M      delay_init(72);    led_init();    delay_ms(500);    LED_SYS = !LED_SYS;    delay_ms(500);    LED_SYS = !LED_SYS;    delay_ms(500);    Ultrasonic_Init();  // 测距初始化    OLED_Clear();    OLED_Init();    delay_ms(1500);    Servo_Init();    USART1_Init();    USART_printf(USART1, &quot;欢迎使用STM32开发板\n\n&quot;);    esp8266_init();    LED_SYS = !LED_SYS;    delay_ms(500);    USART3_Init();    LED_SYS = !LED_SYS;    delay_ms(100);    config_8266();  // 配置ESP8266    delay_ms(500);        while (BMP280Init()) &#123;        USART_printf(USART1, &quot;BMP280初始化失败！\n&quot;);        delay_ms(1000);    &#125;    while (DHT11_Init()) &#123;        USART_printf(USART1, &quot;DHT11初始化失败！\n&quot;);        delay_ms(1000);    &#125;    OLED_Clear();    int displayIndex = 0;    char displayStr[20];    int send_counter = 0;    while (1) &#123;        if (recv_status == 1) &#123;            hand_recv();  // 处理接收到的数据            recv_status = 0;        &#125;                DHT11_Read_Data(&amp;temp, &amp;humi);  // 读取温湿度        BMP280GetData(&amp;bmp280_press, &amp;bmp280_temp, &amp;bmp280_temp);  // 获取气压数据        distance = UltrasonicGetLength();  // 获取超声波测量的距离                // 每2次循环发送一次HTTP请求        if (send_counter == 2) &#123;            send_data_to_esp8266(temp, humi, distance, (float)Pre);  // 发送数据到ESP8266            send_counter = 0;        &#125; else &#123;            send_counter++;  // 增加计数器        &#125;                        switch (displayIndex) &#123;            case 0:                sprintf(displayStr, &quot;%d°C&quot;, temp);                break;            case 1:                sprintf(displayStr, &quot;%d%%&quot;, humi);                break;            case 2:                sprintf(displayStr, &quot;%.2fcm&quot;, distance);                break;            case 3:                sprintf((char*)buff, &quot;%.2fhPa   &quot;, (float)Pre);  // 显示气压值                break;                        case 4:                sprintf(displayStr, &quot;%.2fm&quot;, bmp280_temp);  // 显示温度                break;        &#125;                OLED_ShowCH(0, 5, (u8*)displayStr);        OLED_ShowCH(0, 5, buff);                //char tempStr[20];                //sprintf(tempStr, &quot;%.2f&quot;, bmp280_temp);                //OLED_ShowCH(0, 5, (u8 *)tempStr);        displayIndex = (displayIndex + 1) % 4;        delay_ms(500);    &#125;&#125;</code></pre><pre><code>#include &quot;config.h&quot;#include &quot;stm32f10x.h&quot;#include &quot;delay1.h&quot;#include &quot;bmp280.h&quot;#include &quot;oled_iic.h&quot;#include &lt;stdio.h&gt;#include &quot;dht11.h&quot;#include &quot;servo.h&quot;#include &quot;string.h&quot;#include &quot;sys.h&quot;#include &quot;led.h&quot;#include &quot;ultrasonic.h&quot;#include &quot;timer1.h&quot;#define D1         PBout(0)#define D2         PBout(1)#define LED_SYS    PCout(13)u8 temp;u8 humi;char tempStr[20];char pressStr[20];int num = 30;u8 state = 0;extern char Rx232buffer[Buf_Max];extern u8 recv_status;static float bmp280_press, bmp280_temp;u8 buff[30]; // 参数显示缓存数组u16 Pre;     // 气压检测值char buff1[100]; // 缓存发送数据float Angle = 0; // 初始化角度变量float distance; //超声波测距用的变量/*************************************************************************** * 延时函数 **************************************************************************/void _delay_ms(int i) &#123;    u16 j;    while (i--) &#123;        for (j = 0; j &lt; 5600; j++);    &#125;&#125;/*************************************************************************** * 处理接收数据 **************************************************************************/void hand_recv(void) &#123;    OLED_Clear();    delay_ms(1500);    if (Hand(&quot;ESPKLED1&quot;)) &#123;        //USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led_on();        CLR_Buf();        //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;      else if (Hand(&quot;ESPGLED1&quot;)) &#123;        //USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led_off();        CLR_Buf();        //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;    else if (Hand(&quot;EG&quot;)) &#123;  // 检测到 &quot;EG&quot; 命令        float newAngle = 30;  // 设置舵机旋转30度        Servo_SetAngle(newAngle);  // 设置舵机角度        char angleStr[30];        sprintf(angleStr, &quot;Rotating servo to: %.2f\n&quot;, newAngle);        //USART_printf(USART1, angleStr);  // 通过串口输出    &#125;     else if (Hand(&quot;ON&quot;)) &#123;  // 检测到 &quot;ON&quot; 命令        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led1_on();  // 点亮LD1        CLR_Buf();        //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;    else if (Hand(&quot;OFF&quot;)) &#123;  // 检测到 &quot;OFF&quot; 命令        //USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);        led1_off();  // 熄灭LD1        CLR_Buf();        //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);    &#125;&#125;/*************************************************************************** * 发送数据到 ESP8266（HTTP 请求） **************************************************************************/void send_data_to_esp8266(u8 temp, u8 humi, float distance, float pressure) &#123;    char http_request[500];  // 为了确保请求头和请求体足够大的空间    int request_len;    int json_len;    // 1. 建立 TCP 连接到目标服务器    printf(&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;192.168.224.238\&quot;,5002\r\n&quot;);  // 设置目标服务器 IP 和端口    delay_ms(500);  // 等待连接建立    // 连接成功与否检查    if (strstr(Rx232buffer, &quot;OK&quot;) != NULL) &#123;        USART_printf(USART1, &quot;TCP connected\n&quot;);    &#125; else &#123;        USART_printf(USART1, &quot;TCP connection failed, response: %s\n&quot;);        USART_printf(USART1, Rx232buffer);        return;  // 如果连接失败，直接返回    &#125;    // 2. 构造 HTTP POST 请求    json_len = sprintf(http_request + 200, &quot;&#123;\&quot;temp\&quot;: %d, \&quot;humi\&quot;: %d, \&quot;distance\&quot;: %.2f, \&quot;pressure\&quot;: %.2f&#125;&quot;,                       temp, humi, distance, pressure);    // 计算 Content-Length    request_len = sprintf(http_request,            &quot;POST / HTTP/1.1\r\n&quot;            &quot;Host: 192.168.224.238:5002\r\n&quot;            &quot;Content-Type: application/json\r\n&quot;            &quot;Content-Length: %d\r\n&quot;            &quot;Connection: close\r\n\r\n&quot;,            json_len); // Content-Length是JSON数据的长度    // 拼接请求头和请求体    strcat(http_request, http_request + 200);    // 打印构造的 HTTP 请求（调试信息）    USART_printf(USART1, &quot;Sending HTTP request:\n&quot;);    USART_printf(USART1, http_request);  // 打印 HTTP 请求    // 3. 发送 HTTP 请求数据前，首先告诉 ESP8266 要发送的数据长度    printf(&quot;AT+CIPSEND=%d\r\n&quot;, request_len);  // 通知 ESP8266 发送的数据长度    delay_ms(500);  // 等待响应    // 等待 ESP8266 返回 &quot;OK&quot;，表示它已经准备好接收数据    if (strstr(Rx232buffer, &quot;&gt;&quot;) == NULL) &#123;            USART_printf(USART1,  &quot;ESP8266 not ready to send data, response: %s\n&quot;);        USART_printf(USART1, Rx232buffer);        return;  // 如果 ESP8266 没有返回 &quot;&gt;&quot;, 就说明它没有准备好接收数据    &#125;    // 4. 发送 HTTP 请求数据    printf(&quot;%s&quot;, http_request);  // 发送 HTTP 请求    delay_ms(1500);  // 延长延时，确保请求数据已经完全发送    // 5. 等待 ESP8266 响应    if (strstr(Rx232buffer, &quot;SEND OK&quot;) == NULL) &#123;              USART_printf(USART1, &quot;Failed to send HTTP request, response: %s\n&quot;);        USART_printf(USART1,  Rx232buffer);        USART_printf(USART1, &quot;Retrying...\n&quot;);        delay_ms(2000);  // 延迟后重试        return;  // 如果没有得到预期响应，返回    &#125;    // 6. 关闭 TCP 连接    printf(&quot;AT+CIPCLOSE\r\n&quot;);    delay_ms(1000);  // 延长延时，确保连接关闭    if (strstr(Rx232buffer, &quot;CLOSED&quot;) != NULL) &#123;        USART_printf(USART1, &quot;TCP connection closed successfully\n&quot;);    &#125; else &#123;            USART_printf(USART1, &quot;Failed to send TCP request, response: %s\n&quot;);        USART_printf(USART1,  Rx232buffer);    &#125;    CLR_Buf();  // 清空缓冲区&#125;/*************************************************************************** * 8266 配置函数 **************************************************************************/void config_8266(void) &#123;    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CWMODE=1\r\n&quot;); // 设置为 Station 模式        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();        while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CWJAP=\&quot;666\&quot;,\&quot;a1234567\&quot;\r\n&quot;); // 连接到指定的热点        delay_ms(2000);                printf(&quot;ESP8266 Wi-Fi connection status: %s\n&quot;, Rx232buffer);  // 打印连接状态    &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();        delay_ms(500);                printf(&quot;AT+GMR\r\n&quot;);        delay_ms(500);        // 在启动服务器前加入一些延时        delay_ms(5000);    /*    // 启动服务器端口5002        while (!(Hand(&quot;OK&quot;))) &#123;                printf(&quot;AT+CIPSERVER=1,5002\r\n&quot;);  // 配置 ESP8266 为 TCP 服务器，监听端口5002                delay_ms(500);                // 检查是否成功启动服务器                if (strstr(Rx232buffer, &quot;OK&quot;) != NULL) &#123;                        printf(&quot;***************************************** Server started on port 5002\n&quot;);                        break;  // 成功启动后跳出循环                &#125; else if (strstr(Rx232buffer, &quot;ERROR&quot;) != NULL) &#123;                        printf(&quot;ESP8266: Failed to start server on port 5002\n&quot;);                        break;  // 如果启动失败，跳出循环                &#125; else &#123;                        printf(&quot;ESP8266: Unexpected response: %s\n&quot;, Rx232buffer);  // 输出返回的串口数据                        delay_ms(1000);                &#125;        &#125;    USART_printf(USART1, Rx232buffer);    CLR_Buf();        */    while (!(Hand(&quot;OK&quot;))) &#123;        printf(&quot;AT+CIFSR\r\n&quot;);        delay_ms(500);    &#125;    USART_printf(USART1, Rx232buffer);    delay_ms(1500);    CLR_Buf();&#125;/*************************************************************************** * 主函数 **************************************************************************/int main(void) &#123;     SystemInit();  // 配置系统时钟为72M      delay_init(72);    led_init();    delay_ms(500);    LED_SYS = !LED_SYS;    delay_ms(500);    LED_SYS = !LED_SYS;    delay_ms(500);    Ultrasonic_Init();  // 测距初始化    OLED_Clear();    OLED_Init();    delay_ms(1500);    Servo_Init();    USART1_Init();    USART_printf(USART1, &quot;欢迎使用STM32开发板\n\n&quot;);    esp8266_init();    LED_SYS = !LED_SYS;    delay_ms(500);    USART3_Init();    LED_SYS = !LED_SYS;    delay_ms(100);    config_8266();  // 配置ESP8266    delay_ms(500);        while (BMP280Init()) &#123;        USART_printf(USART1, &quot;BMP280初始化失败！\n&quot;);        delay_ms(1000);    &#125;    while (DHT11_Init()) &#123;              delay_ms(1000);        USART_printf(USART1, &quot;DHT11初始化失败！\n&quot;);        delay_ms(1000);    &#125;    OLED_Clear();    int displayIndex = 0;    char displayStr[20];    int send_counter = 0;    while (1) &#123;        if (recv_status == 1) &#123;            hand_recv();  // 处理接收到的数据            recv_status = 0;        &#125;                DHT11_Read_Data(&amp;temp, &amp;humi);  // 读取温湿度                        BMP280GetData(&amp;bmp280_press, &amp;bmp280_temp, &amp;bmp280_temp);  // 获取气压数据        distance = UltrasonicGetLength();  // 获取超声波测量的距离                // 每2次循环发送一次HTTP请求        if (send_counter == 2) &#123;            send_data_to_esp8266(temp, humi, distance, (float)Pre);  // 发送数据到ESP8266            send_counter = 0;        &#125; else &#123;            send_counter++;  // 增加计数器        &#125;                // 打印读取的温湿度、大气压        char debugStr[100];        sprintf(debugStr, &quot;Temp: %d°C, Humi: %d%%, Pressure: %.2f hPa, Distance: %.2f cm&quot;, temp, humi, bmp280_press, distance);        USART_printf(USART1, debugStr);  // 打印到串口                        switch (displayIndex) &#123;            case 0:                sprintf(displayStr, &quot;%d°C&quot;, temp);                break;            case 1:                sprintf(displayStr, &quot;%d%%&quot;, humi);                break;            case 2:                sprintf(displayStr, &quot;%.2fcm&quot;, distance);                break;            case 3:                sprintf(displayStr, &quot;%.2fhPa   &quot;, (float)Pre);  // 显示气压值                break;                        case 4:                sprintf(displayStr, &quot;%.2fm&quot;, bmp280_temp);  // 显示温度                break;        &#125;                OLED_ShowCH(0, 5, (u8*)displayStr);        //OLED_ShowCH(0, 5, buff);                //char tempStr[20];                //sprintf(tempStr, &quot;%.2f&quot;, bmp280_temp);                //OLED_ShowCH(0, 5, (u8 *)tempStr);        displayIndex = (displayIndex + 1) % 5;        delay_ms(500);    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> stm32、ROS、Springboot3、Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>若依实现实训</title>
      <link href="/2024/09/03/%E8%8B%A5%E4%BE%9D%E5%AE%9E%E7%8E%B0%E5%AE%9E%E8%AE%AD/"/>
      <url>/2024/09/03/%E8%8B%A5%E4%BE%9D%E5%AE%9E%E7%8E%B0%E5%AE%9E%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot-业务流程"><a href="#Springboot-业务流程" class="headerlink" title="Springboot 业务流程"></a>Springboot 业务流程</h1><h2 id="层次逻辑"><a href="#层次逻辑" class="headerlink" title="层次逻辑"></a>层次逻辑</h2><ol><li><strong>Controller（控制器层）</strong>:<ul><li>位于 <code>src/main/java/com/example/springbootdemo/controller/</code> 目录。</li><li>处理来自客户端的 HTTP 请求，调用 Service 层执行业务逻辑，返回结果给客户端。</li><li>通常使用 <code>@RestController</code> 注解。</li></ul></li><li><strong>Service（业务逻辑层）</strong>:<ul><li>位于 <code>src/main/java/com/example/springbootdemo/service/</code> 目录，<code>impl/</code> 目录存放具体的实现类。</li><li>负责处理业务逻辑，与 Repository 层交互。</li><li>通常使用 <code>@Service</code> 注解。</li></ul></li><li><strong>Mapper&#x2F;Repository（数据访问层）</strong>:<ul><li>位于 <code>src/main/java/com/example/springbootdemo/mapper/</code> 目录。</li><li>用于和数据库进行交互，执行数据库的增删改查操作。</li><li>通常使用 <code>@Mapper</code>（MyBatis）或者 <code>@Repository</code>（JPA）注解。</li></ul></li><li><strong>Pojo（实体类层）</strong>:<ul><li>位于 <code>src/main/java/com/example/springbootdemo/pojo/</code> 目录。</li><li>存放实体类（对应数据库表的结构），比如 <code>User</code> 对象。</li></ul></li><li><strong>Config（配置层）</strong>:<ul><li>位于 <code>src/main/java/com/example/springbootdemo/config/</code> 目录。</li><li>存放项目的配置类，比如数据库配置、安全配置、全局跨域配置等。</li></ul></li><li><strong>Utils（工具类层）</strong>:<ul><li>位于 <code>src/main/java/com/example/springbootdemo/utils/</code> 目录。</li><li>存放常用的工具类，比如日期转换、字符串处理等。</li></ul></li><li><strong>Resources（资源层）</strong>:<ul><li>位于 <code>src/main/resources/</code> 目录。</li><li>存放项目的配置文件（如 <code>application.properties</code>）、静态资源（如 HTML、CSS、JS）、以及 Mapper 的 XML 配置文件（如果使用 MyBatis）。</li></ul></li><li><strong>Test（测试层）</strong>:<ul><li>位于 <code>src/test/</code> 目录。</li><li>存放测试类，用于编写单元测试和集成测试。</li></ul></li></ol><h3 id="如果需要扩展层级结构，通常可以增加："><a href="#如果需要扩展层级结构，通常可以增加：" class="headerlink" title="如果需要扩展层级结构，通常可以增加："></a>如果需要扩展层级结构，通常可以增加：</h3><ul><li><strong>DTO（Data Transfer Object）</strong>：用于在 Controller 和 Service 之间传输数据。</li><li><strong>Exception Handling（异常处理层）</strong>：集中处理全局异常。</li></ul><pre><code class="mysql">CREATE TABLE user_profiles (    id INT AUTO_INCREMENT PRIMARY KEY,                    -- 用户唯一标识    name VARCHAR(255) NOT NULL,                           -- 姓名    identity VARCHAR(255) NOT NULL,                       -- 身份    contact VARCHAR(255) NOT NULL,                        -- 紧急联系人    contact_phone VARCHAR(20) NOT NULL,                   -- 紧急联系人电话    contact_relationship VARCHAR(50),                     -- 紧急联系人关系    age INT NOT NULL,                                     -- 年龄    gender ENUM(&#39;male&#39;, &#39;female&#39;) NOT NULL,               -- 性别    health TEXT,                                          -- 健康状况    address VARCHAR(255),                                 -- 家庭住址    face_image VARCHAR(255),                              -- 人脸图片文件路径    profile_photo VARCHAR(255),                           -- 个人照片文件路径    medical_history TEXT,                                 -- 医疗历史    email VARCHAR(255),                                   -- 电子邮件    status ENUM(&#39;active&#39;, &#39;inactive&#39;, &#39;terminated&#39;) DEFAULT &#39;active&#39;, -- 用户状态    notes TEXT,                                           -- 备注    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,       -- 记录创建时间    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP -- 最后更新时间);</code></pre><h3 id="1-项目设置"><a href="#1-项目设置" class="headerlink" title="1. 项目设置"></a>1. <strong>项目设置</strong></h3><ul><li><strong>创建项目</strong>：使用 Spring Initializr（<a href="https://start.spring.io/">start.spring.io</a>）或其他工具创建一个新的 Spring Boot 项目。</li><li><strong>配置依赖</strong>：在 <code>pom.xml</code>（Maven）或 <code>build.gradle</code>（Gradle）中添加所需的依赖，例如 Web、JPA、MySQL 等。</li></ul><h3 id="2-创建实体类（Model）"><a href="#2-创建实体类（Model）" class="headerlink" title="2. 创建实体类（Model）"></a>2. <strong>创建实体类（Model）</strong></h3><ul><li><strong>定义实体类</strong>：在 <code>src/main/java/com/example/yourproject/pojo</code> 目录中创建实体类，使用 <code>@Entity</code> 注解标记它。</li><li><strong>映射到数据库</strong>：使用 <code>@Table</code> 注解指定数据库表名，使用 <code>@Column</code> 注解映射字段到表的列。</li></ul><h3 id="3-创建数据访问层（Repository）"><a href="#3-创建数据访问层（Repository）" class="headerlink" title="3. 创建数据访问层（Repository）"></a>3. <strong>创建数据访问层（Repository）</strong></h3><ul><li><strong>创建接口</strong>：在 <code>src/main/java/com/example/yourproject/repository</code> 目录中创建接口，继承 <code>JpaRepository</code> 或 <code>CrudRepository</code>。</li><li><strong>自定义查询</strong>：如果需要，可以在接口中定义自定义查询方法。</li></ul><h3 id="4-创建服务层（Service）"><a href="#4-创建服务层（Service）" class="headerlink" title="4. 创建服务层（Service）"></a>4. <strong>创建服务层（Service）</strong></h3><ul><li><strong>定义业务逻辑</strong>：在 <code>src/main/java/com/example/yourproject/service</code> 目录中创建服务类，使用 <code>@Service</code> 注解标记它。</li><li><strong>实现业务方法</strong>：在服务类中实现业务逻辑，并调用数据访问层的方法。</li></ul><h3 id="5-创建控制层（Controller）"><a href="#5-创建控制层（Controller）" class="headerlink" title="5. 创建控制层（Controller）"></a>5. <strong>创建控制层（Controller）</strong></h3><ul><li><strong>定义 REST API</strong>：在 <code>src/main/java/com/example/yourproject/controller</code> 目录中创建控制器类，使用 <code>@RestController</code> 注解标记它。</li><li><strong>映射请求</strong>：使用 <code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code> 等注解映射 HTTP 请求到相应的处理方法。</li></ul><h3 id="6-配置应用程序（Configuration）"><a href="#6-配置应用程序（Configuration）" class="headerlink" title="6. 配置应用程序（Configuration）"></a>6. <strong>配置应用程序（Configuration）</strong></h3><ul><li><strong>数据库配置</strong>：在 <code>src/main/resources/application.properties</code> 或 <code>application.yml</code> 文件中配置数据库连接信息、JPA 设置等。</li><li><strong>其他配置</strong>：配置安全、消息队列、缓存等其他组件。</li></ul><h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. <strong>测试</strong></h3><ul><li><strong>编写测试</strong>：在 <code>src/test/java/com/example/yourproject</code> 目录中编写单元测试和集成测试，使用 <code>@SpringBootTest</code> 注解加载 Spring 上下文进行测试。</li><li><strong>运行测试</strong>：运行测试以确保应用程序的功能正常。</li></ul><h3 id="8-运行和部署"><a href="#8-运行和部署" class="headerlink" title="8. 运行和部署"></a>8. <strong>运行和部署</strong></h3><ul><li><strong>运行应用</strong>：通过 IDE 或使用命令行（<code>mvn spring-boot:run</code> 或 <code>./gradlew bootRun</code>）运行应用程序。</li><li><strong>打包和部署</strong>：使用 Maven 或 Gradle 打包应用程序，生成可执行的 JAR 文件或 WAR 文件，然后部署到服务器或云平台上。</li></ul><h3 id="业务流程示例："><a href="#业务流程示例：" class="headerlink" title="业务流程示例："></a>业务流程示例：</h3><p>假设你有一个简单的用户管理系统，业务流程可能如下：</p><ol><li><strong>用户注册</strong>：用户提交注册表单，控制器接收请求并调用服务层的注册方法。服务层处理业务逻辑并保存用户数据到数据库。返回注册成功的响应。</li><li><strong>用户登录</strong>：用户提交登录信息，控制器接收请求并调用服务层的登录方法。服务层验证用户身份并生成认证令牌（如 JWT）。返回认证结果和令牌。</li><li><strong>用户查询</strong>：用户请求查看个人信息，控制器接收请求并调用服务层的方法获取用户数据。服务层从数据库中检索数据并返回给控制器。控制器将数据发送给用户。</li><li><strong>用户更新</strong>：用户提交更新信息，控制器接收请求并调用服务层的更新方法。服务层处理业务逻辑并更新用户数据到数据库。返回更新结果。</li></ol><h2 id="查询全部数据"><a href="#查询全部数据" class="headerlink" title="查询全部数据"></a>查询全部数据</h2><pre><code>http://localhost:5024/user-profiles/list</code></pre><p><img src="/assets/image-20240905155142697.png" alt="image-20240905155142697"></p><h2 id="vue3接收路由"><a href="#vue3接收路由" class="headerlink" title="vue3接收路由"></a>vue3接收路由</h2>]]></content>
      
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ros和实时目标检测算法的伤员搜救场景应用</title>
      <link href="/2024/08/08/%E5%9F%BA%E4%BA%8Eros%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%A4%E5%91%98%E6%90%9C%E6%95%91%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8/"/>
      <url>/2024/08/08/%E5%9F%BA%E4%BA%8Eros%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%A4%E5%91%98%E6%90%9C%E6%95%91%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基于ros和实时目标检测算法的伤员搜救场景应用"><a href="#基于ros和实时目标检测算法的伤员搜救场景应用" class="headerlink" title="基于ros和实时目标检测算法的伤员搜救场景应用"></a>基于ros和实时目标检测算法的伤员搜救场景应用</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ul><li><input checked="" disabled="" type="checkbox"> 实时目标检测（yolo检测伤员并进行标定）</li><li><input disabled="" type="checkbox"> web框架 ，伤员录入，报警界面，小车实时监控界面</li><li><input disabled="" type="checkbox"> 扩展功能</li><li><input disabled="" type="checkbox"> </li></ul><pre><code></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 福建省赛（福建师范大学举办） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人巡检系统实现</title>
      <link href="/2024/07/14/%E6%97%A0%E4%BA%BA%E5%B7%A1%E6%A3%80%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/07/14/%E6%97%A0%E4%BA%BA%E5%B7%A1%E6%A3%80%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="实时监控方案"><a href="#实时监控方案" class="headerlink" title="实时监控方案"></a>实时监控方案</h2><p> Flask、Node.js 和 Vue.js 组合起来，实现视频流处理、实时视频检测、WebSocket 连接以及与 Raspberry Pi 的通信，我们需要确保每个部分都正确连接并能够互相通信。 Flask 部分 用于视频流处理和对象检测。 使用 OpenCV 和 YOLOv5 进行实时视频检测。 在检测到“down”信号时发送给树莓派。 Node.js 部分 用于处理来自前端的 WebSocket 连接。 通过 Socket.IO 接收flask(Node.js 作为中间层) Vue.js 部分 用于展示控制界面和实时视频流和 WebSocket 连接并展示rviz地图 </p><h3 id="摄像头视频流可行-检测可行-发送到树莓派应该也可行"><a href="#摄像头视频流可行-检测可行-发送到树莓派应该也可行" class="headerlink" title="摄像头视频流可行 检测可行 发送到树莓派应该也可行"></a>摄像头视频流可行 检测可行 发送到树莓派应该也可行</h3><h1 id="2024-7-19"><a href="#2024-7-19" class="headerlink" title="2024&#x2F;7&#x2F;19"></a>2024&#x2F;7&#x2F;19</h1><p>实现 巡检大部分功能 细化 比如地图保存 样式图标美化</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407192028385.png" alt="image-20240719202810422"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407192116453.png" alt="image-20240719224600013"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407192306973.png" alt="image-20240720003612299"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407192349875.png"></p><p>下一步 修改巡航区域</p><h1 id="2024-7-20"><a href="#2024-7-20" class="headerlink" title="2024&#x2F;7&#x2F;20"></a>2024&#x2F;7&#x2F;20</h1><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407230115204.png" alt="image-20240723000118109"></p><h1 id="鸿蒙"><a href="#鸿蒙" class="headerlink" title="鸿蒙"></a>鸿蒙</h1><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210003524.png" alt="image-20240721000342451"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210003057.png" alt="image-20240721000357991"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210004329.png" alt="image-20240721000423245"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210004268.png" alt="image-20240721000435204"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210004547.png" alt="image-20240721000449481"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210005667.png" alt="image-20240721000501594"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210005702.png" alt="image-20240721000511636"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210005673.png" alt="image-20240721000531611"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210005563.png" alt="image-20240721000540502"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210005749.png" alt="image-20240721000548681"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210005035.png" alt="image-20240721000557951"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210006317.png" alt="image-20240721000610259"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210006873.png" alt="image-20240721000618814"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210006583.png" alt="image-20240721000627516"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210006092.png" alt="image-20240721000641019"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210006450.png" alt="image-20240721000650385"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210007877.png" alt="image-20240721000701794"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210007568.png" alt="image-20240721000718494"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210007809.png" alt="image-20240721000727733"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210007172.png" alt="image-20240721000741069"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210007791.png" alt="image-20240721000755700"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210008794.png" alt="image-20240721000804721"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210010011.png" alt="image-20240721001025871"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202407210010345.png" alt="image-20240721001039195"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统期末复习笔记</title>
      <link href="/2024/06/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/06/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="ros"><a href="#ros" class="headerlink" title="ros"></a>ros</h1><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271227218.png" alt="image-20240627122745164" style="zoom:100%;" /><p>编译工作空间 CMake</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271400030.png" alt="image-20240627140005928"></p><p>首先在工作空间 catkin_ws&#x2F;src&#x2F; 下递归的查找其中每一个ROS的package。</p><p>2.package中会有 package.xml 和 CMakeLists.txt 文件，Catkin(CMake)编译系统依据 CMakeLists.txt 文件,从而生成 makefiles (放在 catkin_ws&#x2F;build&#x2F;)。</p><p>3.然后 make 刚刚生成的 makefiles 等文件，编译链接生成可执行文件(放在 catkin_ws&#x2F;devel )。</p><p>也就是说，Catkin就是将 cmake 与 make 指令做了一个封装从而完成整个编译过程的工具。catkin有比较突出的优点，主要是：操作更加简单一次配置，多次使用跨依赖项目编译。</p><p>要用catkin编译一个工程或软件包，只需要用 catkin_make 指令。一般当我们写完代码，执行一次 catkin_make 进行编译,调用系统自动完成编译和链接过程，构建生成目标文件</p><pre><code>cd ~/ros_workspace/catkin_makesource ~/ros_workspace/devel/setup.bash</code></pre><h2 id="任何ROS程序只有组织成package功能包才能编译"><a href="#任何ROS程序只有组织成package功能包才能编译" class="headerlink" title="任何ROS程序只有组织成package功能包才能编译"></a>任何ROS程序只有组织成package功能包才能编译</h2><h2 id="Package结构："><a href="#Package结构：" class="headerlink" title="Package结构："></a>Package结构：</h2><p>一个package下常见的文件、路径有：</p><p>├── CMakeLists.txt #package的编译规则(必须)</p><p>├── package.xml #package的描述信息(必须)</p><p>├── src&#x2F; #源代码文件</p><p>├── include&#x2F; #C++头文件</p><p>├── scripts&#x2F; #可执行脚本</p><p>├── msg&#x2F; #自定义消息</p><p>├── srv&#x2F; #自定义服务</p><p>├── models&#x2F; #3D模型文件</p><p>├── urdf&#x2F; #urdf文件</p><p>├── launch&#x2F; #launch文件</p><p>其中定义package的是 CMakeLists.txt 和 package.xml ，这两个文件是package中必不可少的。catkin编译系统在编译前，首先就要解析这两个文件。这两个文件就定义了一个package。</p><ol><li>CMakeLists.txt: 定义package的包名、依赖、源文件、目标文件等编译规则，是package不可少的成分；</li><li>package.xml: 描述package的包名、版本号、作者、依赖等信息，是package不可少的成分；</li><li>src&#x2F;: 存放ROS的源代码，包括C++的源码和(.cpp)以及Python的module(.py)；</li><li>include&#x2F;: 存放C++源码对应的头文件；</li><li>scripts&#x2F;: 存放可执行脚本，例如shell脚本(.sh)、Python脚本(.py)；</li><li>msg&#x2F;: 存放自定义格式的消息(.msg)；</li><li>srv&#x2F;: 存放自定义格式的服务(.srv)；</li><li>models&#x2F;: 存放机器人或仿真场景的3D模型(.sda, .stl, .dae等)；</li><li>urdf&#x2F;: 存放机器人的模型描述(.urdf或.xacro)；</li><li>launch&#x2F;: 存放launch文件(.launch或.xml)；</li></ol><h2 id="Package功能包创建"><a href="#Package功能包创建" class="headerlink" title="Package功能包创建"></a>Package功能包创建</h2><pre><code>catkin_create_pkg package depends</code></pre><pre><code>cd ~/ros_workspace /src #切到功能包创建目录catkin_create_pkg test_pkg roscpp rospy std_msgs #创建名字为test_pkg 的功能包，依赖了roscpp,rospy,std_msgs</code></pre><p>这样就会在当前路径下新建 test_pkg 软件包，包括：</p><p>├── CMakeLists.txt</p><p>├── include</p><p>│ └── test_pkg</p><p>├── package.xml</p><p>└── src</p><p>catkin_create_pkg 帮你完成了软件包的初始化，填充好了 CMakeLists.txt 和 package.xml ，并且将依赖项填进了这两个文件中。</p><h3 id="Package相关命令"><a href="#Package相关命令" class="headerlink" title="Package相关命令"></a>Package相关命令</h3><p><strong>rospack</strong>：</p><p>rospack是对package管理的工具，命令的用法如下：</p><p>表2.1 rospack命令</p><table><thead><tr><th>rospack命令</th><th>作用</th></tr></thead><tbody><tr><td>rospack help</td><td>显示rospack的用法</td></tr><tr><td>rospack list</td><td>列出本机所有package</td></tr><tr><td>rospack depends [package]</td><td>显示package的依赖包</td></tr><tr><td>rospack find [package]</td><td>定位某个package</td></tr><tr><td>rospack profile</td><td>刷新所有package的位置记录</td></tr></tbody></table><p><strong>roscd</strong>：</p><p>roscd 命令类似与Linux系统的 cd ，改进之处在于 roscd 可以直接 cd 到ROS的软件包。</p><p>表2.2 roscd命令</p><table><thead><tr><th>roscd命令</th><th>作用</th></tr></thead><tbody><tr><td>roscd [pacakge]</td><td>cd到ROS package所在路径</td></tr></tbody></table><p><strong>rosls:</strong></p><p>rosls 也可以视为Linux指令 ls 的改进版，可以直接 ls ROS软件包的内容。</p><p>表2.3 rosls命令</p><table><thead><tr><th>rosls命令</th><th>作用</th></tr></thead><tbody><tr><td>rosls [pacakge]</td><td>列出ROS package下的文件</td></tr></tbody></table><p><strong>rosdep:</strong></p><p>rosdep 是用于管理ROS package依赖项的命令行工具，用法如下：</p><p>表2.4 rosdep命令</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271407951.gif" alt="img"></p><p>一个较常使用的命令是 rosdep install –from-paths src –ignore-src –rosdistro&#x3D;kinetic -y ,用于安装工作空间中 src 路径下所有package的依赖项（由pacakge.xml文件指定）。</p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>最小的进程单元就是节点(可执行文件在运行之后就成了一个进程(process)，这个进程在ROS中就叫做节点)</p><p>从程序角度来说，node就是一个可执行文件（通常为C++编译生成的可执行文件、Python脚本）被执行，加载到了内存之中；</p><p>当执行一个ROS程序，就被加载到了内存中，就成为了一个进程，在ROS里叫做节点</p><p>分布式 </p><h2 id="节点管理器master"><a href="#节点管理器master" class="headerlink" title="节点管理器master"></a>节点管理器master</h2><p>ROS为机器人开发者们提供了不同语言的编程接口，比如C++接口叫做roscpp，Python接口叫做rospy，Java接口叫做rosjava。</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271418794.png" alt="image-20240627141840726"></p><h3 id="cpp编写"><a href="#cpp编写" class="headerlink" title="cpp编写"></a>cpp编写</h3><pre><code class="C++">#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &quot;sstream&quot;int main(int argc, char **argv)&#123;// 初始化 ROS 节点，节点名为 &quot;talker&quot;  ros::init(argc, argv, &quot;talker&quot;);// 创建一个节点句柄  ros::NodeHandle n;// 创建一个 Publisher，发布到话题 &quot;chatter&quot;，消息类型为 std_msgs::String，队列大小为 1000  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000);// 设置循环频率为 10Hz  ros::Rate loop_rate(10);  int count = 0;// 当 ROS 节点正常运行时，进入循环  while (ros::ok())  &#123;// 创建一个 std_msgs::String 类型的消息    std_msgs::String msg;    std::stringstream ss;// 将 &quot;hello world&quot; 和当前计数值 count 写入字符串流    ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count;    msg.data = ss.str();// 打印消息内容到终端    ROS_INFO(&quot;%s&quot;, msg.data.c_str());// 发布消息到 &quot;chatter&quot; 话题    chatter_pub.publish(msg);// 调用一次回调函数，处理所有已经到来的消息    ros::spinOnce();// 按照设定的频率休眠    loop_rate.sleep();// 计数值加 1    ++count;  &#125;  return 0;&#125;</code></pre><p>每秒发布 10 条内容为 “hello world x” 的消息，其中 <code>x</code> 是从 0 开始递增的计数值。</p><h3 id="CMakeLists-txt文件修改"><a href="#CMakeLists-txt文件修改" class="headerlink" title="CMakeLists.txt文件修改"></a>CMakeLists.txt文件修改</h3><pre><code>add_executable($&#123;PROJECT_NAME&#125;_node  src/test_pkg_node.cpp)&#123;PROJECT_NAME&#125;_node为生成可执行程序的名字，该名字可以任意指定。src/node.cpp:为编译要使用的源码的文件名。target_link_libraries($&#123;PROJECT_NAME&#125;_node $&#123;catkin_LIBRARIES&#125;）&#123;PROJECT_NAME&#125;_node是在add_executable中生成的可执行文件</code></pre><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271423296.png" alt="image-20240627142349193"></p><p>编译</p><pre><code>roscore//打开Masterrosrun test_pkg test_pkg_node</code></pre><h3 id="rosnode命令"><a href="#rosnode命令" class="headerlink" title="rosnode命令"></a>rosnode命令</h3><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271425596.png" alt="image-20240627142527534"></p><h3 id="头文件引用"><a href="#头文件引用" class="headerlink" title="头文件引用"></a>头文件引用</h3><p>打开终端输入以下命令进入要创建头文件的目录：</p><p>cd ~&#x2F;ros_workspace&#x2F;src&#x2F;test_pkg&#x2F;include&#x2F;test_pkg</p><p>输入以下命令创建头文件：</p><p>gedit test_pkg.h </p><p>输入以下代码：</p><pre><code>#ifndef _TEST_PKG_#define _TEST_PKG_#define TEST_PKG_VER &quot;1.0.0&quot;#define INIT_COUNT 100int addTwoNum(int a,int b);#endif</code></pre><p><strong>完成后保存关闭头文件，修改test.cpp，如下代码</strong>：</p><pre><code class="c++">#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &quot;test_pkg/test_pkg.h&quot; //自定义头文件#include &lt;sstream&gt;int addTwoNum(int a,int b)&#123;return a+b;&#125;//头文件函数实现部分int main(int argc, char *argv[])&#123;ros::init(argc, argv, &quot;talker&quot;);//这个名字是给系统看的ros::NodeHandle n;ros::Publisher chatter_pub = n.advertise &lt;std_msgs::String &gt;(&quot;chatter&quot;, 1000);ros::Rate loop_rate(10);int count = INIT_COUNT;//调用了头文件中的宏定义ROS_INFO(&quot;test_pkg version:%s&quot;,TEST_PKG_VER);while (ros::ok())&#123;std_msgs::String msg;std::stringstream ss;ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count;msg.data = ss.str();ROS_INFO(&quot;%s&quot;, msg.data.c_str());chatter_pub.publish(msg);ros::spinOnce();loop_rate.sleep();++count;&#125;return 0;&#125;</code></pre><p>需要修改修改test_pkg 中的 CMakeLists.txt<br><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271428838.png" alt="image-20240627142818770"></p><p>此处的include是一个相对路径，指的是当前功能包test_pkg下的include</p><h3 id="引用同一工作空间内其他软件包的头文件"><a href="#引用同一工作空间内其他软件包的头文件" class="headerlink" title="引用同一工作空间内其他软件包的头文件"></a>引用同一工作空间内其他软件包的头文件</h3><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271430018.png" alt="image-20240627143034917"></p><p>my_pkg的目的是要引用test_pkg中的自定义头文件，因此这里创建my_pkg的时候要对test_pkg进行依赖。</p><p>my_pkg&#x2F;src路径下创建源码文件my_pkg.cpp</p><pre><code class="C++">#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;sstream&gt;#include &quot;test_pkg/test_pkg.h&quot; //自定义头文件int main(int argc, char *argv[])&#123;ros::init(argc, argv, &quot;my_pkg&quot;);ros::NodeHandle n;ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;my_chatter&quot;, 1000);ros::Rate loop_rate(10);int count = INIT_COUNT;//调用了头文件中的宏定义ROS_INFO(&quot;test_pkg version:%s,init count:%d&quot;,TEST_PKG_VER,INIT_COUNT);//将其他软件包头文件中声明的宏定义打印出来while (ros::ok())&#123;std_msgs::String msg;std::stringstream ss;ss &lt;&lt; &quot;my_pkg &quot; &lt;&lt; count;msg.data = ss.str();ROS_INFO(&quot;%s&quot;, msg.data.c_str());chatter_pub.publish(msg);ros::spinOnce();loop_rate.sleep();++count;&#125;return 0;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271432313.png" alt="image-20240627143210185"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271432582.png" alt="image-20240627143238451"></p><p>对工作空间进行编译：</p><p>cd ~&#x2F;ros_workspace&#x2F;</p><p>catkin_make</p><p>编译完成之后可以运行节点查看结果。</p><p>roscore</p><p>rosrun my_pkg my_pkg_node</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271433139.png" alt="image-20240627143307049"></p><h3 id="launch文件编写"><a href="#launch文件编写" class="headerlink" title="launch文件编写"></a>launch文件编写</h3><p>roslaunch工具来调用launch文件，执行这个脚本文件就一次性启动所有的节点程序。</p><p>launch文件同样也遵循着xml格式规范，是一种标签文本。</p><p><launch> <!--根标签--></p><p><node> <!--需要启动的node及其参数--></p><p><include> <!--包含其他launch--></p><p><machine> <!--指定运行的机器--></p><p><env-loader> <!--设置环境变量--></p><param> <!--定义参数到参数服务器--><p><rosparam> <!--启动yaml文件参数到参数服务器--></p><p><arg> <!--定义变量--></p><p><remap> <!--设定参数映射--></p><p><group> <!--设定命名空间--></p><p></launch> <!--根标签--><br>每个XML文件都必须要包含一个根元素，根元素由一对launch标签定义：<br><launch> … </launch>。</p><p><node>标签的上一级根标签为<launch>标签，用于启动一个ROS节点。启动一个节点的写法如下：</p><node pkg="package-name" type="executable-name" name="node-name" /><p><node>标签下有若干属性，至少要包含三个属性：pkg，type，name。Pkg属性指定了要运行的节点属于哪个功能包，type是指要运行节点的可执行文件的名称，name属性给节点指派了名称，它将覆盖任何通过调用 ros::int来赋 予节点的名称。</p><pre><code class="xml">&lt;launch&gt;&lt;node pkg=&quot;test_pkg&quot; type=&quot;test_pkg_node&quot; name=&quot;test_pkg_node&quot; output=&quot;screen&quot;/&gt;&lt;node pkg=&quot;my_pkg&quot; type=&quot;my_pkg_node&quot; name=&quot;my_pkg_node&quot; output=&quot;screen&quot;/&gt;&lt;/launch&gt;</code></pre><p>其中，output&#x3D;“screen”属性可以将单个节点的标准输出到终端而不是存储在日志文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271437026.png" alt="image-20240627143727913"><br><include> 标签</p><pre><code class="XML">&lt;launch&gt;&lt;node pkg=&quot;test_pkg&quot; type=&quot;test_pkg_node&quot; name=&quot;test_pkg_node&quot; respawn=&quot;true&quot; output=&quot;screen&quot;/&gt;&lt;node pkg=&quot;my_pkg&quot; type=&quot;my_pkg_node&quot; name=&quot;my_pkg_node&quot; required=&quot;true&quot; output=&quot;screen&quot;/&gt;&lt;include file=&quot;$(find third_pkg)/launch/third_pkg.launch&quot;/&gt;&lt;/launch&gt;</code></pre><pre><code class="C++">#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;sstream&gt;int main(int argc, char **argv)&#123;// 初始化 ROS 节点，节点名为 &quot;third_pkg&quot;  ros::init(argc, argv, &quot;third_pkg&quot;);  // 创建一个节点句柄  ros::NodeHandle n;  // 创建一个 Publisher，发布到话题 &quot;third_pkg&quot;，消息类型为 std_msgs::String，队列大小为 1000  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;third_pkg&quot;, 1000);  // 设置循环频率为 10Hz  ros::Rate loop_rate(10);  int count = 0;  // 当 ROS 节点正常运行时，进入循环  while (ros::ok())  &#123;// 创建一个 std_msgs::String 类型的消息    std_msgs::String msg;    std::stringstream ss;    // 将 &quot;third pkg:&quot; 和当前计数值 count 写入字符串流    ss &lt;&lt; &quot;third pkg: &quot; &lt;&lt; count;    msg.data = ss.str();    // 打印消息内容到终端    ROS_INFO(&quot;%s&quot;, msg.data.c_str());    // 发布消息到 &quot;third_pkg&quot; 话题    chatter_pub.publish(msg);    // 调用一次回调函数，处理所有已经到来的消息    ros::spinOnce();    // 按照设定的频率休眠    loop_rate.sleep();    // 计数值加 1    ++count;  &#125;  return 0;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271442153.png" alt="image-20240627144220030"></p><h2 id="话题通讯-话题"><a href="#话题通讯-话题" class="headerlink" title="话题通讯 -话题"></a>话题通讯 -话题</h2><h3 id="topic通讯原理"><a href="#topic通讯原理" class="headerlink" title="topic通讯原理"></a>topic通讯原理</h3><p>topic是一种点对点的单向通信方式，这里的“点”指的是node，也就是说node之间可以通过topic方式来传递信息</p><p>topic要经历下面几步的初始化过程：</p><p>首先publisher节点和subscriber节点都要到节点管理器进行注册；</p><p>然后publisher会发布topic，subscriber在master的指挥下会订阅该topic；</p><p>从而建立起sub-pub之间的通信。</p><p>注意整个过程是单向的。其结构示意图如下。<br><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271459643.png" alt="image-20240627145943528"></p><p>Subscriber接收消息会进行处理，一般这个过程叫做回调(Callback)。所谓回调就是提前定义好了一个处理函数（写在代码中），当有消息来就会触发这个处理函数，函数会对消息进行处理。</p><p>topic通信属于一种异步的通信方式  各司其责，不存在协同工作，我们称这样的通信方式是异步的</p><p>ROS是一种分布式的架构，一个topic可以被多个节点同时发布，也可以同时被多个节点接收</p><p>分布式系统通信的好处：扩展性好、软件复用率高</p><ol><li>topic通信方式是异步的，发送时调用publish()方法，发送完成立即返回，不用等待反馈。</li><li>subscriber通过回调函数的方式来处理消息。</li><li>topic可以同时有多个subscribers，也可以同时有多个publishers。</li></ol><h3 id="通讯示例"><a href="#通讯示例" class="headerlink" title="通讯示例"></a>通讯示例</h3><p>输入以下命令在ros_workspace中创建第四个功能包subscribe_pkg。</p><pre><code>cd ~/ros_workspace/src/catkin_create_pkg subscribe_pkg rospy roscpp std_msgs</code></pre><pre><code class="C++">#include &quot;ros/ros.h&quot;#include &quot;std_msgs/Int32.h&quot;void chatterCallback(const std_msgs::Int32::ConstPtr&amp; msg)  &#123;ROS_INFO(&quot;I heard name:[%d]&quot;,msg-&gt;data);&#125;int main(int argc,char **argv)&#123;  ros::init(argc,argv,&quot;subscribe_node&quot;);  ros::NodeHandle n;  ros::Subscriber sub = n.subscribe(&quot;third_pkg_topic&quot;,1000,chatterCallback);  ros::spin();  return 0;&#125;</code></pre><p>当有消息发布到该话题时，调用回调函数 <code>chatterCallback</code> 并打印消息的内容</p><pre><code class="C++">#include &quot;ros/ros.h&quot;#include &quot;std_msgs/Int32.h&quot;int main(int argc, char **argv)&#123;  // 初始化 ROS 节点，节点名为 &quot;third_pkg&quot;  ros::init(argc, argv, &quot;third_pkg&quot;);  // 创建一个节点句柄  ros::NodeHandle n;  // 创建一个 Publisher，发布到话题 &quot;third_pkg_topic&quot;，队列大小为 1000  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::Int32&gt;(&quot;third_pkg_topic&quot;, 1000);  // 设置循环频率为 2Hz  ros::Rate loop_rate(2);  // 初始化计数器  int count = 0;  // 当 ROS 仍在运行时，循环执行以下操作  while (ros::ok())  &#123;    // 创建一个消息对象    std_msgs::Int32 msg;    // 将计数器的值赋给消息的数据字段    msg.data = count;    // 打印消息的数据    ROS_INFO(&quot;%d&quot;, msg.data);    // 将消息发布到话题 &quot;third_pkg_topic&quot;    chatter_pub.publish(msg);    // 处理回调函数（如果有的话）    ros::spinOnce();    // 按照设定的频率休眠    loop_rate.sleep();    // 计数器递增，且在 0 到 4 之间循环    count = (++count) % 5;  &#125;  return 0;&#125;</code></pre><p>(0 到 4）到 “third_pkg_topic” 话题，并且每秒发布 2 次。<br><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271523477.png" alt="image-20240627152313341"></p><h3 id="理解自定义消息类型"><a href="#理解自定义消息类型" class="headerlink" title="理解自定义消息类型"></a>理解自定义消息类型</h3><p>话题是ROS提供的一种重要通讯方式，<strong>话题上传输的信息内容即为消息</strong></p><p><strong>话题的类型由消息的数据类型决定</strong>，ROS提供了组成消息的基本数据类型。</p><p>int8, int16, int32, int64 (plus uint*)</p><p>float32, float64</p><p>string</p><p>time, duration</p><p>other msg files</p><p>variable-length array[] and fixed-length array[C]</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271530809.png" alt="image-20240627153012684"></p><p><strong>在third_pkg功能包下创建msg文件夹并在msg文件夹下新建myTestMsg.msg文件。</strong></p><p>打开myTestMsg.msg文件输入如图4.20内容。</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271531058.gif" alt="img"></p><p>图4.20 myTestMsg.msg文件内容</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271531274.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271531282.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271531288.gif" alt="img"></p><p>图4.21 CMakeLists.txt文件修改内容</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271532672.gif" alt="img"></p><p>图4.22 package.xml文件修改内容</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271532585.png" alt="image-20240627153248478"></p><p>修改third_pkg.cpp</p><pre><code class="C++">#include &quot;ros/ros.h&quot;#include &quot;third_pkg/myTestMsg.h&quot;//添加自定义消息的头文件int main(int argc,char **argv)&#123;ros::init(argc,argv,&quot;third_pkg&quot;);ros::NodeHandle n;// 更新话题的消息格式为自定义的消息格式ros::Publisher chatter_pub = n.advertise&lt;third_pkg::myTestMsg&gt;(&quot;third_pkg_topic&quot;,1000);ros::Rate loop_rate(2);while(ros::ok())&#123;third_pkg::myTestMsg msg;//声明一个自定义消息的对象msg.name = &quot;corvin&quot;;//填充消息内容msg.age = 20;msg.handsome = true;msg.salary = 123.45;chatter_pub.publish(msg);//将消息发布到话题中ros::spinOnce();loop_rate.sleep();&#125;return 0;&#125;</code></pre><p>修改订阅端代码subscribe.cpp如下，黑色字体为修改部分要格外注意：</p><pre><code class="C++">#include &quot;ros/ros.h&quot;#include &quot;third_pkg/myTestMsg.h&quot;// 回调函数，当接收到消息时调用void chatterCallback(const third_pkg::myTestMsg::ConstPtr&amp; msg)&#123;  // 打印接收到的消息内容  ROS_INFO(&quot;I heard - name: %s, age: %d, isHandsome: %d, salary: %f&quot;,            msg-&gt;name.c_str(), msg-&gt;age, msg-&gt;handsome, msg-&gt;salary);&#125;int main(int argc, char **argv)&#123;  // 初始化 ROS 节点，节点名为 &quot;subscribe_node&quot;  ros::init(argc, argv, &quot;subscribe_node&quot;);  // 创建一个节点句柄  ros::NodeHandle n;  // 创建一个 Subscriber，订阅 &quot;third_pkg_topic&quot; 话题，队列大小为 1000，回调函数为 chatterCallback  ros::Subscriber sub = n.subscribe(&quot;third_pkg_topic&quot;, 1000, chatterCallback);  // 进入循环等待回调  ros::spin();  return 0;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271536431.png" alt="image-20240627153615293"></p><h2 id="ROS通讯机制-服务"><a href="#ROS通讯机制-服务" class="headerlink" title="ROS通讯机制-服务"></a>ROS通讯机制-服务</h2><p>service方式在通信模型上与topic做了区别。Service通信是双向的，它不仅可以发送消息，同时还会有反馈。所以service包括两部分，一部分是请求方（Clinet），另一部分是应答方&#x2F;服务提供方（Server）。这时请求方（Client）就会发送一个request，要等待server处理，反馈回一个reply，这样通过类似“请求-应答”的机制完成整个服务通信。</p><p>Node B是server（应答方），提供了一个服务的接口，叫做 &#x2F;Service ，我们一般都会用string类型来指定service的名称，类似于topic。Node A向Node B发起了请求，经过处理后得到了反馈。</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271555278.png" alt="image-20240627155508120"><br>Service是同步通信方式，所谓同步就是说，此时Node A发布请求后会在原地等待reply，直到Node B处理完了请求并且完成了reply，Node A才会继续执行。Node A等待过程中，是处于阻塞状态的成通信。这样的通信模型没有频繁的消息传递，没有冲突与高系统资源的占用，只有接受请求才执行服务，简单而且高效。</p><p>表5.1 topic与service的对比</p><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271559910.gif" alt="img"></p><p>注意：远程过程调用(Remote Procedure Call，RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在third_pkg功能包下创建srv工作目录并在该目录下创建myTestSrv.srv文件</p><p>打开myTestSrv.srv文件输入以下内容：</p><pre><code>int32 index---int32 result</code></pre><p>两个部分用“—”分开修改third_pkg功能包的CMakeLists.txt</p><p>这里和自定义消息的修改方法类似：</p><ol><li>添加message_generation依赖</li></ol><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271604457.gif" alt="img"></p><ol start="2"><li>添加.srv服务文件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271604459.gif" alt="img"></p><ol start="3"><li>添加消息生成依赖</li></ol><p><img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271604169.gif" alt="img"></p><p>修改third_pkg.cpp</p><pre><code>int main(int argc, char **argv)&#123;// 初始化 ROS 节点，节点名为 &quot;third_pkg&quot;    ros::init(argc, argv, &quot;third_pkg&quot;);// 创建一个节点句柄    ros::NodeHandle n;// 创建一个 Publisher，发布自定义消息到 &quot;third_pkg_topic&quot; 话题，队列大小为1000    ros::Publisher chatter_pub = n.advertise&lt;third_pkg::myTestMsg&gt;(&quot;third_pkg_topic&quot;, 1000);// 定义并初始化服务端，服务名为 &quot;batteryStatus&quot;，服务回调函数为 checkBattery    ros::ServiceServer service = n.advertiseService(&quot;batteryStatus&quot;, checkBattery);// 设置发送话题的频率为 2Hz，即每0.5秒发送一条消息    ros::Rate loop_rate(2);// 循环运行，直到 ROS 关闭    while (ros::ok())    &#123;// 电池电量减少        battery--;// 如果电池电量小于10，则重置为100        if (battery &lt; 10) battery = 100;// 声明一个自定义消息对象        third_pkg::myTestMsg msg;// 填充消息数据        msg.name = &quot;corvin&quot;;        msg.age = 20;        msg.handsome = true;        msg.salary = 123.45;// 将消息发布到话题中        chatter_pub.publish(msg);// 处理回调函数        ros::spinOnce();// 休眠以维持循环频率        loop_rate.sleep();    &#125;    return 0;&#125;</code></pre><p>修改订阅者subscribe.cpp</p><pre><code class="C++">#include &quot;ros/ros.h&quot;#include &quot;third_pkg/myTestMsg.h&quot;  // 自定义消息的头文件#include &quot;third_pkg/myTestSrv.h&quot;  // 自定义服务的头文件// 订阅者的回调函数，用于处理接收到的消息void chatterCallback(const third_pkg::myTestMsg::ConstPtr&amp; msg)&#123;    ROS_INFO(&quot;I heard-name:%s,age:%d,ishandsome:%d,salary:%f&quot;,              msg-&gt;name.c_str(), msg-&gt;age, msg-&gt;handsome, msg-&gt;salary);&#125;int main(int argc, char **argv)&#123;// ROS 初始化，节点名为 &quot;subscribe_node&quot;    ros::init(argc, argv, &quot;subscribe_node&quot;);// 创建节点句柄    ros::NodeHandle n;// 设置循环频率为 1Hz    ros::Rate loop_rate(1);// 创建一个订阅者，订阅 &quot;third_pkg_topic&quot; 话题，队列大小为 1000，回调函数为 chatterCallback    ros::Subscriber sub = n.subscribe(&quot;third_pkg_topic&quot;, 1000, chatterCallback);    // 创建一个服务客户端，连接到 &quot;batteryStatus&quot; 服务    ros::ServiceClient client = n.serviceClient&lt;third_pkg::myTestSrv&gt;(&quot;batteryStatus&quot;);// 创建一个服务请求对象    third_pkg::myTestSrv mySrv;    mySrv.request.index = 1;  // 设置服务请求的参数    while (ros::ok())    &#123;// 调用服务并处理响应        if (client.call(mySrv))        &#123;            ROS_WARN(&quot;Client Get Battery: %d&quot;, mySrv.response.result);  // 打印获得的电        &#125;        else        &#123;            ROS_ERROR(&quot;Failed to call batteryStatus service&quot;);  // 打印错误信息            return 1;  // 返回错误码        &#125;// 处理回调函数        ros::spinOnce();// 休眠以保持循环频率        loop_rate.sleep();&#125;    return 0;&#125;</code></pre><p><strong>1****服务端的定义与初始化</strong></p><p>ros::ServiceServer service &#x3D; n.advertiseService(“batteryStatus”,checkBattery);</p><p>参数1：”batteryStatus”:发布服务的名称，类型：字符串，可以任意指定；</p><p>参数2：checkBattery:指定回调函数，类型：函数指针；</p><p><strong>2</strong> <strong>服务回调函数写法</strong></p><p>bool checkBattery(third_pkg::myTestSrv::Request &amp;req,third_pkg::myTestSrv::Response &amp;res)</p><p>参数1：third_pkg::myTestSrv::Request &amp;req，请求部分参数.</p><p>​         <img src="C:/Users/%E6%B6%82%E8%89%AF%E6%B9%98/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif" alt="img"></p><p>如上图所示：</p><p>1部分：服务的类型，写上要发布的服务类型。</p><p>2部分：固定写法，表征此部分为请求部分；</p><p>3部分：变量名称，可以随便写；</p><p>在此处，由于服务类型third_pkg::myTestSrv的定义如下：</p><p>​           <img src="C:/Users/%E6%B6%82%E8%89%AF%E6%B9%98/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="文本框: int32 index --- int32 result  "></p><p>因此，req的成员变量只有一个为index,即：req.index</p><p>参数2：third_pkg::myTestSrv::Response &amp;res，响应部分参数。</p><p>​         <img src="C:/Users/%E6%B6%82%E8%89%AF%E6%B9%98/AppData/Local/Temp/msohtmlclip1/01/clip_image003.gif" alt="img"></p><p>1部分：服务的类型，写上要发布的服务类型。</p><p>2部分：固定写法，表征此部分为响应部分；</p><p>3部分：变量名称，可以随便写；</p><p>在此处，由于服务类型third_pkg::myTestSrv的定义如下：</p><p>​           <img src="C:/Users/%E6%B6%82%E8%89%AF%E6%B9%98/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif" alt="文本框: int32 index --- int32 result  "></p><p>因此res的成员变量只有一个为：result，即：res.result。</p><p><strong>3</strong> <strong>客户端定义</strong></p><p>ros::ServiceClient client &#x3D; n.serviceClient&lt;third_pkg::myTestSrv&gt;(“batteryStatus”);</p><p>​         <img src="https://cdn.jsdelivr.net/gh/linkailang/bolg_img/img/202406271614626.gif" alt="img"></p><p>其中：</p><p>ros::ServiceClient为客户端定义类；</p><p>1部分：客户端初始化函数；</p><p>2部分：服务类型，这里为：third_pkg::myTestSrv；</p><p>3部分：要调用的服务名字，类型为字符串；</p><p><strong>4</strong> <strong>服务调用：</strong></p><p>third_pkg::myTestSrv mySrv;&#x2F;&#x2F;定义变量</p><p>mySrv.request.index &#x3D; 1;&#x2F;&#x2F;填充数据</p><p>client.call(mySrv)；&#x2F;&#x2F;调用服务</p><h1 id="移动机器人"><a href="#移动机器人" class="headerlink" title="移动机器人"></a>移动机器人</h1><p> 四大组成部分：执行机构 驱动系统 传感系统 控制系统</p><p>控制 - 驱动 -执行 -对象 -传感器 - 控制 </p><p>   |            |</p><p>   传感器</p><h1 id="ros组成"><a href="#ros组成" class="headerlink" title="ros组成"></a>ros组成</h1><p>ros &#x3D; 通信机制 + 开发工具 + 应用功能 + 生态系统</p><p>分布式通信框架 功能独立又相互联系</p><p>节点 功能的执行单元 </p><p>节点 节点管理器</p><p>话题和消息</p><p>服务</p><p>参数</p><p>topic通信属于一种异步的通信方式  各司其责，不存在协同工作，我们称这样的通信方式是异步的</p><p>ROS是一种分布式的架构，一个topic可以被多个节点同时发布，也可以同时被多个节点接收</p><p>分布式系统通信的好处：扩展性好、软件复用率高</p><ol><li>topic通信方式是异步的，发送时调用publish()方法，发送完成立即返回，不用等待反馈。</li><li>subscriber通过回调函数的方式来处理消息。</li><li>topic可以同时有多个subscribers，也可以同时有多个publishers。</li></ol><h1 id="ros常用工具"><a href="#ros常用工具" class="headerlink" title="ros常用工具"></a>ros常用工具</h1><ol><li>rostopic  话题相关</li><li>rosservice   服务</li><li>rosnode    节点</li><li>rosparam   参数</li><li>rosmsg  话题消息</li><li>rossrv   服务消息</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ros操作系统实验报告</title>
      <link href="/2024/06/15/ros%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/06/15/ros%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="ros操作系统"><a href="#ros操作系统" class="headerlink" title="ros操作系统"></a>ros操作系统</h1><h2 id="实验一-开发环境搭建"><a href="#实验一-开发环境搭建" class="headerlink" title="实验一  开发环境搭建"></a>实验一  开发环境搭建</h2><p>测试 ROS </p><p>ROS 内置了一些小程序，可以通过运行这些小程序以检测 ROS 环境是否可以正常运行 </p><p>首先启动三个命令行(ctrl + alt + T) </p><p>命令行 1 键入:<strong>roscore</strong> </p><p>命令行 2 键入:<strong>rosrun turtlesim turtlesim_node</strong>(此时会弹出图形化界面) </p><p>命令行 3 键入:<strong>rosrun turtlesim turtle_teleop_key</strong>(在 3 中可以通过上下左右控制 2 中乌龟的运动) </p><p><img src="C:/Users/%E6%B6%82%E8%89%AF%E6%B9%98/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><h2 id="实验二-Ubuntu的使用"><a href="#实验二-Ubuntu的使用" class="headerlink" title="实验二  Ubuntu的使用"></a>实验二  Ubuntu的使用</h2><h2 id="实验三-ROS-“hello-world”-基于-Python-和-C"><a href="#实验三-ROS-“hello-world”-基于-Python-和-C" class="headerlink" title="实验三. ROS “hello world”(基于 Python 和 C++)"></a>实验三. ROS “hello world”(基于 Python 和 C++)</h2><h2 id="实验四-ROS命令练习及Launch文件的使用"><a href="#实验四-ROS命令练习及Launch文件的使用" class="headerlink" title="实验四. ROS命令练习及Launch文件的使用"></a>实验四. ROS命令练习及Launch文件的使用</h2><h2 id="实验五Topic-的发布与订阅"><a href="#实验五Topic-的发布与订阅" class="headerlink" title="实验五Topic 的发布与订阅"></a>实验五Topic 的发布与订阅</h2><h2 id="实验六-自定义-msg-的发布与订阅"><a href="#实验六-自定义-msg-的发布与订阅" class="headerlink" title="实验六. 自定义 msg 的发布与订阅"></a>实验六. 自定义 msg 的发布与订阅</h2><h2 id="实验七-URDF-的练习试验"><a href="#实验七-URDF-的练习试验" class="headerlink" title="实验七. URDF 的练习试验"></a>实验七. URDF 的练习试验</h2><h2 id="实验八-完整机器人建模"><a href="#实验八-完整机器人建模" class="headerlink" title="实验八. 完整机器人建模"></a>实验八. 完整机器人建模</h2><h2 id="实验九-Gazebo仿真实例"><a href="#实验九-Gazebo仿真实例" class="headerlink" title="实验九. Gazebo仿真实例"></a>实验九. Gazebo仿真实例</h2><h2 id="实验十-Gazebo-仿真实例二"><a href="#实验十-Gazebo-仿真实例二" class="headerlink" title="实验十. Gazebo 仿真实例二"></a>实验十. Gazebo 仿真实例二</h2><h2 id="实验十一-SLAM-建图"><a href="#实验十一-SLAM-建图" class="headerlink" title="实验十一. SLAM 建图"></a>实验十一. SLAM 建图</h2><h2 id="实验十二-机器人导航"><a href="#实验十二-机器人导航" class="headerlink" title="实验十二. 机器人导航"></a>实验十二. 机器人导航</h2><h2 id="实验十三-ROS-视觉应用"><a href="#实验十三-ROS-视觉应用" class="headerlink" title="实验十三. ROS 视觉应用"></a>实验十三. ROS 视觉应用</h2><h2 id="实验十四-实际机器人的连接与控制"><a href="#实验十四-实际机器人的连接与控制" class="headerlink" title="实验十四. 实际机器人的连接与控制"></a>实验十四. 实际机器人的连接与控制</h2>]]></content>
      
      
      
        <tags>
            
            <tag> -- 大三下 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ros</title>
      <link href="/2024/03/19/Ros/"/>
      <url>/2024/03/19/Ros/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS的概念"><a href="#ROS的概念" class="headerlink" title="ROS的概念"></a>ROS的概念</h1><ol><li><strong>一种软件框架</strong>，当我们按照它的规范编写、运行各个程序，就可以通过它的函数和工具，使我们的程序之间能够更方便地进行通信（话题、服务、动作、参数服务器），让我们调试更加方便。</li></ol><p>特点：</p><ol><li>​    分布式计算</li></ol><ul><li>①一些机器人搭载多台计算机，每台计算机用于控制机器人的部分驱动器或传感器；</li><li>②即使只有一台计算机，通常仍将程序划分为独立运行且相互协作的小的模块来完成复杂的控制任务。</li><li>③当多个机器人需要协同完成一个任务时，往往需要互相通信来支撑任务的完成；</li><li>④用户通常通过其他搭建ros的主机与机器人进行ros层的通信。</li></ul><p>2.快速测试</p><p>①可以使用模拟器替代底层硬件模块，独立测试顶层部分，提高测试效率，并且可以仿真测试。【各类仿真工具】</p><p>②可以在调试过程中记录传感器数据及其他类型的消息数据，并在试验后按时间戳回放。【rosbag工具】</p><p>3.良好的开发生态</p><p>众多开发者维护的算法和工具。</p><h1 id="ROS系统架构"><a href="#ROS系统架构" class="headerlink" title="ROS系统架构"></a>ROS系统架构</h1><h2 id="系统基本架构"><a href="#系统基本架构" class="headerlink" title="系统基本架构"></a>系统基本架构</h2><p><img src="/2024/03/19/Ros/image-20240319194831164.png" alt="image-20240319194831164"></p><h4 id="总的来说，整个ROS的项目在部署运行过程中，分为几个部分："><a href="#总的来说，整个ROS的项目在部署运行过程中，分为几个部分：" class="headerlink" title="总的来说，整个ROS的项目在部署运行过程中，分为几个部分："></a>总的来说，整个ROS的项目在部署运行过程中，分为几个部分：</h4><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><h4 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h4><h4 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h4><h2 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h2><h4 id="包含了软件环境和硬件环境。通常一个ROS的机器人，需要一个开发主板用于运算和控制操作。"><a href="#包含了软件环境和硬件环境。通常一个ROS的机器人，需要一个开发主板用于运算和控制操作。" class="headerlink" title="包含了软件环境和硬件环境。通常一个ROS的机器人，需要一个开发主板用于运算和控制操作。"></a>包含了软件环境和硬件环境。通常一个ROS的机器人，需要一个开发主板用于运算和控制操作。</h4><h4 id="例如，我们用树莓派作为开发板，用来作为这个机器人的运算和控制操作，那么这个就是软件所运行的"><a href="#例如，我们用树莓派作为开发板，用来作为这个机器人的运算和控制操作，那么这个就是软件所运行的" class="headerlink" title="例如，我们用树莓派作为开发板，用来作为这个机器人的运算和控制操作，那么这个就是软件所运行的"></a>例如，我们用树莓派作为开发板，用来作为这个机器人的运算和控制操作，那么这个就是软件所运行的</h4><h4 id="硬件环境。开发板上通常需要有操作系统，所装的操作系统属于系统环境。当然开发板上可能会外接一"><a href="#硬件环境。开发板上通常需要有操作系统，所装的操作系统属于系统环境。当然开发板上可能会外接一" class="headerlink" title="硬件环境。开发板上通常需要有操作系统，所装的操作系统属于系统环境。当然开发板上可能会外接一"></a>硬件环境。开发板上通常需要有操作系统，所装的操作系统属于系统环境。当然开发板上可能会外接一</h4><h4 id="些其他硬件，如摄像头。那么这些硬件也属于硬件环境。"><a href="#些其他硬件，如摄像头。那么这些硬件也属于硬件环境。" class="headerlink" title="些其他硬件，如摄像头。那么这些硬件也属于硬件环境。"></a>些其他硬件，如摄像头。那么这些硬件也属于硬件环境。</h4><h2 id="执行器-1"><a href="#执行器-1" class="headerlink" title="执行器"></a>执行器</h2><h4 id="执行器主要作用是给操作系统发送一些指令，通过指令取控制硬件操作。例如发送指令给开发板，让开"><a href="#执行器主要作用是给操作系统发送一些指令，通过指令取控制硬件操作。例如发送指令给开发板，让开" class="headerlink" title="执行器主要作用是给操作系统发送一些指令，通过指令取控制硬件操作。例如发送指令给开发板，让开"></a>执行器主要作用是给操作系统发送一些指令，通过指令取控制硬件操作。例如发送指令给开发板，让开</h4><h4 id="发板外接的陀机转动，驱动物体运动。执行器更像是硬件驱动的输入。"><a href="#发板外接的陀机转动，驱动物体运动。执行器更像是硬件驱动的输入。" class="headerlink" title="发板外接的陀机转动，驱动物体运动。执行器更像是硬件驱动的输入。"></a>发板外接的陀机转动，驱动物体运动。执行器更像是硬件驱动的输入。</h4><h3 id="传感器-1"><a href="#传感器-1" class="headerlink" title="传感器"></a>传感器</h3><h4 id="在硬件环境中，可能会安装一些环境探测的硬件，例如温度感应器。这些硬件感应器会将感觉的数据发"><a href="#在硬件环境中，可能会安装一些环境探测的硬件，例如温度感应器。这些硬件感应器会将感觉的数据发" class="headerlink" title="在硬件环境中，可能会安装一些环境探测的硬件，例如温度感应器。这些硬件感应器会将感觉的数据发"></a>在硬件环境中，可能会安装一些环境探测的硬件，例如温度感应器。这些硬件感应器会将感觉的数据发</h4><h4 id="布出来，传感器其实扮演的就是这些硬件发布数据的传播者，更像是硬件驱动的输出。"><a href="#布出来，传感器其实扮演的就是这些硬件发布数据的传播者，更像是硬件驱动的输出。" class="headerlink" title="布出来，传感器其实扮演的就是这些硬件发布数据的传播者，更像是硬件驱动的输出。"></a>布出来，传感器其实扮演的就是这些硬件发布数据的传播者，更像是硬件驱动的输出。</h4><h3 id="软件结构-1"><a href="#软件结构-1" class="headerlink" title="软件结构"></a>软件结构</h3><h4 id="这里所说的软件结构是指，ROS机器人运行时部署的软件及软件间的关系。"><a href="#这里所说的软件结构是指，ROS机器人运行时部署的软件及软件间的关系。" class="headerlink" title="这里所说的软件结构是指，ROS机器人运行时部署的软件及软件间的关系。"></a>这里所说的软件结构是指，ROS机器人运行时部署的软件及软件间的关系。</h4><h4 id="机器人运行起来后，内部会有很多单元程序运行，每个单元程序做很小的事情。有的小程序负责读取硬"><a href="#机器人运行起来后，内部会有很多单元程序运行，每个单元程序做很小的事情。有的小程序负责读取硬" class="headerlink" title="机器人运行起来后，内部会有很多单元程序运行，每个单元程序做很小的事情。有的小程序负责读取硬"></a>机器人运行起来后，内部会有很多单元程序运行，每个单元程序做很小的事情。有的小程序负责读取硬</h4><h4 id="件驱动传递的数据，有的负责处理读取的数据，有的负责判断数据，有的负责发出指令…"><a href="#件驱动传递的数据，有的负责处理读取的数据，有的负责判断数据，有的负责发出指令…" class="headerlink" title="件驱动传递的数据，有的负责处理读取的数据，有的负责判断数据，有的负责发出指令…."></a>件驱动传递的数据，有的负责处理读取的数据，有的负责判断数据，有的负责发出指令….</h4><p>总之，ros将复杂的程序分解成了很小的一部分，每部分干很少的活，每个部分还可以复用。</p><h2 id="ROS-软件结构组成"><a href="#ROS-软件结构组成" class="headerlink" title="ROS 软件结构组成"></a>ROS 软件结构组成</h2><p><img src="/image-20240319194906093.png" alt="image-20240319194906093"></p><h3 id="ROS-Master"><a href="#ROS-Master" class="headerlink" title="ROS Master"></a>ROS Master</h3><pre><code>管理Node节点间进行通讯的每个Node节点都需要到Ros Master中进行通讯</code></pre><p>通roscore命令可以启动ROS Master，启动节点前，必须启动ROS Master。</p><pre><code># 启动ROS Masterroscore</code></pre><h3 id="ROS节点"><a href="#ROS节点" class="headerlink" title="ROS节点"></a>ROS节点</h3><h4 id="具备单一功能的可执行程序"><a href="#具备单一功能的可执行程序" class="headerlink" title="具备单一功能的可执行程序"></a>具备单一功能的可执行程序</h4><h4 id="可以单独编译，可执行，可管理"><a href="#可以单独编译，可执行，可管理" class="headerlink" title="可以单独编译，可执行，可管理"></a>可以单独编译，可执行，可管理</h4><pre><code>存放在package中</code></pre><h2 id="ROS-哲学"><a href="#ROS-哲学" class="headerlink" title="ROS 哲学"></a>ROS 哲学</h2><h3 id="1-点对点"><a href="#1-点对点" class="headerlink" title="1. 点对点"></a>1. 点对点</h3><h4 id="点对点的设计。"><a href="#点对点的设计。" class="headerlink" title="点对点的设计。"></a>点对点的设计。</h4><pre><code>Node节点单元采用了分布式网络结构节点间通过RPC + TCP/UDP进行通讯</code></pre><h3 id="2-分布式"><a href="#2-分布式" class="headerlink" title="2. 分布式"></a>2. 分布式</h3><h4 id="分散协同式布局。可以将ROS同时部署到多台机器上，让多台机器进行通讯。"><a href="#分散协同式布局。可以将ROS同时部署到多台机器上，让多台机器进行通讯。" class="headerlink" title="分散协同式布局。可以将ROS同时部署到多台机器上，让多台机器进行通讯。"></a>分散协同式布局。可以将ROS同时部署到多台机器上，让多台机器进行通讯。</h4><h3 id="3-多语种"><a href="#3-多语种" class="headerlink" title="3. 多语种"></a>3. 多语种</h3><h4 id="多编程语言的支持。"><a href="#多编程语言的支持。" class="headerlink" title="多编程语言的支持。"></a>多编程语言的支持。</h4><pre><code>可以采用python，c++，lisp等语言进行开发。遵循协议进行编码，和编程语言无关</code></pre><h3 id="4-重量轻"><a href="#4-重量轻" class="headerlink" title="4.重量轻"></a>4.重量轻</h3><p>组件工具包丰富。ros提供了丰富的开发工具包。</p><h3 id="5-免费开源"><a href="#5-免费开源" class="headerlink" title="5. 免费开源"></a>5. 免费开源</h3><h4 id="免费并且开源。"><a href="#免费并且开源。" class="headerlink" title="免费并且开源。"></a>免费并且开源。</h4><h4 id="BSD许可。可修改，可复用，可商用。"><a href="#BSD许可。可修改，可复用，可商用。" class="headerlink" title="BSD许可。可修改，可复用，可商用。"></a>BSD许可。可修改，可复用，可商用。</h4><h4 id="开源使软件进步"><a href="#开源使软件进步" class="headerlink" title="开源使软件进步"></a>开源使软件进步</h4><h2 id="工作目录结构"><a href="#工作目录结构" class="headerlink" title="工作目录结构"></a>工作目录结构</h2><p><img src="/image-20240319194947232.png" alt="image-20240319194947232"></p><p>Workspace，Package，Node是工程结构中的几个关键词，也是核心概念。以上视图我们初步的认知<br>他们的包含关系。</p><p>标准的Workspace工作目录结构如下：</p><pre><code>📁workspace├── 📁build├── 📁devel│ ├── 📃setup.bash└── 📁src├── 📃CMakeLists.txt├── 📁pkg│ ├── 📃CMakeLists.txt│ ├── 📁include│ ├── 📃package.xml│ └── 📁src├── 📁pkg│ ├── 📃CMakeLists.txt│ ├── 📁include│ ├── 📃package.xml│ └── 📁src└── 📁pkg├── 📃CMakeLists.txt├── 📁include├── 📃package.xml└── 📁src</code></pre><h4 id="完整的机构示意图如下："><a href="#完整的机构示意图如下：" class="headerlink" title="完整的机构示意图如下："></a>完整的机构示意图如下：</h4><p><img src="/2024/03/19/Ros/image-20240319195046298.png" alt="image-20240319195046298"></p><h2 id="工作目录理解"><a href="#工作目录理解" class="headerlink" title="工作目录理解"></a>工作目录理解</h2><p><img src="/2024/03/19/Ros/image-20240319195101101.png" alt="image-20240319195101101"></p><p>Tip</p><p>生活中，企业通过部门管理员工。</p><p>人多瞎胡乱，鸡多不下蛋，一旦项目变大，组织结构和规范就变的非常重要。</p><p><img src="/2024/03/19/Ros/image-20240319195115679.png" alt="image-20240319195115679"></p><p>我们基于ros开发一个无人驾驶的小车，代码结构按照package划分，可以划分如下</p><pre><code>camera视觉包： 负责视频的采集，图像解析，障碍识别等hardware硬件包：负责控制小车，硬件的加速减速，方向移动motion控制包： 负责用来规划计算 运动轨迹和如何运动</code></pre><p>提示</p><h4 id="按照公司结构来去类比，无人小汽车相当于一个公司，下面的模块相当于一个部门，模块下的功能相当"><a href="#按照公司结构来去类比，无人小汽车相当于一个公司，下面的模块相当于一个部门，模块下的功能相当" class="headerlink" title="按照公司结构来去类比，无人小汽车相当于一个公司，下面的模块相当于一个部门，模块下的功能相当"></a>按照公司结构来去类比，无人小汽车相当于一个公司，下面的模块相当于一个部门，模块下的功能相当</h4><h4 id="于部门里干活的人。"><a href="#于部门里干活的人。" class="headerlink" title="于部门里干活的人。"></a>于部门里干活的人。</h4><p>按照ROS的项目结构来划分，无人小汽车工程就是一个workspace，视觉功能模块就是一个<br>package，模块下的视频采集功能就是一个Node。</p><p>ros的这种结构划分，和公司结构划分是一个道理。功能多，通过只能进行管理划分，规范开发，让开<br>发效率提升，解决一些耦合。</p><h2 id="工作目录说明"><a href="#工作目录说明" class="headerlink" title="工作目录说明"></a>工作目录说明</h2><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><h4 id="我们在开发一个ROS项目的时候，是以工作空间来代表一个项目的。"><a href="#我们在开发一个ROS项目的时候，是以工作空间来代表一个项目的。" class="headerlink" title="我们在开发一个ROS项目的时候，是以工作空间来代表一个项目的。"></a>我们在开发一个ROS项目的时候，是以工作空间来代表一个项目的。</h4><p><img src="/2024/03/19/Ros/image-20240319195131504.png" alt="image-20240319195131504"></p><pre><code>workspace： 工作空间build：ros编译打包的结果产出目录。 我们不需要对这个文件夹做任何编辑操作，属于自动生成。devel: 开发所需要的目录src：存放package的目录CMakeLists.txt: 整个工作空间编译的脚本。此文件我们通常不用去做修改操作。</code></pre><h3 id="工作单元package"><a href="#工作单元package" class="headerlink" title="工作单元package"></a>工作单元package</h3><p>一个项目中可以创建多个工作单元，这个工作单元，我们称之为package。</p><p>package的文件组成结构为以下：</p><p><img src="/2024/03/19/Ros/image-20240319195148286.png" alt="image-20240319195148286"></p><pre><code>pkg1： package的名称，开发过程中根据自己实际情况进行创建设定。CMakeLists.txt: 当前package的编译脚本。通常需要为c++代码添加编译时的依赖，执行等操作。package.xml: package相关信息。通常添加一些ros库的支持include文件夹: 存放c++ 头文件的config文件夹：存放参数配置文件，格式为yamllaunch文件夹：存放.launch文件的。src：c++源代码scripts：python源代码srv：存放定义的servicemsg: 存放自定义的消息协议action： 存放自定义的action</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> --Ros操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用API</title>
      <link href="/2024/03/11/java%E5%B8%B8%E7%94%A8API/"/>
      <url>/2024/03/11/java%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常用API"><a href="#1-常用API" class="headerlink" title="1 常用API"></a>1 常用API</h1><ul><li>API（:Application Programming Interface ）：应用程序编程接口</li></ul><h2 id="1-1-Math类-java-lang"><a href="#1-1-Math类-java-lang" class="headerlink" title="1.1 Math类(java.lang)"></a>1.1 Math类(java.lang)</h2><pre><code>Math类包含执行基本数字运算的方法，如基本指数，对数，平方根和三角函数。</code></pre><ul><li><p>Math中<strong>没有构造方法</strong>，<strong>类的成员都是静态的</strong>（static修饰），<strong>通过类名就可以直接调用</strong></p></li><li><p>静态常量</p><ul><li><code>static final double PI = 3.141……</code>(精确到19位)</li><li><code>static double exp(double a)</code> :返回Euler的数字 e ，其值 double值。<ul><li>用于计算 Euler’s 数（自然对数的底 e）的 a 次幂。参数 <code>a</code> 是幂的指数。</li></ul></li></ul></li><li><p><strong>常用方法</strong></p></li></ul><table><thead><tr><th align="left">方法名</th><th>说明</th></tr></thead><tbody><tr><td align="left">public static int abs(int a)</td><td>获取参数a的绝对值</td></tr><tr><td align="left">public static double ceil(double a)</td><td>向上取整</td></tr><tr><td align="left">public static double floor(double a)</td><td>向下取整</td></tr><tr><td align="left">public static long round(double a)</td><td>四舍五入取整</td></tr><tr><td align="left">public static int max(int a,int b)</td><td>返回两个数中较大值</td></tr><tr><td align="left">public static int min(int a,int b)</td><td>返回两个数中较小值</td></tr><tr><td align="left">public static double pow(double a,double b)</td><td>获取a的b次幂</td></tr><tr><td align="left">public static double random()</td><td>返回值为double类型随机数 [0.0~1.0）</td></tr><tr><td align="left">static double cos(double a)</td><td>返回角度的三角余弦值。</td></tr><tr><td align="left">static double acos(double a)</td><td>返回值的反余弦值; 返回的角度在0.0到pi的范围内。</td></tr><tr><td align="left">static double expm1(double x)</td><td>返回 e^x -1</td></tr><tr><td align="left">static double log(double a)</td><td>返回 double值的自然对数（基数 e ）</td></tr><tr><td align="left">static double log10(double a)</td><td>返回 double值的基数10对数。</td></tr><tr><td align="left">static double sqrt(double a)</td><td>返回 double值的正确舍入正平方根。</td></tr><tr><td align="left">static double toDegrees(double angrad)</td><td>将以弧度测量的角度转换为以度为单位测量的近似等效角度。</td></tr><tr><td align="left">static double toRadians(double angdeg)</td><td>将以度为单位测量的角度转换为以弧度为单位测量的近似等效角度。</td></tr></tbody></table><pre><code class="java">public class MathDemo &#123;    public static void main(String[] args) &#123;        //1、public static int abs(int a)获取参数a的绝对值        System.out.println(Math.abs(88)); //88        System.out.println(Math.abs(-88)); //88        //2、public static double ceil(double a)向上取整        System.out.println(Math.ceil(12.34)); //13.0        System.out.println(Math.ceil(12.56)); //13.0        //3、public static double floor(double a)向下取整        System.out.println(Math.floor(12.34)); //12.0        System.out.println(Math.floor(12.56)); //12.0        //4、public static long round(double a)四舍五入取整        System.out.println(Math.round(12.34)); //12        System.out.println(Math.round(12.56)); //13        //5、public static int max(int a,int b)返回两个数中较大值        System.out.println(Math.max(66,88)); //88        //6、public static int min(int a,int b)返回两个数中较小值        System.out.println(Math.min(66,88)); //66        //7、public static double pow(double a,double b)获取a的b次幂        System.out.println(Math.pow(2.0,3.0)); //8.0        //8、public static double random()返回值为double类型随机数 [0.0~1.0）        System.out.println(Math.random()); //0.36896250602163483        System.out.println(Math.random()); //0.3507783145075083    &#125;&#125;</code></pre><h2 id="1-2-System类"><a href="#1-2-System类" class="headerlink" title="1.2 System类"></a>1.2 System类</h2><ul><li><p>System被<strong>静态修饰</strong>，通过类名访问</p></li><li><p><strong>常用方法</strong></p><ul><li><p>static long currentTimeMillis()：返回以毫秒为单位的当前时间。&#x2F;&#x2F;获取毫秒值形式的当前时间。</p><pre><code>常用于测试程序效率</code></pre></li><li><p>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。</p></li><li><p>src Object:源数组（原来的数组）。</p><pre><code>src Posint:源数组索引起始位置。dest Object:目标数组。dest Posint:目标数组索引起始位置。length int:复制元素个数。</code></pre></li><li><p>static void setErr(PrintStream err)：重新分配“标准”错误输出流。</p></li><li><p>static void setIn(InputStream in)：重新分配“标准”输入流。</p></li><li><p>static void setOut(PrintStream out)：重新分配“标准”输出流。</p></li><li><p><em>public static void exit(int status)终止JVM虚拟机，非 0 是异常终止        System.exit(0);</em></p></li></ul><pre><code class="java">import java.text.SimpleDateFormat;public class SystemDemo &#123;    public static void main(String[] args) &#123;        /*        System.out.println(&quot;开始&quot;); //开始        //1、public static void exit(int status)终止JVM虚拟机，非 0 是异常终止        System.exit(0);        System.out.println(&quot;结束&quot;); //没有输出结束        */        //2、public static long currentTimeMillis()返回当前时间（以毫秒为单位）        System.out.println(System.currentTimeMillis()); //1625491582918        long time = System.currentTimeMillis();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;);        System.out.println(sdf.format(time)); //2023年12月05日 21:26:22 星期一 下午    &#125;&#125;</code></pre></li></ul><h2 id="1-3-Object类-java-lang"><a href="#1-3-Object类-java-lang" class="headerlink" title="1.3 Object类(java.lang)"></a>1.3 Object类(java.lang)</h2><ul><li><p>Object 类是 Java 中的祖宗类，所有类都直接或者间接继承自该类</p><ul><li>Class Object是类Object结构的根。 每个班都有Object作为超类。 所有对象（包括数组）都实现了这个类的方法。</li></ul></li><li><p><strong>只有无参构造方法</strong>：<code>public Object()</code></p></li><li><p><strong>常用方法</strong>：</p><ul><li><p>String toString()：返回该对象的字符串表示。</p></li><li><p>boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。</p></li><li><p>int hasCode()：返回该对象的哈希码值。</p><pre><code>HashSet集合存放自定义类型元素时，需要重写对象中的hashCode和equals方法</code></pre></li><li><p>void wait()：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。</p></li><li><p>void wait(long timeout)：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。</p></li><li><p>void wait(long timeout, int nanos)：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。</p></li><li><p>void notify()：唤醒在此对象监视器上等待的单个线程。</p></li><li><p>void notifyAll()：唤醒在此对象监视器上等待的所有线程。<br>Class&lt;?&gt; getClass()：返回此 Object 的运行时类。</p></li><li><p>protected Object clone()：创建并返回此对象的一个副本。</p></li><li><p>protected void finalize()：当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p></li></ul></li></ul><h3 id="1、public-String-toString"><a href="#1、public-String-toString" class="headerlink" title="1、public String toString()"></a>1、public String toString()</h3><p>默认是返回当前对象在堆内存中的地址信息<br>直接输出对象名称，默认会调用 toString()方法，所以直接输出对象可以省略 toString()<br>所以 toString() 存在的意义是为了被子类重写，以便能够返回对象的数据内容输出<br>重写快捷键：按下Fn+Alt+Insert &#x2F; 右键 -&gt; generate -&gt; toString -&gt; OK<br>看方法的源码：选中方法，按Ctrl+B</p><pre><code class="java">package ceshi;public class Student extends Object&#123;    private String name;    private int age;public Student() &#123; &#125;public Student(String name, int age) &#123;    this.name = name;    this.age = age;&#125;public String getName() &#123;    return name;&#125;public void setName(String name) &#123;    this.name = name;&#125;public int getAge() &#123;    return age;&#125;public void setAge(int age) &#123;    this.age = age;&#125;//自动生成重写toString()方法；按下Fn+Alt+Insert / 右键 -&gt; generate -&gt; toString -&gt; OK@Overridepublic String toString() &#123;    return &quot;Student&#123;&quot; +            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +            &quot;, age=&quot; + age +            &#39;&#125;&#39;;&#125;&#125;</code></pre><pre><code class="java">package ceshi;public class ObjectDemo &#123;    public static void main(String[] args) &#123;        Student s = new Student();        s.setName(&quot;yy&quot;);        s.setAge(20);        System.out.println(s); //ceshi.Student@1b6d3586        System.out.println(s.toString()); //ceshi.Student@1b6d3586        //重写后输出        /*源码        Student&#123;name=&#39;yy&#39;, age=20&#125;        Student&#123;name=&#39;yy&#39;, age=20&#125;*/        //选中方法Ctrl+B查看方法源码        /*public void println(Object x) &#123; //1、x = s            String s = String.valueOf(x);            synchronized (this) &#123;                print(s);                newLine();            &#125;        &#125;*/            /*public static String valueOf(Object obj) &#123; //2、obj = x            return (obj == null) ? &quot;null&quot; : obj.toString();        &#125;*/            /*public String toString() &#123; //3、            return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); //所以重写前才会输出ceshi.Student@1b6d3586        &#125;*/    &#125;&#125;</code></pre><h3 id="2、public-boolean-equals-Object-o"><a href="#2、public-boolean-equals-Object-o" class="headerlink" title="2、public boolean equals(Object o)"></a>2、public boolean equals(Object o)</h3><p>默认是比较两个对象的地址是否相同，相同返回true<br>直接比较两个对象的地址是否完全相同，可以用”&#x3D;&#x3D;”替代equals<br>所以 equals 存在的意义是为了被子类重写<br>重写快捷键：按下Fn+Alt+Insert -&gt; generate -&gt; equals() and hashCode() -&gt; Template：选择 IntelliJ default -&gt; 三个next &gt; finsh ；然后删除hashCode()方法</p><pre><code class="java">package ceshi;public class Student extends Object&#123;    private String name;    private int age;    public Student() &#123; &#125;        public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;        public int getAge() &#123;        return age;    &#125;        public void setAge(int age) &#123;        this.age = age;    &#125;        //自动生成重写equals()方法    @Override    public boolean equals(Object o) &#123;        if (this == o) return true; //1、比较地址是否相同，如果相同就是同一个对象，直接返回true        //2、先判断参数是否为null；判断连个对象是否来自同一个类；一个满足就返回false        if (o == null || getClass() != o.getClass()) return false;        //向下转型        Student student = (Student) o; //student = s2;        //3、比较年龄是否相同，年龄相同往下走        if (age != student.age) return false;        //比较名字是否相同，s1的name不是null才能取调方法        return name != null ? name.equals(student.name) : student.name == null;    &#125;&#125;</code></pre><pre><code class="java">package ceshi;public class ObjectDemo &#123;    public static void main(String[] args) &#123;        Student s1 = new Student();        s1.setName(&quot;yy&quot;);        s1.setAge(20);        Student s2 = new Student();        s2.setName(&quot;yy&quot;);        s2.setAge(20);            //比较两个对象内容是否相等        System.out.println(s1.equals(s2)); //重写前：false ； 重写后：true        /*public boolean equals(Object obj) &#123;            //this---s1            //obj---s2            return (this == obj); //重写前==比较的是地址值，不是内容需要重写equals()方法        &#125;*/        &#125;&#125;</code></pre><h2 id="1-4-Objects类-java-util"><a href="#1-4-Objects类-java-util" class="headerlink" title="1.4 Objects类 (java.util)"></a>1.4 Objects类 (java.util)</h2><ul><li><p>Objects类是 jdk 1.7 开始之后才有的</p></li><li><p>常用方法</p><ul><li><p>public static boolean equals(Object a, Object b)比较两个对象内容是否相等</p></li><li><p>public static boolean isNull(Object obj)判断变量是否为 null , 为 null 返回 true</p></li></ul></li></ul><pre><code class="java">public class ObjectsDemo &#123;    public static void main(String[] args) &#123;        Student s1 = new Student();        Student s2 = new Student();        System.out.println(s1.equals(s2));        System.out.println(Objects.equals(s1,s2));        // true        // true        //询问s1是否为null，为null返回true        System.out.println(Objects.isNull(s1));    &#125;&#125;</code></pre><h2 id="1-5-Arrays类-java-util"><a href="#1-5-Arrays类-java-util" class="headerlink" title="1.5 Arrays类 (java.util)"></a>1.5 Arrays类 (java.util)</h2><ul><li><p>Arrays类包含用于操作数组的各种方法</p></li><li><p>工具类的设计思想</p><ul><li>构造方法用 private 修饰（防止外界创建对象）</li><li>成员用 public static 修饰（使用类名来访问</li></ul></li><li><p><strong>常用方法</strong></p><p>- </p><ul><li><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public static String toString(int[] a)</td><td>返回指定数组的内容的字符串表示形式</td></tr><tr><td><code>sort(T[] a)</code></td><td>对数组进行自然排序</td></tr><tr><td><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></td><td>使用指定的比较器对数组进行排序</td></tr><tr><td><code>binarySearch(T[] a, T key)</code></td><td>在已排序的数组中使用二分搜索算法查找指定元素的索引</td></tr><tr><td><code>binarySearch(T[] a, int fromIndex, int toIndex, T key)</code></td><td>在指定范围内的已排序数组中使用二分搜索算法查找指定元素的索引</td></tr><tr><td><code>fill(T[] a, T val)</code></td><td>使用指定的值填充整个数组</td></tr><tr><td><code>fill(T[] a, int fromIndex, int toIndex, T val)</code></td><td>使用指定的值填充数组的指定范围</td></tr><tr><td><code>equals(T[] a, T[] a2)</code></td><td>比较两个数组是否相等</td></tr><tr><td><code>deepEquals(Object[] a1, Object[] a2)</code></td><td>深度比较两个数组是否相等</td></tr><tr><td><code>toString(T[] a)</code></td><td>返回包含数组元素的字符串表示形式</td></tr><tr><td><code>asList(T... a)</code></td><td>将指定数组转换为 List</td></tr><tr><td><code>copyOf(T[] original, int newLength)</code></td><td>复制指定数组的副本，截取或填充空值以使副本具有指定的长度</td></tr><tr><td><code>copyOfRange(T[] original, int from, int to)</code></td><td>复制指定数组的指定范围</td></tr></tbody></table></li></ul></li><li><p>冒泡排序</p></li></ul><pre><code class="java">package ceshi;public class ArrayDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;21,56,15,89,62&#125;;        System.out.println(&quot;排序前:&quot;+arrayToString(arr)); //排序前:[21, 56, 15, 89, 62]        //冒泡排序        for(int i=0;i&lt;arr.length-1;i++) &#123;            for(int x=0;x&lt; arr.length-1-i;x++) &#123;                if(arr[x] &gt; arr[x+1]) &#123;                    //当前一个大于后一个时，双方交换位置                    int temp = arr[x];                    arr[x] = arr[x+1];                    arr[x+1] = temp;                &#125;            &#125;        &#125;        System.out.println(&quot;排序后:&quot;+arrayToString(arr)); //排序后:[15, 21, 56, 62, 89]    &#125;    public static String arrayToString(int[] arr) &#123;        StringBuilder sb = new StringBuilder();        sb.append(&quot;[&quot;);        for(int i=0;i&lt;arr.length;i++) &#123;            if(i==arr.length-1) &#123;                sb.append(arr[i]);            &#125;else &#123;                sb.append(arr[i]).append(&quot;, &quot;);            &#125;        &#125;        sb.append(&quot;]&quot;);        String s = sb.toString();        return s;    &#125;&#125;//排序前:[21, 56, 15, 89, 62]//排序后:[15, 21, 56, 62, 89]</code></pre><p><img src="/2024/03/11/java%E5%B8%B8%E7%94%A8API/image-20240311004011670.png" alt="image-20240311004011670"></p><ul><li>Arrays方法范例</li></ul><pre><code class="java">package ceshi;import java.util.Arrays;public class ArrayDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;21,56,15,89,62&#125;;        //1、public static String toString(int[] a) 返回指定数组的内容的字符串表示形式        System.out.println(&quot;排序前：&quot;+ Arrays.toString(arr)); //排序前：[21, 56, 15, 89, 62]        //2、public static void sort(int[] a) 按照数字排序指定的数组        Arrays.sort(arr);        System.out.println(&quot;排序后：&quot;+Arrays.toString(arr)); //排序后：[15, 21, 56, 62, 89]    &#125;&#125;</code></pre><h2 id="1-6-基本类型包装类"><a href="#1-6-基本类型包装类" class="headerlink" title="1.6 基本类型包装类"></a>1.6 基本类型包装类</h2><ul><li>将基本数据类型封装成对象的好处在于在对象中定义更多的功能方法操作该数据</li><li>常用的操作之一：用于<strong>基本数据类型与字符串之间的转换</strong></li></ul><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer(重点)</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character(特殊)</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h3 id="包装类和基本数据类型的区别"><a href="#包装类和基本数据类型的区别" class="headerlink" title="包装类和基本数据类型的区别"></a>包装类和基本数据类型的区别</h3><p><strong>存储方式</strong>：</p><ul><li>基本数据类型存储的是实际的数据值，它们在栈上分配内存。</li><li>包装类存储的是对象的引用，它们在堆上分配内存。</li></ul><p><strong>对象特性</strong>：</p><ul><li>基本数据类型不是对象，因此它们没有方法或属性。</li><li>包装类是对象，它们具有方法和属性，可以进行对象操作。</li></ul><p><strong>装箱(基本类型的数据-&gt;包装类)</strong></p><h3 id="1-6-1-Integer类概述和使用"><a href="#1-6-1-Integer类概述和使用" class="headerlink" title="1.6.1 Integer类概述和使用"></a>1.6.1 Integer类概述和使用</h3><ul><li>Integer：包装一个对象中原始类型int的值</li><li><strong>常用方法</strong></li></ul><p>构造方法：</p><ul><li><p>Integer(int value)：构造一个新分配的 Integer 对象，它表示指定的 int 值。（过时）</p></li><li><p>Integer(String s)：构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。（传递的字符串，必须是基本类型的字符串，否则会抛出异常 “100” 正确 “a” 抛异常）</p></li></ul><p>静态方法:</p><ul><li><p>static Integer valueOf(int i)：返回一个表示指定的 int 值的 Integer 实例。</p></li><li><p>static Integer valueOf(String s)：返回保存指定的 String 的值的 Integer 对象。</p></li></ul><p>进制转换静态方法：</p><ul><li>static String toBinaryString(int i)：返回数字i的二进制数字符串。</li><li>static String toOctalString(int i)：返回数字i的八进制数字符串。</li><li>static String toHexString(int i)：返回数字i的十六进制数字符串。</li><li>static int parseInt(String s)： 将字符串参数s解析为带符号的十进制整数。</li><li>static int parseInt(String s, int radix)： 将整数字符串s（radix用来指明s是几进制）转换成10进制的整数。</li></ul><h3 id="1-6-2-int-和-String-的相互转换"><a href="#1-6-2-int-和-String-的相互转换" class="headerlink" title="1.6.2 int 和 String 的相互转换"></a>1.6.2 int 和 String 的相互转换</h3><ul><li>1、int 转换为 String 类型<ul><li>public static String valueOf(int i)：返回 int 参数的字符串表示形式。该方法是 String 类中的方法</li></ul></li><li>2、String 转换为 int 类型<ul><li>public static int parselnt(String s)：将字符串解析为int类型。该方法是 Integer 类中的方法</li></ul></li></ul><pre><code class="java">package ceshi;public class IntegerDemo &#123;    public static void main(String[] args) &#123;        //int --- String        int number = 10;        //1、public static String valueOf (int i)        String s = String.valueOf(number);        System.out.println(s); //10        //String --- int        String s1 = &quot;100&quot;;        //2、public static int parseInt(String s)        int i = Integer.parseInt(s1);        System.out.println(i); //100    &#125;&#125;</code></pre><h3 id="1-6-3-案例：字符串中数据排序"><a href="#1-6-3-案例：字符串中数据排序" class="headerlink" title="1.6.3 案例：字符串中数据排序"></a>1.6.3 案例：字符串中数据排序</h3><pre><code class="java">package ceshi; // 定义一个包名为&quot;ceshi&quot;import java.util.Arrays; // 导入 Arrays 类，用于排序数组public class IntegerTest &#123;    public static void main(String[] args) &#123;        String s = &quot;15 8 45 32 21&quot;; // 定义一个包含整数字符串        String[] strArray = s.split(&quot; &quot;); // 使用空格作为分隔符将字符串分割为字符串数组        int[] arr = new int[strArray.length]; // 创建一个整型数组，长度与字符串数组相同        for (int i = 0; i &lt; arr.length; i++) &#123;            arr[i] = Integer.parseInt(strArray[i]); // 将字符串数组中的每个元素转换为整数并赋值给整型数组        &#125;        Arrays.sort(arr); // 使用 Arrays 类的 sort 方法对整型数组进行排序        StringBuilder sb = new StringBuilder(); // 创建一个 StringBuilder 对象，用于拼接排序后的整数字符串        for (int i = 0; i &lt; arr.length; i++) &#123;            if (i == arr.length - 1) &#123;                sb.append(arr[i]); // 如果是数组最后一个元素，不添加逗号            &#125; else &#123;                sb.append(arr[i]).append(&quot;, &quot;); // 否则添加逗号和空格            &#125;        &#125;        String s1 = sb.toString(); // 将 StringBuilder 对象转换为字符串        System.out.println(s1); // 输出排序后的整数字符串    &#125;&#125;</code></pre><h3 id="1-6-4-自动装箱和拆箱"><a href="#1-6-4-自动装箱和拆箱" class="headerlink" title="1.6.4 自动装箱和拆箱"></a>1.6.4 自动装箱和拆箱</h3><ul><li><strong>自动装箱</strong>: 可以直接把基本数据类型的值或变量赋值给包装类</li><li><strong>自动拆箱</strong>: 可以把包装类的变量直接赋值给基本数据类型</li></ul><pre><code class="java">public class PackageClass &#123;    public static void main(String[] args) &#123;        //基本数据类型的值或变量赋值给包装类        Integer i = Integer.valueOf(100); //手动调方法装箱        Integer ii = 100; //默认调用Integer.valueOf(100);        //拆箱        int i1 = ii; //自动拆箱，100        ii +=200; //        System.out.println(ii) //300                //开发中如果是引用类型变量最好先做不为null判断        Integer iii = null;        if(iii != null) &#123;            iii += 300; //NullPointerException        &#125;                  &#125;&#125;</code></pre><ul><li><strong>注意</strong>：在使用包装类的时候，如果是操作最好先判断是否为null；推荐只要是对象，再使用前必须进行不为null判断</li></ul><h2 id="1-7-日期类"><a href="#1-7-日期类" class="headerlink" title="1.7 日期类"></a>1.7 日期类</h2><h3 id="1-7-1-Date类"><a href="#1-7-1-Date类" class="headerlink" title="1.7.1 Date类"></a>1.7.1 Date类</h3><ul><li><strong>导包</strong>：<code>java.util.Date</code></li><li><strong>构造方法</strong></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Date()</td><td>创建当前系统的此刻日期时间对象</td></tr><tr><td>public Date(long time)</td><td>把时间毫秒值转换成日期对象</td></tr></tbody></table><pre><code class="java">package ceshi;import java.util.Date;public class DateDemo &#123;    public static void main(String[] args) &#123;        //1、public Date()        Date d1 = new Date();        System.out.println(d1); //Tue Jul 06 22:36:15 CST 2021        //2、public Date(long time)        long date = 60;        Date d2 = new Date(date);        System.out.println(d2); //Thu Jan 01 08:00:00 CST 1970    &#125;&#125;</code></pre><ul><li><strong>常用方法</strong></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public long getTime()</td><td>获取日期对象从1970年1月1日00：00：00 到现在的毫秒值</td></tr><tr><td>public void setTime(long time)</td><td>设置时间，给的是毫秒值</td></tr></tbody></table><pre><code class="java">package ceshi;import java.util.Date;public class DateDemo &#123;    public static void main(String[] args) &#123;        //1、public long getTime() 获取日期对象从1970年1月1日00：00：00 到现在的毫秒值        Date d = new Date();        System.out.println(d.getTime()); //1625582796041        //2、public void setTime(long time) 设置时间，给的是毫秒值        long time = 1000*60*60;        d.setTime(time);        System.out.println(d); //Thu Jan 01 09:00:00 CST 1970    &#125;&#125;</code></pre><h3 id="1-7-2-SimpleDateFormat类-ˈsɪmpl"><a href="#1-7-2-SimpleDateFormat类-ˈsɪmpl" class="headerlink" title="1.7.2 SimpleDateFormat类 [ˈsɪmpl]"></a>1.7.2 SimpleDateFormat类 [ˈsɪmpl]</h3><ul><li>可以对日期格式化和解析</li><li>日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中,从 ‘A’ 到 ‘Z’ 以及从 ‘a’ 到’z’ 引号的字母被解释为表示日期或时间字符串的组件的模式字母</li><li>常用的模式字母对应： y—年；M—月；d—日；H—时；m—分；s—秒；E—星期几；a—上午 &#x2F; 下午</li><li>构造方法：</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public SimpleDateFormat()</td><td>使用默认模式和日期模式</td></tr><tr><td>public SimpleDateFormat(String pattern)</td><td>指定时间的格式创建简单日期格式化对象</td></tr></tbody></table><ul><li><p><strong>格式化和解析日期方法</strong></p><ul><li><p>public String format(Date date)将日期格式化为日期 &#x2F; 时间字符串</p></li><li><p>public String format(Object time)将时间毫秒格式化为日期 &#x2F; 时间字符串</p></li><li><p>public Date parse(String source) [pɑːz]从给定的字符串开始解析文本生成日期</p></li></ul></li></ul><pre><code class="java">package ceshi;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class SimpleDateFormatDemo &#123;    public static void main(String[] args) throws ParseException &#123;        //格式化 Date》String         Date d = new Date();//1、        SimpleDateFormat sdf = new SimpleDateFormat(); //无参构造        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss E a&quot;); //2、带参构造        String s = sdf.format(d);        System.out.println(s); //1、21-7-11 上午10:13  2、2021年07月11日 10:16:00 星期日 上午        //解析 String &gt; date        String s1 = &quot;2020年1月1日 8:25:12&quot;;        SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);        Date d1 = sdf1.parse(s1); //parse报错了，选中按下Alt+enter，默认选第一个        System.out.println(d1); //Wed Jan 01 08:25:12 CST 2020    &#125;&#125;</code></pre><h3 id="日期工具类"><a href="#日期工具类" class="headerlink" title="日期工具类"></a>日期工具类</h3><pre><code class="java">/** * 日期时间工具类 * */public class DateUtils &#123;    /**     * 显示年月日时分秒，例如 2015-08-11 09:51:53.     */    public static final String DATETIME_PATTERN = &quot;yyyy-MM-dd HH:mm:ss&quot;;    /**     * 显示年月日时分，例如 2015-08-11 09:51.     */    public static final String NO_SECOND_DATETIME_PATTERN = &quot;yyyy-MM-dd HH:mm&quot;;    /**     * 仅显示年月日，例如 2015-08-11.     */    public static final String DATE_PATTERN = &quot;yyyy-MM-dd&quot;;    /**     * 仅显示时分秒，例如 09:51:53.     */    public static final String TIME_PATTERN = &quot;HH:mm:ss&quot;;    /**     * 显示年月日时分秒(由/分割)，例如 2015/08/11 09:51:53.     */    public static final String DATETIME_PATTERN_WITH_SLASH = &quot;yyyy/MM/dd HH:mm:ss&quot;;    /**     * 显示年月日(由/分割)，例如 2015/08/11.     */    public static final String DATE_PATTERN_WITH_SLASH = &quot;yyyy/MM/dd&quot;;    /**     * 显示年月日时分秒(无符号)，例如 20150811095153.     */    public static final String UNSIGNED_DATETIME_PATTERN = &quot;yyyyMMddHHmmss&quot;;    /**     * 仅显示年月日(无符号)，例如 20150811.     */    public static final String UNSIGNED_DATE_PATTERN = &quot;yyyyMMdd&quot;;    /**     * 仅显示年(无符号)，例如 2015.     */    private static final String YEAR_PATTERN = &quot;yyyy&quot;;    /**     * 仅显示年月，例如 2015-08.     */    private static final String MONTH_PATTERN = &quot;yyyy-MM&quot;;    /**     * 仅显示年月(无符号)，例如 201508.     */    private static final String UNSIGNED_MONTH_PATTERN = &quot;yyyyMM&quot;;    /**     * 一天的开始时间，仅显示时分秒     */    private static final String START_TIME = &quot;00:00:00&quot;;    /**     * 一天的结束时间，仅显示时分秒     */    private static final String END_TIME = &quot;23:59:59&quot;;    /**     * 每天的毫秒数.     */    public static final long MILLISECONDS_PER_DAY = 86400000L;    /**     * 每小时毫秒数.     */    public static final long MILLISECONDS_PER_HOUR = 3600000L;    /**     * 每分钟毫秒数.     */    public static final long MILLISECONDS_PER_MINU = 60000L;    /**     * 每秒的毫秒数.     */    public static final long MILLISECONDS_PER_SECONDS = 1000L;    /**     * 每分钟秒数.     */    public static final long SECONDS_PER_MINUTE = 60L;    /**     * 每小时秒数.     */    public static final long SECONDS_PER_HOUR = 3600L;    /**     * 每天秒数.     */    public static final long SECONDS_PER_DAY = 86400L;    /**     * 每周秒数.     */    public static final long SECONDS_PER_WEEK = 604800L;    /**     * 每个月秒数，默认每月30天.     */    public static final long SECONDS_PER_MONTH = 2592000L;    /**     * 每年秒数，默认每年365天.     */    public static final long SECONDS_PER_YEAR = 31536000L;    /**     * 每周的天数.     */    public static final long DAYS_PER_WEEK = 7L;    /**     * 春天;     */    public static final Integer SPRING = 1;    /**     * 夏天;     */    public static final Integer SUMMER = 2;    /**     * 秋天;     */    public static final Integer AUTUMN = 3;    /**     * 冬天;     */    public static final Integer WINTER = 4;    /**     * 星期日;     */    public static final String SUNDAY = &quot;星期日&quot;;    /**     * 星期一;     */    public static final String MONDAY = &quot;星期一&quot;;    /**     * 星期二;     */    public static final String TUESDAY = &quot;星期二&quot;;    /**     * 星期三;     */    public static final String WEDNESDAY = &quot;星期三&quot;;    /**     * 星期四;     */    public static final String THURSDAY = &quot;星期四&quot;;    /**     * 星期五;     */    public static final String FRIDAY = &quot;星期五&quot;;    /**     * 星期六;     */    public static final String SATURDAY = &quot;星期六&quot;;    /**     * 获取当前日期和时间字符串.     *     * @return String 日期时间字符串，例如 2015-08-11 09:51:53     */    public static String getDateTimeStr() &#123;        return format(new Date(), DATETIME_PATTERN);    &#125;    /**     * 获取当前日期字符串.     *     * @return String 日期字符串，例如2015-08-11     */    public static String getDateStr() &#123;        return format(new Date(), DATE_PATTERN);    &#125;    /**     * 获取当前时间字符串.     *     * @return String 时间字符串，例如 09:51:53     */    public static String getTimeStr() &#123;        return format(new Date(), TIME_PATTERN);    &#125;    /**     * 获取当前年份字符串.     *     * @return String 当前年份字符串，例如 2015     */    public static String getYearStr() &#123;        return format(new Date(), YEAR_PATTERN);    &#125;    /**     * 获取当前月份字符串.     *     * @return String 当前月份字符串，例如 08     */    public static String getMonthStr() &#123;        return format(new Date(), &quot;MM&quot;);    &#125;    /**     * 获取当前天数字符串.     *     * @return String 当前天数字符串，例如 11     */    public static String getDayStr() &#123;        return format(new Date(), &quot;dd&quot;);    &#125;    /**     * 获取当前星期字符串.     *     * @return String 当前星期字符串，例如 星期二     */    public static String getDayOfWeekStr() &#123;        return format(new Date(), &quot;E&quot;);    &#125;    /**     * 获取指定日期是星期几     *     * @param date 日期     * @return String 星期几     */    public static String getDayOfWeekStr(Date date) &#123;        String[] weekOfDays = &#123;SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY&#125;;        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        int num = calendar.get(Calendar.DAY_OF_WEEK) - 1;        return weekOfDays[num];    &#125;    /**     * 获取当前小时字符串.     *     * @return String 当前小时字符串，例如09     */    public static String getHourStr() &#123;        return format(new Date(), &quot;HH&quot;);    &#125;    /**     * 获取当前分钟字符串.     *     * @return String 当前分钟字符串，例如51     */    public static String getMinuteStr() &#123;        return format(new Date(), &quot;mm&quot;);    &#125;    /**     * 获取当前秒钟字符串.     *     * @return String 当前秒钟字符串，例如53     */    public static String getSecondStr() &#123;        return format(new Date(), &quot;ss&quot;);    &#125;    /**     * 获取日期时间字符串     *     * @param date    需要转化的日期时间     * @param pattern 时间格式     * @return String 日期时间字符串，例如 2015-08-11 09:51:53     */    public static String format(Date date, String pattern) &#123;        return new SimpleDateFormat(pattern).format(date);    &#125;    /**     * 时间戳转换为日期时间字符串     *     * @param timestamp 时间戳     * @param pattern   日期格式 例如DATETIME_PATTERN     * @return String 日期时间字符串，例如 2015-08-11 09:51:53     */    public static String getDateTimeStr(long timestamp, String pattern) &#123;        return new SimpleDateFormat(pattern).format(timestamp);    &#125;    /**     * 日期字符串转换为日期(java.util.Date)     *     * @param dateStr 日期字符串     * @param pattern 日期格式 例如DATETIME_PATTERN     * @return Date 日期     */    public static Date parse(String dateStr, String pattern) &#123;        Date date = null;        SimpleDateFormat dateFormat = new SimpleDateFormat(pattern);        // 设置lenient为false. 否则SimpleDateFormat会比较宽松地验证日期，比如2007/02/29会被接受，并转换成2007/03/01        dateFormat.setLenient(false);        try &#123;            date = dateFormat.parse(dateStr);        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return date;    &#125;    /**     * 获取指定日期num年数之后的日期.     *     * @param num 间隔年数(负数表示之前)     * @return Date 日期     */    public static Date addYears(Date date, int num) &#123;        return add(date, num, Calendar.YEAR);    &#125;    /**     * 获取当前日期指定年数之后的日期.     *     * @param num 间隔年数(负数表示之前)     * @return Date 日期     */    public static Date addYears(int num) &#123;        return add(new Date(), num, Calendar.YEAR);    &#125;    /**     * 获取当前日期num月数之后的日期.     *     * @param num 间隔月数(负数表示之前)     * @return Date 日期     */    public static Date addMonths(Date date, int num) &#123;        return add(date, num, Calendar.MONTH);    &#125;    /**     * 获取当前日期指定月数之后的日期.     *     * @param num 间隔月数(负数表示之前)     * @return Date 日期     */    public static Date addMonths(int num) &#123;        return add(new Date(), num, Calendar.MONTH);    &#125;    /**     * 获取指定日期num周数之后的日期.     *     * @param date 日期     * @param num  周数(负数表示之前)     * @return Date 新的日期     */    public static Date addWeeks(Date date, int num) &#123;        return add(date, num, Calendar.WEEK_OF_YEAR);    &#125;    /**     * 获取当前日期指定周数之后的日期.     *     * @param num 周数(负数表示之前)     * @return Date 新的日期     */    public static Date addWeeks(int num) &#123;        return add(new Date(), num, Calendar.WEEK_OF_YEAR);    &#125;    /**     * 获取指定日期num天数之后的日期.     *     * @param date 日期     * @param num  天数(负数表示之前)     * @return Date 新的日期     */    public static Date addDays(Date date, int num) &#123;        return add(date, num, Calendar.DAY_OF_MONTH);    &#125;    /**     * 获取当前日期指定天数之后的日期.     *     * @param num 天数(负数表示之前)     * @return Date 新的日期     */    public static Date addDays(int num) &#123;        return add(new Date(), num, Calendar.DAY_OF_MONTH);    &#125;    /**     * 获取指定日期num小时之后的日期.     *     * @param date 日期     * @param num  小时数(负数表示之前)     * @return Date 新的日期     */    public static Date addHours(Date date, int num) &#123;        return add(date, num, Calendar.HOUR_OF_DAY);    &#125;    /**     * 获取当前日期指定小时之后的日期.     *     * @param num 小时数(负数表示之前)     * @return Date 新的日期     */    public static Date addHours(int num) &#123;        return add(new Date(), num, Calendar.HOUR_OF_DAY);    &#125;    /**     * 获取指定日期num分钟之后的日期.     *     * @param date 日期     * @param num  分钟数(负数表示之前)     * @return Date 新的日期     */    public static Date addMinutes(Date date, int num) &#123;        return add(date, num, Calendar.MINUTE);    &#125;    /**     * 获取当前日期指定分钟之后的日期.     *     * @param num 分钟数(负数表示之前)     * @return Date 新的日期     */    public static Date addMinutes(int num) &#123;        return add(new Date(), num, Calendar.MINUTE);    &#125;    /**     * 获取指定日期num秒钟之后的日期.     *     * @param date 日期     * @param num  秒钟数(负数表示之前)     * @return Date 新的日期     */    public static Date addSeconds(Date date, int num) &#123;        return add(date, num, Calendar.SECOND);    &#125;    /**     * 获取当前日期指定秒钟之后的日期.     *     * @param num 秒钟数(负数表示之前)     * @return Date 新的日期     */    public static Date addSeconds(int num) &#123;        return add(new Date(), num, Calendar.SECOND);    &#125;    /**     * 获取指定日期num毫秒之后的日期.     *     * @param date 日期     * @param num  毫秒数(负数表示之前)     * @return Date 新的日期     */    public static Date addMilliSeconds(Date date, int num) &#123;        return add(date, num, Calendar.MILLISECOND);    &#125;    /**     * 获取当前日期指定毫秒之后的日期.     *     * @param num 毫秒数(负数表示之前)     * @return Date 新的日期     */    public static Date addMilliSeconds(int num) &#123;        return add(new Date(), num, Calendar.MILLISECOND);    &#125;    /**     * 获取当前日期指定数量日期时间单位之后的日期.     *     * @param date 日期     * @param num  数量     * @param unit 日期时间单位     * @return Date 新的日期     */    public static Date add(Date date, int num, int unit) &#123;        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        calendar.add(unit, num);        return calendar.getTime();    &#125;    /**     * 计算两个日期之间相隔年数.     *     * @param startDate 开始日期     * @param endDate   结束日期     * @return int 相隔年数，向下取整     */    public static int getYearsBetween(Date startDate, Date endDate) &#123;        return getMonthsBetween(startDate, endDate) / 12;    &#125;    /**     * 计算两个日期之间相隔月数.     *     * @param startDate 开始日期     * @param endDate   结束日期     * @return int 相隔月数，向下取整     */    public static int getMonthsBetween(Date startDate, Date endDate) &#123;        int months;        int flag = 0;        Calendar startCalendar = Calendar.getInstance();        startCalendar.setTime(startDate);        Calendar endCalendar = Calendar.getInstance();        endCalendar.setTime(endDate);        if (endCalendar.equals(startCalendar)) &#123;            return 0;        &#125;        if (startCalendar.after(endCalendar)) &#123;            Calendar temp = startCalendar;            startCalendar = endCalendar;            endCalendar = temp;        &#125;        if (endCalendar.get(Calendar.DAY_OF_MONTH) &lt; startCalendar.get(Calendar.DAY_OF_MONTH)) &#123;            flag = 1;        &#125;        if (endCalendar.get(Calendar.YEAR) &gt; startCalendar.get(Calendar.YEAR)) &#123;            months = ((endCalendar.get(Calendar.YEAR) - startCalendar.get(Calendar.YEAR))                    * 12 + endCalendar.get(Calendar.MONTH) - flag)                    - startCalendar.get(Calendar.MONTH);        &#125; else &#123;            months = endCalendar.get(Calendar.MONTH)                    - startCalendar.get(Calendar.MONTH) - flag;        &#125;        return months;    &#125;    /**     * 计算两个日期之间相隔周数.     *     * @param startDate 开始日期     * @param endDate   结束日期     * @return long 相隔周数，向下取整     */    public static long getWeeksBetween(Date startDate, Date endDate) &#123;        return getDaysBetween(startDate, endDate) / DAYS_PER_WEEK;    &#125;    /**     * 计算两个日期之间相隔天数.     *     * @param startDate 开始日期     * @param endDate   结束日期     * @return long 相隔天数，向下取整     */    public static long getDaysBetween(Date startDate, Date endDate) &#123;        return (endDate.getTime() - startDate.getTime()) / MILLISECONDS_PER_DAY;    &#125;    /**     * 计算两个日期之间相隔小时数.     *     * @param startDate 开始日期     * @param endDate   结束日期     * @return long 相隔小时数，向下取整     */    public static long getHoursBetween(Date startDate, Date endDate) &#123;        return (endDate.getTime() - startDate.getTime()) / MILLISECONDS_PER_HOUR;    &#125;    /**     * 计算两个日期之间相隔分钟数.     *     * @param startDate 开始日期     * @param endDate   结束日期     * @return long 相隔分钟数，向下取整     */    public static long getMinutesBetween(Date startDate, Date endDate) &#123;        return (endDate.getTime() - startDate.getTime()) / MILLISECONDS_PER_MINU;    &#125;    /**     * 计算两个日期之间相隔秒数.     *     * @param startDate 开始日期     * @param endDate   结束日期     * @return long 相隔秒数，向下取整     */    public static long getSecondsBetween(Date startDate, Date endDate) &#123;        return (endDate.getTime() - startDate.getTime()) / MILLISECONDS_PER_SECONDS;    &#125;    /**     * 获取当前季度.     * 注意:3～5月为春季 1，6～8月为夏季 2，9～11月为秋季 3，12～2月为冬季 4     *     * @return int 当前季度数     */    public static int getCurrentSeason() &#123;        Calendar calendar = Calendar.getInstance();        int month = calendar.get(Calendar.MONTH) + 1;        int season = 0;        if (month &gt;= 3 &amp;&amp; month &lt;= 5) &#123;            season = SPRING;        &#125; else if (month &gt;= 6 &amp;&amp; month &lt;= 8) &#123;            season = SUMMER;        &#125; else if (month &gt;= 9 &amp;&amp; month &lt;= 11) &#123;            season = AUTUMN;        &#125; else if (month == 12 || month &gt;= 1 &amp;&amp; month &lt;= 2) &#123;            season = WINTER;        &#125;        return season;    &#125;    /**     * 获取当前日期与之前日期的时间间隔.     *     * @param date 之前的日期     * @return String 例如 16分钟前、2小时前、3天前、4月前、5年前等     */    public static String getIntervalByDate(Date date) &#123;        long secondsBetween = getSecondsBetween(date, new Date());        return getIntervalBySeconds(secondsBetween);    &#125;    /**     * 将以秒为单位的时间转换为其他单位.     *     * @param seconds 秒数     * @return String 例如 16分钟前、2小时前、3天前、4月前、5年前等     */    public static String getIntervalBySeconds(long seconds) &#123;        StringBuffer buffer = new StringBuffer();        if (seconds &lt; SECONDS_PER_MINUTE) &#123;            buffer.append(seconds).append(&quot;秒前&quot;);        &#125; else if (seconds &lt; SECONDS_PER_HOUR) &#123;            buffer.append((long) Math.floor(seconds / SECONDS_PER_MINUTE)).append(&quot;分钟前&quot;);        &#125; else if (seconds &lt; SECONDS_PER_DAY) &#123;            buffer.append((long) Math.floor(seconds / SECONDS_PER_HOUR)).append(&quot;小时前&quot;);        &#125; else if (seconds &lt; SECONDS_PER_WEEK) &#123;            buffer.append((long) Math.floor(seconds / SECONDS_PER_DAY)).append(&quot;天前&quot;);        &#125; else if (seconds &lt; SECONDS_PER_MONTH) &#123;            buffer.append((long) Math.floor(seconds / SECONDS_PER_WEEK)).append(&quot;周前&quot;);        &#125; else if (seconds &lt; SECONDS_PER_YEAR) &#123;            buffer.append((long) Math.floor(seconds / SECONDS_PER_MONTH)).append(&quot;月前&quot;);        &#125; else &#123;            buffer.append((long) Math.floor(seconds / SECONDS_PER_YEAR)).append(&quot;年前&quot;);        &#125;        return buffer.toString();    &#125;    /**     * 将 Date 日期转化为 Calendar 类型日期.     *     * @param date 指定日期     * @return Calendar Calendar对象     */    public static Calendar getCalendar(Date date) &#123;        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        return calendar;    &#125;    /**     * 得到UTC时间，类型为字符串，格式为&quot;yyyy-MM-dd HH:mm&quot;     * 如果获取失败，返回null     *     * @return     */    public static String getUTCTimeStr() &#123;        StringBuffer UTCTimeBuffer = new StringBuffer();        // 1、取得本地时间：        Calendar cal = Calendar.getInstance();        // 2、取得时间偏移量：        int zoneOffset = cal.get(Calendar.ZONE_OFFSET);        // 3、取得夏令时差：        int dstOffset = cal.get(Calendar.DST_OFFSET);        // 4、从本地时间里扣除这些差量，即可以取得UTC时间：        cal.add(Calendar.MILLISECOND, -(zoneOffset + dstOffset));        int year = cal.get(Calendar.YEAR);        int month = cal.get(Calendar.MONTH) + 1;        int day = cal.get(Calendar.DAY_OF_MONTH);        int hour = cal.get(Calendar.HOUR_OF_DAY);        int minute = cal.get(Calendar.MINUTE);        UTCTimeBuffer.append(year).append(&quot;-&quot;).append(month).append(&quot;-&quot;).append(day);        UTCTimeBuffer.append(&quot; &quot;).append(hour).append(&quot;:&quot;).append(minute);        try &#123;            SimpleDateFormat sdf = new SimpleDateFormat(NO_SECOND_DATETIME_PATTERN);            sdf.parse(UTCTimeBuffer.toString());            return UTCTimeBuffer.toString();        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**     * 将Timestamp转换为yyyy-MM-dd HH:mm:ss格式字符串     *     * @param timestamp     * @return     */    public static String timestampToStr(Timestamp timestamp) &#123;        return timestamp.toString().substring(0, 19);    &#125;    /**     * 比较传进来的日期是否大于当前日期，如果传进来的日期大于当前日期则返回true，否则返回false     *     * @param dateStr 日期字符串     * @param pattern 日期格式     * @return boolean     */    public static boolean compareNowDate(String dateStr, String pattern) &#123;        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);        try &#123;            Date date = simpleDateFormat.parse(dateStr);            return date.after(new Date());        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return false;    &#125;    /**     * 如果endDateStr&gt;startDateStr，返回true，否则返回false     *     * @param startDateStr 开始日期字符串     * @param endDateStr   结束日期字符串     * @param pattern      日期格式     * @return boolean     */    public static boolean compareDate(String startDateStr, String endDateStr, String pattern) &#123;        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);        try &#123;            Date startDate = simpleDateFormat.parse(startDateStr);            Date endDate = simpleDateFormat.parse(endDateStr);            return endDate.after(startDate);        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return false;    &#125;    /**     * 如果startDate&gt;endDate，返回true，否则返回false     *     * @param startDate 开始日期字符串     * @param endDate   结束日期字符串     * @return boolean     */    public static boolean compareDate(Date startDate, Date endDate) &#123;        return endDate.after(startDate);    &#125;    /**     * 判断日期是否合法     *     * @param dateStr yyyy-MM-dd HH:mm:ss格式日期字符串     * @return     */    public static boolean isValidDate(String dateStr) &#123;        boolean convertSuccess = true;        // 指定日期格式为四位年/两位月份/两位日期        SimpleDateFormat format = new SimpleDateFormat(DATETIME_PATTERN);        try &#123;            // 设置lenient为false. 否则SimpleDateFormat会比较宽松地验证日期，比如2007/02/29会被接受，并转换成2007/03/01            format.setLenient(false);            format.parse(dateStr);        &#125; catch (ParseException e) &#123;            e.printStackTrace();            // 如果throw java.text.ParseException或者NullPointerException，就说明格式不对            convertSuccess = false;        &#125;        return convertSuccess;    &#125;    /**     * 判断日期是否为月底最后一天     *     * @param date 日期     * @return boolean true:是  false:否     */    public static boolean isLastDayofMonth(Date date) &#123;        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));        if (calendar.get(Calendar.DAY_OF_MONTH) == 1) &#123;            return true;        &#125;        return false;    &#125;    /**     * 获取本年第一天的日期字符串     *     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getYearStartTimeStr() &#123;        return getDateTimeStr(getStartDayOfYear(new Date()));    &#125;    /**     * 获取指定日期当年第一天的日期字符串     *     * @param date     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getYearStartTimeStr(Date date) &#123;        return getDateTimeStr(getStartDayOfYear(date));    &#125;    /**     * 获取本年最后一天的日期字符串     *     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getYearEndTimeStr() &#123;        return getDateTimeStr(getEndDayOfYear(new Date()));    &#125;    /**     * 获取指定日期当年最后一天的日期字符串     *     * @param date 指定日期     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getYearEndTimeStr(Date date) &#123;        return getDateTimeStr(getEndDayOfYear(date));    &#125;    /**     * 获取本月第一天的日期字符串     * 格式：yyyy-MM-dd HH:mm:ss     *     * @return     */    public static String getMonthStartTimeStr() &#123;        return getDateTimeStr(getStartDayOfMonth(new Date()));    &#125;    /**     * 获取指定日期当月第一天的日期字符串     *     * @param date 指定日期     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getMonthStartTimeStr(Date date) &#123;        return getDateTimeStr(getStartDayOfMonth(date));    &#125;    /**     * 获取本月最后一天的日期字符串     *     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getMonthEndTimeStr() &#123;        return getDateTimeStr(getEndDayOfMonth(new Date()));    &#125;    /**     * 获取指定日期当月最后一天的日期字符串     *     * @param date 指定日期     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getMonthEndTimeStr(Date date) &#123;        return getDateTimeStr(getEndDayOfMonth(date));    &#125;    /**     * 获取本周第一天的日期字符串     *     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getWeekStartTimeStr() &#123;        return getDateTimeStr(getStartDayOfWeek(new Date()));    &#125;    /**     * 获取指定日期当周第一天的日期字符串     *     * @param date 指定日期     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getWeekStartTimeStr(Date date) &#123;        return getDateTimeStr(getStartDayOfWeek(date));    &#125;    /**     * 获取本周最后一天的日期字符串     *     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getWeekEndTimeStr() &#123;        return getDateTimeStr(getEndDayOfWeek(new Date()));    &#125;    /**     * 获取指定日期当周最后一天的日期字符串     *     * @param date 指定日期     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getWeekEndTimeStr(Date date) &#123;        return getDateTimeStr(getEndDayOfWeek(date));    &#125;    /**     * 获取今天的开始时间字符串     *     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getTodayStartTimeStr() &#123;        return getDateTimeStr(getTodayStartTime(new Date()));    &#125;    /**     * 获取指定日期的开始时间字符串     *     * @param date 指定日期     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getTodayStartTimeStr(Date date) &#123;        return getDateTimeStr(getTodayStartTime(date));    &#125;    /**     * 获取今天的结束时间字符串     *     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getTodayEndTimeStr() &#123;        return getDateTimeStr(getTodayEndTime(new Date()));    &#125;    /**     * 获取指定日期的结束时间字符串     *     * @param date 指定日期     * @return String 格式：yyyy-MM-dd HH:mm:ss     */    public static String getTodayEndTimeStr(Date date) &#123;        return getDateTimeStr(getTodayEndTime(date));    &#125;    /**     * 获得指定日期所在日的开始时间字符串     *     * @param date 指定日期     * @return String 例如：2020-12-06 00:00:00     */    public static String getDateStartTimeStr(Date date) &#123;        String result = format(date, DATE_PATTERN);        return result.concat(&quot; &quot;).concat(START_TIME);    &#125;    /**     * 获得指定日期所在日的结束时间字符串     *     * @param date 指定日期     * @return String 例如：2020-12-06 23:59:59     */    public static String getDateEndTimeStr(Date date) &#123;        String result = format(date, DATE_PATTERN);        return result.concat(&quot; &quot;).concat(END_TIME);    &#125;    /**     * 根据日历返回日期时间字符串     *     * @param calendar 日历     * @return String 日期时间字符串     */    public static String getDateTimeStr(Calendar calendar) &#123;        StringBuffer buf = new StringBuffer(&quot;&quot;);        buf.append(calendar.get(Calendar.YEAR));        buf.append(&quot;-&quot;);        buf.append(calendar.get(Calendar.MONTH) + 1 &gt; 9 ? calendar.get(Calendar.MONTH) + 1 + &quot;&quot;                : &quot;0&quot; + (calendar.get(Calendar.MONTH) + 1));        buf.append(&quot;-&quot;);        buf.append(calendar.get(Calendar.DAY_OF_MONTH) &gt; 9 ? calendar.get(Calendar.DAY_OF_MONTH) + &quot;&quot;                : &quot;0&quot; + calendar.get(Calendar.DAY_OF_MONTH));        buf.append(&quot; &quot;);        buf.append(calendar.get(Calendar.HOUR_OF_DAY) &gt; 9 ? calendar.get(Calendar.HOUR_OF_DAY) + &quot;&quot;                : &quot;0&quot; + calendar.get(Calendar.HOUR_OF_DAY));        buf.append(&quot;:&quot;);        buf.append(calendar.get(Calendar.MINUTE) &gt; 9 ? calendar.get(Calendar.MINUTE) + &quot;&quot;                : &quot;0&quot; + calendar.get(Calendar.MINUTE));        buf.append(&quot;:&quot;);        buf.append(calendar.get(Calendar.SECOND) &gt; 9 ? calendar.get(Calendar.SECOND) + &quot;&quot;                : &quot;0&quot; + calendar.get(Calendar.SECOND));        return buf.toString();    &#125;    /**     * 获取今年的第一天     *     * @return Calendar 日历     */    public static Calendar getStartDayOfYear(Date date) &#123;        Calendar calendar = Calendar.getInstance(Locale.CHINA);        calendar.setTime(date);        calendar.set(Calendar.DAY_OF_YEAR, 1);        calendar.set(Calendar.HOUR_OF_DAY, 0);        calendar.set(Calendar.MINUTE, 0);        calendar.set(Calendar.SECOND, 0);        return calendar;    &#125;    /**     * 获取今年的最后一天     *     * @return Calendar 日历     */    public static Calendar getEndDayOfYear(Date date) &#123;        Calendar calendar = Calendar.getInstance(Locale.CHINA);        calendar.setTime(date);        int i = calendar.getActualMaximum(Calendar.DAY_OF_YEAR);        calendar.set(Calendar.DAY_OF_YEAR, i);        calendar.set(Calendar.HOUR_OF_DAY, 23);        calendar.set(Calendar.MINUTE, 59);        calendar.set(Calendar.SECOND, 59);        return calendar;    &#125;    /**     * 获取本月的第一天     *     * @return Calendar 日历     */    public static Calendar getStartDayOfMonth(Date date) &#123;        Calendar calendar = Calendar.getInstance(Locale.CHINA);        calendar.setTime(date);        calendar.set(Calendar.DAY_OF_MONTH, 1);        calendar.set(Calendar.HOUR_OF_DAY, 0);        calendar.set(Calendar.MINUTE, 0);        calendar.set(Calendar.SECOND, 0);        return calendar;    &#125;    /**     * 获取本月的最后一天     *     * @return Calendar 日历     */    public static Calendar getEndDayOfMonth(Date date) &#123;        Calendar calendar = Calendar.getInstance(Locale.CHINA);        calendar.setTime(date);        int i = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);        calendar.set(Calendar.DAY_OF_MONTH, i);        calendar.set(Calendar.HOUR_OF_DAY, 23);        calendar.set(Calendar.MINUTE, 59);        calendar.set(Calendar.SECOND, 59);        return calendar;    &#125;    /**     * 获取本周的第一天，一个星期的第一天是星期一，最后一天是星期天     *     * @return Calendar 日历     */    public static Calendar getStartDayOfWeek(Date date) &#123;        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        // 设置一个星期的第一天，按中国的习惯一个星期的第一天是星期一        calendar.setFirstDayOfWeek(Calendar.MONDAY);        calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);        calendar.set(Calendar.HOUR_OF_DAY, 0);        calendar.set(Calendar.MINUTE, 0);        calendar.set(Calendar.SECOND, 0);        return calendar;    &#125;    /**     * 获取本周的最后一天，一个星期的第一天是星期一，最后一天是星期天     *     * @return Calendar 日历     */    public static Calendar getEndDayOfWeek(Date date) &#123;        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        // 设置一个星期的第一天，按中国的习惯一个星期的第一天是星期一        calendar.setFirstDayOfWeek(Calendar.MONDAY);        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);        calendar.set(Calendar.HOUR_OF_DAY, 23);        calendar.set(Calendar.MINUTE, 59);        calendar.set(Calendar.SECOND, 59);        return calendar;    &#125;    /**     * 获取今天开始时间     *     * @return     */    public static Calendar getTodayStartTime(Date date) &#123;        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        calendar.set(Calendar.HOUR_OF_DAY, 0);        calendar.set(Calendar.MINUTE, 0);        calendar.set(Calendar.SECOND, 0);        calendar.set(Calendar.MILLISECOND, 0);        return calendar;    &#125;    /**     * 获取今天结束时间     *     * @return     */    public static Calendar getTodayEndTime(Date date) &#123;        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        calendar.set(Calendar.HOUR_OF_DAY, 23);        calendar.set(Calendar.MINUTE, 59);        calendar.set(Calendar.SECOND, 59);        calendar.set(Calendar.MILLISECOND, 999);        return calendar;    &#125;    /**     * 根据日期范围，获取按周期划分的日期区间     *     * @param startDateStr 开始日期（格式：2020-11-29）     * @param endDateStr   结束日期（格式：2020-12-02）     * @param pattern      日期格式（支持：DATE_PATTERN，MONTH_PATTERN，YEAR_PATTERN）     * @return List&lt;String&gt; 区间集合 例如：[2020-11-29,2020-11-30,2020-12-01,2020-12-02]     */    public static List&lt;String&gt; getDateStrList(String startDateStr, String endDateStr, String pattern) &#123;        Date start = parse(startDateStr, pattern);        Date end = parse(endDateStr, pattern);        return getDateStrList(start, end, pattern);    &#125;    /**     * 根据日期范围，获取按周期划分的日期区间     *     * @param startDate 开始日期     * @param endDate   结束日期     * @param pattern   日期格式（支持：DATE_PATTERN，MONTH_PATTERN，YEAR_PATTERN）     * @return List&lt;String&gt; 区间集合 例如：[2020-11-29,2020-11-30,2020-12-01,2020-12-02]     */    public static List&lt;String&gt; getDateStrList(Date startDate, Date endDate, String pattern) &#123;        List&lt;String&gt; result = new ArrayList&lt;&gt;();        Calendar calendar = Calendar.getInstance();        calendar.setTime(startDate);        if (DATE_PATTERN.equals(pattern)) &#123;            while (startDate.before(endDate) || startDate.equals(endDate)) &#123;                result.add(new SimpleDateFormat(DATE_PATTERN).format(calendar.getTimeInMillis()));                calendar.add(Calendar.DATE, 1);                startDate = calendar.getTime();            &#125;        &#125; else if (MONTH_PATTERN.equals(pattern)) &#123;            while (startDate.before(endDate) || startDate.equals(endDate)) &#123;                result.add(new SimpleDateFormat(MONTH_PATTERN).format(calendar.getTimeInMillis()));                calendar.add(Calendar.MONTH, 1);                startDate = calendar.getTime();            &#125;        &#125; else if (YEAR_PATTERN.equals(pattern)) &#123;            while (startDate.before(endDate) || startDate.equals(endDate)) &#123;                result.add(new SimpleDateFormat(YEAR_PATTERN).format(calendar.getTimeInMillis()));                calendar.add(Calendar.YEAR, 1);                startDate = calendar.getTime();            &#125;        &#125;        return result;    &#125;    /**     * 获取当前日期前后num天的集合     *     * @param num 天数（正数：之后；负数：之前）     * @return List&lt;String&gt; 前/后日期的集合（包含指定日期）     */    public static List&lt;String&gt; getDateStrList(int num) &#123;        return getDateStrList(new Date(), num, DATE_PATTERN);    &#125;    /**     * 获取指定日期前后num天的集合     *     * @param date 指定日期     * @param num  天数（正数：之后；负数：之前）     * @return List&lt;String&gt; 前/后日期的集合（包含指定日期）     */    public static List&lt;String&gt; getDateStrList(Date date, int num) &#123;        return getDateStrList(date, num, DATE_PATTERN);    &#125;    /**     * 获取指定日期前后num天的集合，带日期格式参数     *     * @param date    指定日期     * @param num     天数（正数：之后；负数：之前）     * @param pattern 日期格式     * @return List&lt;String&gt; 前/后日期的集合（包含指定日期）  例如：[2020-11-29,2020-11-30,2020-12-01]     */    public static List&lt;String&gt; getDateStrList(Date date, int num, String pattern) &#123;        List&lt;String&gt; result = new ArrayList&lt;&gt;();        Calendar c = Calendar.getInstance();        c.setTime(date);        boolean flag = false;        if (num &lt; 0) &#123;            num = Math.abs(num);            flag = true;        &#125;        for (int i = 0; i &lt; num; i++) &#123;            result.add(new SimpleDateFormat(pattern).format(c.getTimeInMillis()));            c.add(Calendar.DATE, flag ? -1 : 1);        &#125;        if (flag) &#123;            Collections.reverse(result);        &#125;        return result;    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;=======================&quot;);        System.out.println(getYearStr());        System.out.println(getMonthStr());        System.out.println(getDayStr());        System.out.println(getHourStr());        System.out.println(getMinuteStr());        System.out.println(getSecondStr());        System.out.println(getDateTimeStr());        System.out.println(getDateStr());        System.out.println(getTimeStr());        System.out.println(getDayOfWeekStr());        System.out.println(getDayOfWeekStr(parse(&quot;2020-12-05&quot;, DATE_PATTERN)));        System.out.println(getDateTimeStr(System.currentTimeMillis(), DATETIME_PATTERN));        System.out.println(&quot;=======================&quot;);        System.out.println(parse(&quot;2020-12-31&quot;, DATE_PATTERN));        System.out.println(&quot;=======================&quot;);        System.out.println(addYears(1));        System.out.println(addYears(new Date(), -1));        System.out.println(addMonths(1));        System.out.println(addMonths(new Date(), -1));        System.out.println(addWeeks(1));        System.out.println(addWeeks(new Date(), -1));        System.out.println(addDays(1));        System.out.println(addDays(new Date(), -1));        System.out.println(addHours(1));        System.out.println(addHours(new Date(), -1));        System.out.println(addMinutes(1));        System.out.println(addMinutes(new Date(), -1));        System.out.println(addSeconds(1));        System.out.println(addSeconds(new Date(), -1));        System.out.println(addMilliSeconds(1));        System.out.println(addMilliSeconds(new Date(), -1));        System.out.println(&quot;=======================&quot;);        System.out.println(getYearsBetween(parse(&quot;2020-01-30&quot;, DATE_PATTERN), parse(&quot;2021-01-29&quot;, DATE_PATTERN)));        System.out.println(getMonthsBetween(parse(&quot;2020-01-30&quot;, DATE_PATTERN), parse(&quot;2021-01-29&quot;, DATE_PATTERN)));        System.out.println(getWeeksBetween(parse(&quot;2020-01-30&quot;, DATE_PATTERN), parse(&quot;2020-02-06&quot;, DATE_PATTERN)));        System.out.println(getDaysBetween(parse(&quot;2020-01-30&quot;, DATE_PATTERN), parse(&quot;2020-02-06&quot;, DATE_PATTERN)));        System.out.println(getHoursBetween(parse(&quot;2020-01-30&quot;, DATE_PATTERN), parse(&quot;2020-02-06&quot;, DATE_PATTERN)));        System.out.println(getMinutesBetween(parse(&quot;2020-01-30&quot;, DATE_PATTERN), parse(&quot;2020-02-06&quot;, DATE_PATTERN)));        System.out.println(getSecondsBetween(parse(&quot;2020-12-06 19:47:00&quot;, DATETIME_PATTERN), parse(&quot;2020-12-06 19:47:50&quot;, DATETIME_PATTERN)));        System.out.println(&quot;=======================&quot;);        System.out.println(getCurrentSeason());        System.out.println(&quot;=======================&quot;);        System.out.println(getIntervalByDate(parse(&quot;2020-12-06 19:30:00&quot;, DATETIME_PATTERN)));        System.out.println(getIntervalBySeconds(604800L));        System.out.println(&quot;=======================&quot;);        System.out.println(getCalendar(new Date()));        System.out.println(getUTCTimeStr());        System.out.println(&quot;=======================&quot;);        System.out.println(timestampToStr(new Timestamp(System.currentTimeMillis())));        System.out.println(&quot;=======================&quot;);        System.out.println(compareNowDate(&quot;2020-12-07&quot;, DATE_PATTERN));        System.out.println(compareDate(parse(&quot;2020-12-05&quot;, DATE_PATTERN), new Date()));        System.out.println(compareDate(&quot;2020-12-05&quot;, &quot;2020-12-06&quot;, DATE_PATTERN));        System.out.println(&quot;=======================&quot;);        System.out.println(isValidDate(&quot;2020-02-29 23:59:00&quot;));        System.out.println(isLastDayofMonth(parse(&quot;2020-11-01 00:00:00&quot;, DATETIME_PATTERN)));        System.out.println(&quot;=======================&quot;);        System.out.println(getYearStartTimeStr());        System.out.println(getYearStartTimeStr(parse(&quot;2019-12-06&quot;, DATE_PATTERN)));        System.out.println(getYearEndTimeStr());        System.out.println(getYearEndTimeStr(parse(&quot;2019-12-06&quot;, DATE_PATTERN)));        System.out.println(getMonthStartTimeStr());        System.out.println(getMonthStartTimeStr(parse(&quot;2019-12-06&quot;, DATE_PATTERN)));        System.out.println(getMonthEndTimeStr());        System.out.println(getMonthEndTimeStr(parse(&quot;2019-12-06&quot;, DATE_PATTERN)));        System.out.println(getWeekStartTimeStr());        System.out.println(getWeekStartTimeStr(parse(&quot;2019-12-06&quot;, DATE_PATTERN)));        System.out.println(getWeekEndTimeStr());        System.out.println(getWeekEndTimeStr(parse(&quot;2019-12-06&quot;, DATE_PATTERN)));        System.out.println(getTodayStartTimeStr());        System.out.println(getTodayStartTimeStr(parse(&quot;2019-12-06&quot;, DATE_PATTERN)));        System.out.println(getTodayEndTimeStr());        System.out.println(getTodayEndTimeStr(parse(&quot;2019-12-06&quot;, DATE_PATTERN)));        System.out.println(getDateStartTimeStr(parse(&quot;2020-11-01 00:00:00&quot;, DATETIME_PATTERN)));        System.out.println(getDateEndTimeStr(parse(&quot;2020-11-01 00:00:00&quot;, DATETIME_PATTERN)));        System.out.println(&quot;=======================&quot;);        List&lt;String&gt; strList1 = getDateStrList(3);        for (String s : strList1) &#123;            System.out.println(s);        &#125;        System.out.println(&quot;=======================&quot;);        List&lt;String&gt; dayList = getDateStrList(parse(&quot;2020-11-29&quot;, DATE_PATTERN), 3);        for (String s : dayList) &#123;            System.out.println(s);        &#125;        System.out.println(&quot;=======================&quot;);        List&lt;String&gt; dateList = getDateStrList(&quot;2020-11-29&quot;, &quot;2020-12-06&quot;, DATE_PATTERN);        for (String s : dateList) &#123;            System.out.println(s);        &#125;        System.out.println(&quot;=======================&quot;);        List&lt;String&gt; strList = getDateStrList(parse(&quot;2020-11-29&quot;, DATE_PATTERN), parse(&quot;2020-12-06&quot;, DATE_PATTERN), DATE_PATTERN);        for (String s : strList) &#123;            System.out.println(s);        &#125;    &#125;&#125;</code></pre><h5 id="1-7-3Calendar日历"><a href="#1-7-3Calendar日历" class="headerlink" title="1.7.3Calendar日历"></a>1.7.3Calendar日历</h5><ul><li><p>Calendar 代表了系统此刻日期对应的日历对象</p></li><li><p>Calendar 是一个<strong>抽象类</strong>，不能直接创建对象</p></li><li><p><strong>常用方法</strong></p><ul><li><p>public static Calendar getInstance()返回一个日历类的对象</p></li><li><p>public int get(int field)返回给定日历的值</p></li><li><p>public void set(int field,int value)修改日历的某个字段信息</p></li><li><p>public abstract void add(int field,int amount)根据日历的规则，将指定的时间量添加或减去给定的日历字段</p></li><li><p>public final void set(int year,int month,int date)设置当前日历年月日</p></li></ul></li></ul><pre><code>package ceshi;import java.util.Calendar;public class CalendarDemo &#123;    public static void main(String[] args) &#123;        //1、获取Calendar对象        Calendar c = Calendar.getInstance(); //多态形式        //2、public int get (int field) 根据给的日历字段返回值   /*     int year = c.get(Calendar.YEAR);        int month = c.get(Calendar.MONTH) + 1; //从0开始所以加个1        int date = c.get(Calendar.DATE);        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;); //2021年7月7日*/                //3、public void set(int field,int value) 修改日历的某个字段信息        //c.set(Calendar.YEAR,2099);        // System.out.println(rightNow.get(Calendar.YEAR)); //2099                //4、public abstract void add(int field,int amount):根据日历的规则，将指定的时间量添加或减去给定的日历字段        //需求1:三年前/*        c.add(Calendar.YEAR,-3);        int year = c.get(Calendar.YEAR);        System.out.println(year); //2018,减了三年*/        //需求2：十年后，五天前        /*c.add(Calendar.YEAR,10);        c.add(Calendar.DATE,-5);        System.out.println();        int year = c.get(Calendar.YEAR);        int month = c.get(Calendar.MONTH) + 1;        int date = c.get(Calendar.DATE);        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;); //2031年7月2日*/        //5、public final void set(int year,int month,int date)：设置当前日历年月日        c.set(2022,1,1);        int year = c.get(Calendar.YEAR);        int month = c.get(Calendar.MONTH) + 1;        int date = c.get(Calendar.DATE);        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;); //2022年2月1日    &#125;&#125;</code></pre><h1 id="2-String类"><a href="#2-String类" class="headerlink" title="2 String类"></a>2 String类</h1><h2 id="2-1-String概括"><a href="#2-1-String概括" class="headerlink" title="2.1 String概括"></a>2.1 String概括</h2><ul><li>String 类 在java.lang包下，所以使用的时候不需要导包</li><li>java程序中所有的双引号字符串，都是String这个类的对象</li><li>特点：字符串不可变，它们的值在创建后不可改变</li></ul><h2 id="2-2-String构造方法"><a href="#2-2-String构造方法" class="headerlink" title="2.2 String构造方法"></a>2.2 String构造方法</h2><ul><li><p>String()：初始化新创建的String对象，以使其表示空字符序列。</p></li><li><p>String(char[] value)：通过当前参数中的字符数组来构造新的String。</p></li><li><p>String(byte[] bytes)：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。&#x3D;&#x3D;双引号直接写的字符串在常量池当中，new的不在池当中。地址值不同.&#x3D;&#x3D;</p></li><li><p>String(byte[] bytes, int offset, int length)：通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。&#x2F;&#x2F;把字节数组的一部分转换为字符串。</p></li><li><p>String(char[] value, int offset, int count)：分配一个新的 String，它包含取自字符数组参数一个子数组的字符。&#x2F;&#x2F;把字符数组的一部分转换为字符串。</p><p>&#x3D;&#x3D;把字节&#x2F;字符数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数 count:转换的字符个数&#x3D;&#x3D;</p></li></ul><h2 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法:"></a>判断功能的方法:</h2><ul><li><p>boolean equals(Objectan Object)：将此字符串与指定对象进行比较。</p></li><li><p>boolean equalsIgnoreCase(String anotherString)：将此字符串与指定对象进行比较，忽略大小写。</p><p>&#x3D;&#x3D;Object是”对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。&#x3D;&#x3D;</p></li></ul><h2 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法:"></a>获取功能的方法:</h2><ul><li>int length()：返回此字符串的长度。</li><li>String concat(String str)：将指定的字符串连接到该字符串的末尾。</li><li>char charAt(int index)：返回指定索引处的char值。</li><li>int indexOf(String str)：返回指定子字符串第一次出现在该字符串内的索引。</li><li>String substring(int beginIndex)：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</li><li>String substring(int beginIndex, int endIndex)：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</li></ul><h2 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法:"></a>转换功能的方法:</h2><ul><li>char[] toCharArray()：将此字符串转换为新的字符数组。</li><li>byte[] getBytes()：使用平台的默认字符集将该String编码转换为新的字节数组。</li><li>String replaceAll(String regex, String replacement)：成功则返回替换的字符串，失败则返回原始字符串。其中regex为匹配此字符串的正则表达式；replacement为用来替换每个匹配项的字符串。</li><li>String replace(CharSequence target, CharSequencere placement)：将与target匹配的字符串使用replacement字符串替换。</li><li>CharSequence是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中。</li></ul><h2 id="分割功能的方法"><a href="#分割功能的方法" class="headerlink" title="分割功能的方法:"></a>分割功能的方法:</h2><ul><li>String[] split(String regex)：将此字符串按照给定的regex（规则）拆分为字符串数组。</li><li>split方法的参数其实是一个“正则表达式”，如果按照英文句点“.”进行切分，必须写”.”。<br>将基本数据型态转换成String的static方法：</li><li>String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串。</li><li>String.valueOf(char c) : 将 char 变量 c 转换成字符串。</li><li>String.valueOf(char[] data) : 将 char 数组 data 转换成字符串。</li><li>String.valueOf(char[] data, int offset, int count) : 将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串。</li><li>String.valueOf(double d) : 将 double 变量 d 转换成字符串。</li><li>String.valueOf(float f) : 将 float 变量 f 转换成字符串。</li><li>String.valueOf(int i) : 将 int 变量 i 转换成字符串。</li><li>String.valueOf(long l) : 将 long 变量 l 转换成字符串。</li><li>String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString()。<br>将String转换成基本数据型态的方法：<br>详情参考parseXxx系列方法。</li></ul><pre><code class="java">public class Demo&#123;    public static void main(String[] args)&#123;        //1.public String() 创建一个空字符串对象，不包含任何内容        String s1 = new String();        System.out.println(&quot;s1:&quot;+s1); //s1:（无内容）        //2.public String(chas[] chs) 根据字符数组内容，来创建字符串对象        char[] chs = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;        String s2 = new String(chs);        System.out.println(&quot;s2:&quot;+s2); //s2:abc        //3.public String(byte[] bys) 根据字节数组内容，来创建字符串对象        byte[] bys = &#123;97,98,99&#125;; //对应计算机底层字符        String s3 = new String(bys);        System.out.println(&quot;s3:&quot;+s3); //s3:abc        //4.String s = “abc”; 直接赋值的方法创建字符串对象，内容就是abc        String s4 = &quot;abc&quot;;        System.out.println(&quot;s4:&quot;+s4); //s4:abc    &#125;&#125;</code></pre><h2 id="2-3-String对象的区别"><a href="#2-3-String对象的区别" class="headerlink" title="2.3 String对象的区别"></a>2.3 String对象的区别</h2><p>1.通过 new 创建字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p><p>2.以 “ ” 方式给出的字符串，只要字符串的序列相同（顺序和大小写），无论在程序中出现多少次，JVM都只会建立一个String对象，并在字符串池维护</p><p>内存</p><p><img src="/2024/03/11/java%E5%B8%B8%E7%94%A8API/image-20240312182518251.png" alt="image-20240312182518251"></p><h2 id="2-5-String字符串比较"><a href="#2-5-String字符串比较" class="headerlink" title="2.5 String字符串比较"></a>2.5 String字符串比较</h2><ul><li>使用双等号作比较<ul><li>基本类型：比较的是数据值是否相同</li><li>引用类型：比较的是地址值是否相同</li></ul></li><li>字符串是对象，它比较内容是否相同，是通过一个方法来实现的，这个方法叫做: equals()</li><li>范例：</li></ul><pre><code>public class Demo&#123;  public static void main(String[] args)&#123;     //构造方法的方式得到对象     char[] chs = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;      String s1 = new String(chs);      String s2 = new String(chs);      //直接赋值的方法得到对象      String s3 = &quot;abc&quot;;     String s4 = &quot;abc&quot;;```    System.out.println(s1.equals(s2)); //true    System.out.println(s1.equals(s3)); //true    System.out.println(s3.equals(s4)); //true&#125;```&#125;</code></pre><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><ul><li>java.lang.StringBuilder字符串缓冲区 可变字符序列</li></ul><p>构造方法：</p><ul><li>StringBuilder()：构造一个空的StringBuilder容器。</li><li>StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><p>常用方法：</p><ul><li><p>StringBuilder append(…)：添加任意类型数据的字符串形式，并返回当前对象自身。</p></li><li><p>连锁编程：bu.append(“abc”).append(1).append(true).append(8.8).append(‘中’);</p></li><li><p>String toString()：将当前StringBuilder对象转换为String对象。</p></li><li></li><li><table><thead><tr><th>public int length()</th><th>返回长度(字符出现的个数)</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><p>StringBuilder和String可以相互转换：String-&gt;StringBuilder：StringBuilder&#x2F;&#x2F;StringBuilder-&gt;String：toString</p></li></ul><ol><li>JDK5.0后提供了StringBuilder，等价StringBuffer 。</li><li>区别：StringBuilder线程不安全，StringBuffer线程安全， StringBuilder类是单线程，不提供同步，理论上效率更高</li></ol><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //创建空白可改变字符串对象        StringBuilder sb = new StringBuilder();        System.out.println(&quot;sb:&quot;+sb); //sb:        System.out.println(&quot;sb.length():&quot;+sb.length()); //sb.length():0        //根据字符串内容创建对象        StringBuilder sb2 = new StringBuilder(&quot;hello&quot;);        System.out.println(&quot;sb2:&quot;+sb2); //sb2:hello        System.out.println(&quot;sb2.length():&quot;+sb2.length()); //5    &#125;&#125;</code></pre><pre><code>public class Demo &#123;    public static void main(String[] args) &#123;        //创建对象        StringBuilder sb = new StringBuilder();        //1.public StringBuilder append(任意类型) 添加数据，并返回对象本身//        StringBuilder sb2 = sb.append(&quot;java&quot;);//        System.out.println(&quot;sb:&quot;+sb); //sb:java，因为返回的是对象本身所以sb赋值了java//        System.out.println(&quot;sb2:&quot;+sb2); //sb2:java//        System.out.println(sb==sb2); //true//        sb.append(&quot;java&quot;);//        sb.append(&quot;word&quot;);//        sb.append(100);//        System.out.println(&quot;sb:&quot;+sb); //sb:javaword100        //链式编程        sb.append(&quot;java&quot;).append(&quot;word&quot;).append(100);        System.out.println(&quot;sb:&quot;+sb); //sb:javaword100        //2.public StringBuilder reverse() 返回相反的字符序列        sb.reverse();        System.out.println(&quot;sb:&quot;+sb); //sb:001drowavaj    &#125;&#125;</code></pre><h2 id="3-3-StringBuilder-和-String-相互转换"><a href="#3-3-StringBuilder-和-String-相互转换" class="headerlink" title="3.3 StringBuilder 和 String 相互转换"></a>3.3 StringBuilder 和 String 相互转换</h2><ol><li>StringBuilder 转换为 String</li></ol><pre><code>public String toString()通过toString()可以把StringBuilder 转换为 String</code></pre><ol><li>String 转换为 StringBuilder</li></ol><pre><code>public StringBuilder(String s)通过构造方法就可以把String 转换为 StringBuilder</code></pre><ul><li>范例</li></ul><pre><code>public class Demo &#123;    public static void main(String[] args) &#123;        //1.StringBulider 转换为 String        StringBuilder sb = new StringBuilder();        sb.append(&quot;hello&quot;);        //public String toString() 通过toString()可以把StringBuilder 转换为 String        String s = sb.toString();        System.out.println(&quot;s:&quot;+s); //s:hello            //2.String 转换为 StringBulider        String s1 = &quot;hello&quot;;        //public StringBuilder(String s) 通过构造方法就可以把String 转换为 StringBuilder        StringBuilder sb1 = new StringBuilder(s1);        System.out.println(&quot;sb1:&quot;+sb1); //sb1:hello    &#125;&#125;</code></pre><h1 id="4-集合结构体系"><a href="#4-集合结构体系" class="headerlink" title="4 集合结构体系"></a>4 集合结构体系</h1><p><img src="/2024/03/11/java%E5%B8%B8%E7%94%A8API/image-20240312193951531.png" alt="image-20240312193951531"></p><h1 id="4-集合基础"><a href="#4-集合基础" class="headerlink" title="4 集合基础"></a>4 集合基础</h1><ul><li><p>集合提供一种存储空间可变的存储模型，存储的数据容量可以改变</p></li><li><p>ArrayLis&lt;&gt;:</p><ul><li><p>可调整大小的数组实现</p></li><li><p>&lt;&gt;：是一种特殊的数据类型，泛型</p></li><li><p>可储存重复元素</p></li></ul></li><li><p>怎么使用呢</p><ul><li>在出现E的地方我们使用引用数据类型替换即可</li><li>举例：ArrayList<String>、ArrayList<Student></li></ul></li></ul><h2 id="4-1-集合与数组的区别"><a href="#4-1-集合与数组的区别" class="headerlink" title="4.1 集合与数组的区别"></a>4.1 集合与数组的区别</h2><ul><li>共同点:都是存储数据的容器</li><li>不同点：数组的容量是固定的，集合的容量是可变的</li></ul><h2 id="4-2-ArrayList-构造方法和添加方法"><a href="#4-2-ArrayList-构造方法和添加方法" class="headerlink" title="4.2 ArrayList 构造方法和添加方法"></a>4.2 ArrayList 构造方法和添加方法</h2><pre><code>import java.util.ArrayList;public class Demo &#123;    public static void main(String[] args) &#123;        //创建集合对象        ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();        System.out.println(array); //[]        //添加到集合末尾        array.add(&quot;hello&quot;);        array.add(&quot;word&quot;);        array.add(&quot;java&quot;);        System.out.println(array); //[hello, word, java]            //指定位置，添加元素        array.add(1,&quot;javase&quot;);        System.out.println(array); //[hello, javase, word, java]            array.add(4,&quot;javaee&quot;);        System.out.println(array); //[hello, javase, word, java, javaee]            array.add(6,&quot;javaweb&quot;);         System.out.println(array); //IndexOutOfBoundsException，不能中间跳一个位置    &#125;&#125;</code></pre><h2 id="4-3-ArrayList-常用方法"><a href="#4-3-ArrayList-常用方法" class="headerlink" title="4.3 ArrayList 常用方法"></a>4.3 ArrayList 常用方法</h2><p>方法名说明</p><ul><li>public boolean remove(Object o)删除指定的元素，返回删除是否成功</li><li>public E remove(int index)删除指定索引处的元素,返回被删除的元素</li><li>public E set(int index,E element)修改指定索引处的元素，返回被修改的元素</li><li>public E get(int index)返回指定索引处的元素</li><li>public int size()返回集合中元素的个数</li></ul><h3 id="范例："><a href="#范例：" class="headerlink" title="范例："></a>范例：</h3><pre><code>import java.util.ArrayList;public class Demo &#123;    public static void main(String[] args) &#123;        //创建集合对象        ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();        System.out.println(array); //[]        //添加到集合末尾        array.add(&quot;hello&quot;);        array.add(&quot;word&quot;);        array.add(&quot;java&quot;);        System.out.println(array); //[hello, word, java]            //1,public boolean remove(Object o) 删除指定的元素，返回删除是否成功//        System.out.println(array.remove(&quot;hello&quot;)); //true; 集合变为[word, java]//        System.out.println(array.remove(&quot;javase&quot;)); //false; 集合变为[hello, word, java]        //2,public E remove(int index) 删除指定索引处的元素,返回被删除的元素//        System.out.println(array.remove(1)); //word,集合变为[hello, java]        //3,public E set(int index,E element) 修改指定索引处的元素，返回被修改的元素//        System.out.println(array.set(1,&quot;javase&quot;)); //word;集合变为[hello, javase, java]        //4,public E get(int index) 返回指定索引处的元素//        System.out.println(array.get(0)); //hello//        System.out.println(array.get(1)); //word//        System.out.println(array.get(2)); //java        //5,public int size() 返回集合中元素的个数        System.out.println(array.size()); //3    &#125;&#125;</code></pre><h2 id="4-4-案例"><a href="#4-4-案例" class="headerlink" title="4.4 案例"></a>4.4 案例</h2><h3 id="4-4-1-案例1：存储字符串并遍历"><a href="#4-4-1-案例1：存储字符串并遍历" class="headerlink" title="4.4.1 案例1：存储字符串并遍历"></a>4.4.1 案例1：存储字符串并遍历</h3><pre><code>import java.util.ArrayList;public class Demo &#123;    public static void main(String[] args) &#123;        //创建集合对象        ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();        //加元素        array.add(&quot;java&quot;);        array.add(&quot;天下&quot;);        array.add(&quot;第一&quot;);            for(int i=0;i&lt;array.size();i++) &#123;            String s = array.get(i);            System.out.print(s+&quot; &quot;); //java 天下 第一        &#125;    &#125;&#125;</code></pre><h3 id="4-4-2-案例2：存储学生对象并遍历"><a href="#4-4-2-案例2：存储学生对象并遍历" class="headerlink" title="4.4.2 案例2：存储学生对象并遍历"></a>4.4.2 案例2：存储学生对象并遍历</h3><pre><code>Student类package ceshi;public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;        public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;        public int getAge() &#123;        return age;    &#125;        public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><pre><code>package ceshi;import java.util.ArrayList;public class ArrayListStudent &#123;    public static void main(String[] args) &#123;        //定义集合对象        ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;();        //创建学生对象        Student stu1 = new Student(&quot;小白&quot;,20);        Student stu2 = new Student(&quot;小明&quot;,21);        Student stu3 = new Student(&quot;小黑&quot;,22);            //添加学生对象到集合中        array.add(stu1);        array.add(stu2);        array.add(stu3);            //遍历集合        for(int i=0;i&lt;array.size();i++) &#123;            Student s = array.get(i);            System.out.println(s.getName()+&quot;,&quot;+s.getAge()); //小白,20                                                            //小明,21                                                            //小黑,22        &#125;    &#125;&#125;</code></pre><h1 id="5-Collection集合"><a href="#5-Collection集合" class="headerlink" title="5 Collection集合"></a>5 Collection集合</h1><h2 id="5-1-Collection集合概述"><a href="#5-1-Collection集合概述" class="headerlink" title="5.1 Collection集合概述"></a>5.1 Collection集合概述</h2><ul><li>是单列集合的顶层接口，它表示一组对象，这些对象也称Collection元素</li><li>JDK不提供此接口的直接实现，它提供更具体的子接口（Set 和 List）实现</li></ul><pre><code>package ceshi;import java.util.AbstractCollection;import java.util.ArrayList;import java.util.Collection;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        //创建Collection集合对象        Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();```    //添加元素    c.add(&quot;hello&quot;);    c.add(&quot;world&quot;);    c.add(&quot;java&quot;);    System.out.println(c); //[hello, world, java]&#125;```&#125;</code></pre><h2 id="5-2-Collection集合常用方法（查看所有源码快捷键）"><a href="#5-2-Collection集合常用方法（查看所有源码快捷键）" class="headerlink" title="5.2 Collection集合常用方法（查看所有源码快捷键）"></a>5.2 Collection集合常用方法（查看所有源码快捷键）</h2><pre><code>方法名说明public boolean add(E e)把给定的元素添加到当前集合中public boolean remove(E e)把给定的对象在当前集合中删除public void clear()清空集合中所有的元素public boolean contains(Object obj) [kənˈteɪnz] 包括判断当前集合中是否存在指定的对象public boolean isEmpty() [ˈenpti]判断当前集合是否为空public int size()返回集合中元素的个数public Object[] toArray( )把集合中的元素，储存到数组中</code></pre><ul><li>快捷键：Alt+7 打开源码中所有方法</li></ul><pre><code>package ceshi;import java.util.AbstractCollection;import java.util.ArrayList;import java.util.Collection;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        //创建Collection集合对象        Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();        //1、public boolean add(E e) 把给定的元素添加到当前集合中        c.add(&quot;hello&quot;);        c.add(&quot;hello&quot;);        System.out.println(c); //[hello, hello] ;ArrayList可以存储重复元素            //2、public boolean remove(E e) 把给定的对象在当前集合中删除        /*System.out.println(c.remove(&quot;hello&quot;)); //true        System.out.println(c.remove(&quot;java&quot;)); //false        System.out.println(c); //[hello]*/            //3、public void clear() 清空集合中所有的元素        /*c.clear();        System.out.println(c); //[]*/            //4、public boolean contains(Object obj) 判断当前集合中是否存在指定的对象        /*System.out.println(c.contains(&quot;java&quot;)); //false        System.out.println(c.contains(&quot;hello&quot;)); //true*/            //5、public boolean isEmpty() 判断当前集合是否为空//        System.out.println(c.isEmpty()); //false        //6、public int size() 返回集合中元素的个数//        System.out.println(c.size()); //2        //7、public Object[] toArray( 把集合中的元素，储存到数组中        Object[] arr = c.toArray();        for(int i= 0;i&lt; arr.length;i++) &#123;            System.out.print(arr[i]+&quot;,&quot;); //hello,hello        &#125;            &#125;&#125;</code></pre><h2 id="5-3-Collection集合的遍历"><a href="#5-3-Collection集合的遍历" class="headerlink" title="5.3 Collection集合的遍历"></a>5.3 Collection集合的遍历</h2><p>Collection 集合遍历有三种方法：</p><ul><li>迭代器</li><li>foreach(增强for循环)</li><li>DK 1.8 开始的新技术 Lambda 表达式(了解)</li></ul><h3 id="5-3-1-Iterator-‘lɪtəreɪtə-迭代器遍历集合"><a href="#5-3-1-Iterator-‘lɪtəreɪtə-迭代器遍历集合" class="headerlink" title="5.3.1 Iterator[‘lɪtəreɪtə]迭代器遍历集合"></a>5.3.1 Iterator[‘lɪtəreɪtə]迭代器遍历集合</h3><ul><li>lterator:迭代器，集合的专用遍历方式</li><li>Iterator<E> iterator():返回此集合中元素的迭代器，通过集合的iterator()方法得到</li><li>迭代器是通过集合的**iterator()**方法得到的，所以我们说它是依赖于集合而存在的</li></ul><h4 id="Iterator中的常用方法"><a href="#Iterator中的常用方法" class="headerlink" title="Iterator中的常用方法"></a>Iterator中的常用方法</h4><pre><code>方法名说明E next()获取迭代中的下一个元素boolean hasNext()如果迭代具有更多元素，则返回true</code></pre><pre><code>package ceshi;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class IteratorDemo &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt;  c = new ArrayList&lt;String&gt;();        c.add(&quot;java&quot;);        c.add(&quot;天下&quot;);        c.add(&quot;无敌&quot;);            //Iterator&lt;E&gt; iterator():返回此集合中元素的迭代器，通过集合的iterator0方法得到        Iterator&lt;String&gt; it = c.iterator(); //c.iterator();按下Ctrl+alt+v        /*public Iterator&lt;E&gt; iterator() &#123;            return new ArrayList.Itr(); //返回的是实现类的对象        &#125;            private class Itr implements Iterator&lt;E&gt; &#123;...&#125;        */            //E next()        /*System.out.println(it.next()); //java        System.out.println(it.next());        System.out.println(it.next());        System.out.println(it.next()); //NoSuchElementException：表示请求的元素不存在*/            //boolean hasNext() 如果迭代具有更多元素，则返回true        /*if(it.hasNext()) &#123;            System.out.println(it.next()); //java        &#125;        if(it.hasNext()) &#123;            System.out.println(it.next()); //天下        &#125;        if(it.hasNext()) &#123;            System.out.println(it.next()); //无敌        &#125;        if(it.hasNext()) &#123;            System.out.println(it.next()); //无输出        &#125; */            //while循环改良        while(it.hasNext()) &#123;            String s = it.next();            System.out.println(s);  //java                                    //天下                                    //无敌        &#125;    &#125;&#125;</code></pre><p>案例</p><pre><code>package ceshi;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        //2、创建Collection集合对象        Collection&lt;Student&gt; c = new ArrayList&lt;Student&gt;();        //3、创建学生对象        Student s1 = new Student(&quot;y1&quot;, 10);        Student s2 = new Student(&quot;y2&quot;, 20);        Student s3 = new Student(&quot;y3&quot;, 30);            //4、把学生添加到集合        c.add(s1);        c.add(s2);        c.add(s3);            //5、遍历集合        Iterator&lt;Student&gt; it = c.iterator(); //必须集合添加完毕后创建迭代器对象        while (it.hasNext()) &#123;            Student s = it.next();            System.out.println(s.getName() + &quot;,&quot; + s.getAge());            /*            y1,10            y2,20            y3,30            */        &#125;    &#125;&#125;</code></pre><h2 id="5-4-Collections工具类"><a href="#5-4-Collections工具类" class="headerlink" title="5.4 Collections工具类"></a>5.4 Collections工具类</h2><ul><li>包：java.util.Collections</li><li>Collections 并不属于集合，而是用来操作集合的工具类</li></ul><p>常用方法（全是静态修饰，用类名调用）<br>方法名说明</p><ul><li>public static &lt;T extends Comparable&lt;?super T&gt;&gt; void sort(List list)将指定的列表按升序排序</li><li>public static void reverse(List&lt;?&gt; list)反转指定列表中元素顺序</li><li>public static void shuffle(List&lt;?&gt; list)使用默认的随机源随机排序指定的列表</li></ul><pre><code>package ceshi;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class MapDemo &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();```    list.add(30);    list.add(20);    list.add(50);    list.add(10);    list.add(40);    System.out.println(list); //[30, 20, 50, 10, 40]    //1,public static &lt;T extends Comparable&lt;?super T&gt;&gt; void sort(List list) 将指定的列表按升序排序    /*Collections.sort(list);    System.out.println(list); //[10, 20, 30, 40, 50]*/    //2,public static void reverse(List&lt;?&gt; list) 反转指定列表中元素顺序    /*Collections.reverse(list);    System.out.println(list); //[40, 10, 50, 20, 30]*/    //3,public static void shuffle(List&lt;?&gt; list) 使用默认的随机源随机排序指定的列表    Collections.shuffle(list);    System.out.println(list);    //第一次运行[10, 40, 30, 50, 20]    //第二次运行[10, 30, 20, 50, 40]&#125;```&#125;</code></pre><h1 id="6-List集合"><a href="#6-List集合" class="headerlink" title="6 List集合"></a>6 List集合</h1><ul><li>List系列集合：添加的元素是有序，可重复，有索引</li><li>ArrayList: 添加的元素是有序，可重复，有索引</li><li>LinkedList: 添加的元素是有序，可重复，有索引</li><li>Vector ：是线程安全的，速度慢，开发中很少使用</li></ul><h2 id="6-1-List集合概述和特点"><a href="#6-1-List集合概述和特点" class="headerlink" title="6.1 List集合概述和特点"></a>6.1 List集合概述和特点</h2><p>List集合概述</p><ol><li>有序集合(也称为序列)，用户可以精确控制列表中每个元索的插入位置。用户可以通过整数索引访问元素,并获取列表中的元素</li><li>与Set集合不同，List集合允许重复的元素</li></ol><p>List集合特点</p><ol><li>有序: 存储和取出的元素顺序一致</li><li>可重复: 存储的元素可以重复</li></ol><pre><code>package ceshi;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        List&lt;String&gt; list = new ArrayList&lt;&gt;();        //添加元素        list.add(&quot;java&quot;);        list.add(&quot;天下&quot;);        list.add(&quot;无敌&quot;);        list.add(&quot;java&quot;);            System.out.println(list); //[java, 天下, 无敌, java]            //迭代器遍历        Iterator&lt;String&gt; it = list.iterator();        while(it.hasNext()) &#123;            String s = it.next();            System.out.println(s);            /*java            天下            无敌            java*/        &#125;    &#125;&#125;</code></pre><h2 id="6-2-List集合的特有方法"><a href="#6-2-List集合的特有方法" class="headerlink" title="6.2 List集合的特有方法"></a>6.2 List集合的特有方法</h2><p>方法名说明</p><ul><li>public void add(int index,E element)该集合中的指定位置上插入元素</li><li>public E remove(int index)删除列表中指定位置的元素，返回被删除的元素</li><li>public E set(int index,E element)修改指定索引的元素，返回被修改的元素</li><li>public E get(int index)返回集合中指定位置的元素</li></ul><pre><code>package ceshi;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        List&lt;String&gt; list = new ArrayList&lt;&gt;();        //添加元素        list.add(&quot;java&quot;);        list.add(&quot;天下&quot;);        list.add(&quot;无敌&quot;);        list.add(&quot;java&quot;);        System.out.println(list); //[java, 天下, 无敌, java]            //1、public void add(int index,E element) 该集合中的指定位置上插入元素        list.add(1,&quot;javase&quot;);        System.out.println(list); //[java, javase, 天下, 无敌, java]            //2、public E remove(int index) 删除列表中指定位置的元素，返回被删除的元素        System.out.println(list.remove(1)); //javase        System.out.println(list); //[java, 天下, 无敌, java]            //3、public E set(int index,E element) 修改指定索引的元素，返回被修改的元素        System.out.println(list.set(0,&quot;java1&quot;)); //java        System.out.println(list); //[java1, 天下, 无敌, java]            //4、public E get(int index) 返回集合中指定位置的元素        System.out.println(list.get(2)); //无敌            //for循环遍历        for(int i=0;i&lt; list.size();i++) &#123;            //5,public E get(int index)返回集合中指定位置的元素            String s = list.get(i);            System.out.println(s);            /*java1            天下            无敌            java*/        &#125;    &#125;&#125;</code></pre><p>案例</p><p>测试类</p><pre><code>package ceshi;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListDemo &#123;    public static void main(String[] args) &#123;        //2、创建集合对象        List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        //3、创建学生对象        Student s1 = new Student(&quot;y1&quot;,10);        Student s2 = new Student(&quot;y2&quot;,20);        Student s3 = new Student(&quot;y3&quot;,30);        //4、学生对象添加到集合        list.add(s1);        list.add(s2);        list.add(s3);```    //5、遍历集合：迭代器方法    Iterator&lt;Student&gt; it = list.iterator();    while(it.hasNext()) &#123;        Student s = it.next();        System.out.println(s.getName()+&quot;,&quot;+s.getAge());        /*y1,10        y2,20        y3,30*/    &#125;    //5、遍历集合：for循环    for(int i=0;i&lt;list.size();i++) &#123;        Student ss = list.get(i);        System.out.println(ss.getName()+&quot;,&quot;+ss.getAge());        /*y1,10        y2,20        y3,30*/    &#125;&#125;```&#125;</code></pre><h2 id="6-3-ListIterator迭代器"><a href="#6-3-ListIterator迭代器" class="headerlink" title="6.3 ListIterator迭代器"></a>6.3 ListIterator迭代器</h2><p>Lstlterator:列表迭代器</p><ul><li>通过List集合的listterator()方法得到，所以说它是List集合特有的迭代器</li><li>用于允许程序员沿任一方向遍历列表的列表迭代器,在迭代期间修改列表,并获取列表中迭代器的当前位置</li></ul><p>常用方法</p><ul><li>list.listIterator()得到 listIterator 迭代器</li><li>E next()返回迭代中的下一个元素</li><li>boolean hasNext()如果迭代具有更多元素，则返回true</li><li>E previous() [ˈpriːviəs]返回列表中的上一个元素</li><li>boolean hasPrevious()如果此列表迭代器在相反方向遍历列表时具有更多元索，则返回true</li><li>void add(E e)将指定的元索插入列表</li></ul><pre><code>package ceshi;import java.util.ArrayList;import java.util.List;import java.util.ListIterator;public class ListIteratorDemo &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;java&quot;);        list.add(&quot;python&quot;);        list.add(&quot;scala&quot;);            //通过list集合的listIterator() 方法得到迭代器        /*ListIterator&lt;String&gt; lit = list.listIterator();        while(lit.hasNext()) &#123;            String s = lit.next();            System.out.println(s);            *//*java            python            scala*//*        &#125;        System.out.println(&quot;---------&quot;);            //逆向遍历        *//*E previous0 返回列表中的上一个元素        boolean hasPrevious() 如果此列表迭代器在相反方向遍历列表时具有更多元索，则返回true*//*        while(lit.hasPrevious()) &#123;            String s = lit.previous();            System.out.println(s);            *//*scala            python            java*//*        &#125;*/            //获取列表迭代器        ListIterator&lt;String&gt; lit = list.listIterator();        while(lit.hasNext()) &#123;            String s = lit.next();            if(s.equals(&quot;java&quot;)) &#123;                lit.add(&quot;world&quot;);            &#125;        &#125;        System.out.println(list); //[java, world, python, scala]    &#125;&#125;</code></pre><h2 id="6-4-foreach（增强for循环）"><a href="#6-4-foreach（增强for循环）" class="headerlink" title="6.4 foreach（增强for循环）"></a>6.4 foreach（增强for循环）</h2><p>增强for：简化数组和Collection集合的遍历</p><p>实现Iterable接口的类允许其对象成为增强型 for语句的目标<br>它是JDK5之后出现的，其内部原理是一个Iterator迭代器<br>格式</p><pre><code>for(元素类型  变量名: 数组名或collection集合)&#123;     &#125;</code></pre><pre><code>//范例int[] arr = &#123;1,2,3,4,5&#125;;for(int i : arr) &#123;    System.out.println(i);&#125;</code></pre><p>范例：</p><pre><code>package ceshi;import java.util.ArrayList;import java.util.List;public class ForDemo &#123;    public static void main(String[] args) &#123;        //int类型数组        int[] arr = &#123;1,2,3,4,5&#125;;        for(int i : arr) &#123;            System.out.println(i);            /*            1            2            3            4            5*/        &#125;        //String类型数组        String[] strArray = &#123;&quot;java&quot;,&quot;python&quot;,&quot;scala&quot;&#125;;        for(String s : strArray) &#123;            System.out.println(s);            /*java            python            scala*/        &#125;</code></pre><pre><code>    //集合    List&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;y1&quot;);    list.add(&quot;y2&quot;);    list.add(&quot;y3&quot;);    for(String lt:list) &#123;        System.out.println(lt);        /*y1        y2        y3*/    &#125;    //判断：内部原理是一个Iterator迭代器    for(String s:list) &#123;        if(s.equals(&quot;y1&quot;)) &#123;            list.add(&quot;y4&quot;); //ConcurrentModificationException:并发修改异常        &#125;    &#125;&#125;</code></pre><p>}</p><h2 id="6-5-案例：List集合存储学生对象用三种方式遍历"><a href="#6-5-案例：List集合存储学生对象用三种方式遍历" class="headerlink" title="6.5 案例：List集合存储学生对象用三种方式遍历"></a>6.5 案例：List集合存储学生对象用三种方式遍历</h2><p>测试类</p><pre><code>package ceshi;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListDemo &#123;    public static void main(String[] args) &#123;        List&lt;Student&gt; list = new ArrayList&lt;&gt;();        Student s1 = new Student(&quot;y1&quot;,10);        Student s2 = new Student(&quot;y2&quot;,20);        Student s3 = new Student(&quot;y3&quot;,30);            list.add(s1);        list.add(s2);        list.add(s3);            //迭代器方式        Iterator&lt;Student&gt; it = list.iterator();        while(it.hasNext()) &#123;            Student s = it.next();            System.out.println(s.getName()+&quot;,&quot;+s.getAge());        &#125;        System.out.println(&quot;----------&quot;);        //for带索引方式        for(int i =0;i&lt;list.size();i++) &#123;            Student s = list.get(i);            System.out.println(s.getName()+&quot;,&quot;+s.getAge());        &#125;        System.out.println(&quot;----------&quot;);            //增强for        for(Student s: list) &#123;            System.out.println(s.getName()+&quot;,&quot;+s.getAge());        &#125;    &#125;&#125;</code></pre><h2 id="6-6-List集合子类特点"><a href="#6-6-List集合子类特点" class="headerlink" title="6.6 List集合子类特点"></a>6.6 List集合子类特点</h2><ul><li>ArrayList：底层数据结构数组实现，查询快，增删慢</li><li>LinkedList：底层数据结构链表实现，查询慢，增删快</li></ul><p>范例：分别用ArrayList和LinkedList存储字符串并遍历</p><pre><code>package ceshi;import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.List;public class ListDemo &#123;    public static void main(String[] args) &#123;        //1、创建ArrayList集合对象        ArrayList&lt;String&gt; arraylist = new ArrayList&lt;&gt;();        arraylist.add(&quot;java&quot;);        arraylist.add(&quot;python&quot;);        arraylist.add(&quot;scala&quot;);        //增强for        for(String s: arraylist) &#123;            System.out.println(s);        &#125;        System.out.println(&quot;-------&quot;);        //普通for循环        for(int i=0;i&lt; arraylist.size();i++) &#123;            String s = arraylist.get(i);            System.out.println(s);        &#125;        System.out.println(&quot;-------&quot;);        //迭代器的方式        Iterator&lt;String&gt; it = arraylist.iterator();        while(it.hasNext()) &#123;            String s = it.next();            System.out.println(s);        &#125;        System.out.println(&quot;-------&quot;);        //2、创建LinkedList集合对象        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add(&quot;a&quot;);        linkedList.add(&quot;b&quot;);        linkedList.add(&quot;c&quot;);        //增强for        for(String s:linkedList) &#123;            System.out.println(s);        &#125;        System.out.println(&quot;-------&quot;);        //普通for        for(int i=0;i&lt; linkedList.size();i++) &#123;            String s = linkedList.get(i);            System.out.println(s);        &#125;        System.out.println(&quot;-------&quot;);        //迭代器        Iterator&lt;String&gt; it1 = linkedList.iterator();        while(it1.hasNext()) &#123;            String s = it1.next();            System.out.println(s);        &#125;    &#125;&#125;</code></pre><h2 id="6-7-LinkedList集合特有方法"><a href="#6-7-LinkedList集合特有方法" class="headerlink" title="6.7 LinkedList集合特有方法"></a>6.7 LinkedList集合特有方法</h2><p>方法名说明</p><ul><li>public void addFirst(E,e)在该列表开头插入指定的元素</li><li>public void addLast(E,e)将指定的元索追加到此列表的末尾</li><li>public E getFirst()返回此列表中的第一个元索</li><li>public E getLast()返回此列表中的最后一个元素</li><li>public E removeFirst从此列表中删除并返回第一个元素</li><li>public E removeLast从此列表中删除并返回最后一个元素</li></ul><pre><code>package ceshi;import java.util.LinkedList;public class LinkedListDemo &#123;    public static void main(String[] args) &#123;        //创建集合对象        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add(&quot;java&quot;);        linkedList.add(&quot;python&quot;);        linkedList.add(&quot;scala&quot;);        System.out.println(linkedList); //[java, python, scala]        //1、public void addFirst(E,e) 在该列表开头插入指定的元素        linkedList.addFirst(&quot;1&quot;);        System.out.println(linkedList); //[1, java, python, scala]            //2、public void addLast(E,e) 将指定的元索追加到此列表的末尾        linkedList.addLast(&quot;5&quot;);        System.out.println(linkedList); //[1, java, python, scala, 5]            //3、public E getFirst() 返回此列表中的第一个元索        System.out.println(linkedList.getFirst()); //1            //4、public E getLast() 返回此列表中的最后一个元素        System.out.println(linkedList.getLast()); //5            //5、public E removeFirst 从此列表中删除并返回第一个元素        System.out.println(linkedList.removeFirst()); //1        System.out.println(linkedList);//[java, python, scala, 5]            //6、public E removeLast 从此列表中删除并返回最后一个元素        System.out.println(linkedList.removeLast()); //5        System.out.println(linkedList); //[java, python, scala]    &#125;&#125;</code></pre><h1 id="7-Set集合"><a href="#7-Set集合" class="headerlink" title="7 Set集合"></a>7 Set集合</h1><h2 id="7-1-Set集合的概述和特点"><a href="#7-1-Set集合的概述和特点" class="headerlink" title="7.1 Set集合的概述和特点"></a>7.1 Set集合的概述和特点</h2><p>Set集合的特点</p><ul><li>不包含重复元素的集合</li><li>没有带索引的方法，所以不能使用普通for循环</li><li>Set集合是接口通过实现类实例化（多态的形式）</li><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet: 添加的元素是有序，不重复，无索引的</li><li>TreeSet: 不重复，无索引，按照大小默认升序排列</li></ul><pre><code>package ceshi;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class SetDemo &#123;    public static void main(String[] args) &#123;        //创建Set集合对象        Set&lt;String&gt; set = new HashSet&lt;&gt;();        //添加元素        set.add(&quot;java&quot;);        set.add(&quot;python&quot;);        set.add(&quot;scala&quot;);        //不包含重复元素        set.add(&quot;java&quot;);            //两种遍历方式        for(String s:set) &#123;            System.out.println(s);            /*python            java            scala*/        &#125;        System.out.println(&quot;--------&quot;);            Iterator&lt;String&gt; it = set.iterator();        while(it.hasNext()) &#123;            String s = it.next();            System.out.println(s);            /*python            java            scala*/        &#125;    &#125;&#125;</code></pre><h2 id="7-2-哈希值"><a href="#7-2-哈希值" class="headerlink" title="7.2 哈希值"></a>7.2 哈希值</h2><ul><li>哈希值：是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</li><li>Object类中有一个方法可以获取对象的哈希值</li><li>public int hashCode()：返回对象的哈希码值</li></ul><p>对象的哈希值特点</p><pre><code>同一个对象多次调用hashCode()方法返回的哈希值是相同的默认情况下，不同对象的哈希值是不同的。而重写hashCode0方法，可以实现让不同对象的哈希值相同</code></pre><pre><code>package ceshi;public class HashDemo &#123;    public static void main(String[] args) &#123;        //创建学生对象        Student s1 = new Student(&quot;y1&quot;,10);        //同一个对象多次调用hashCode()方法哈希值相同        System.out.println(s1.hashCode()); //460141958        System.out.println(s1.hashCode()); //460141958        System.out.println(&quot;---------&quot;);            //默认情况下，不同对象哈希值不同；重写hashCode()方法就可以使哈希值相同        Student s2 = new Student(&quot;y2&quot;,20);        System.out.println(s2.hashCode()); //1163157884        System.out.println(&quot;---------&quot;);            System.out.println(&quot;java&quot;.hashCode()); //3254818        System.out.println(&quot;python&quot;.hashCode()); //-973197092        System.out.println(&quot;scala&quot;.hashCode()); //109250886        System.out.println(&quot;---------&quot;);            System.out.println(&quot;无&quot;.hashCode()); //26080        System.out.println(&quot;敌&quot;.hashCode()); //25932    &#125;&#125;</code></pre><h2 id="7-3-数据结构之哈希表"><a href="#7-3-数据结构之哈希表" class="headerlink" title="7.3 数据结构之哈希表"></a>7.3 数据结构之哈希表</h2><pre><code>JDK8之前，底层采用数组+链表实现，可以说是一个元索为链表的数组（哈希表 = 数组 + 链表 + （哈希算法））JDK8以后，在长度比较长的时候，底层实现了优化（哈希表 = 数组 + 链表 + 红黑树 + （哈希算法））当链表长度超过 8 时，将链表转换为红黑树，这样大大减少了查找时间</code></pre><h2 id="7-4-HashSet集合概述和特点"><a href="#7-4-HashSet集合概述和特点" class="headerlink" title="7.4 HashSet集合概述和特点"></a>7.4 HashSet集合概述和特点</h2><p>HashSet集合特点</p><ul><li>底层数据结构是哈希表</li><li>对集合的迭代顺序不作任何保证 ,也就是说不保证存储和取出的元素顺序一致</li><li>没有带索引的方法，所以不能使用普通for循环遍历</li><li>由于是Set集合, 所以是不包含重复元素的集合</li></ul><pre><code>package ceshi;import java.util.HashSet;public class HashSetDemo &#123;    public static void main(String[] args) &#123;        HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();        hs.add(&quot;java&quot;);        hs.add(&quot;python&quot;);        hs.add(&quot;scala&quot;);            hs.add(&quot;scala&quot;);            for(String s:hs) &#123;            System.out.println(s);            /*python            java            scala*/        &#125;        &#125;&#125;</code></pre><h2 id="7-5-HashSet集合保证元素唯一性源码分析（重点面试常考）"><a href="#7-5-HashSet集合保证元素唯一性源码分析（重点面试常考）" class="headerlink" title="7.5 HashSet集合保证元素唯一性源码分析（重点面试常考）"></a>7.5 HashSet集合保证元素唯一性源码分析（重点面试常考）</h2><pre><code>HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();​    hs.add(&quot;java&quot;);​    hs.add(&quot;python&quot;);​    hs.add(&quot;scala&quot;);​    hs.add(&quot;scala&quot;);​    for(String s:hs) &#123;​        System.out.println(s);​        /*python​        java​        scala*/​    &#125;</code></pre><hr><pre><code>public boolean add(E e) &#123;   return map.put(e, PRESENT)==null;&#125;static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true); //上个方法的返回的值是hash（key）的值&#125;//hash值和元素的hashCode()方法final V putVal(int hash, K key, V value, boolean onlyIfAbsent,              boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    //如果哈希表未初始化就对其初始化    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    //根据对象的哈希值计算对象的存储位置，    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null); //如果该位置没有元素，就存储新元素    //有元素就走else    else &#123;        Node&lt;K,V&gt; e; K k;        //存入的元素和以前的元素比哈希值        if (p.hash == hash &amp;&amp;             //二、如果哈希值相同，调用对象的equals()比较内容是否相同            //1、如果内容不同equals()返回false,就走一把元素添加到集合            //2、如果内容相同返回true，说明元素重复，走e = p;不存储            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        //一、如果哈希值不同，就走else存储元素到集合        else &#123;            for (int binCount = 0; ; ++binCount) &#123;                if ((e = p.next) == null) &#123;                    p.next = newNode(hash, key, value, null); //新元素添加到集合                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                &#125;                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            &#125;        &#125;        if (e != null) &#123; // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        &#125;    &#125;    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;&#125;</code></pre><p>HashSet集合存储元素：要保证元素唯一性需要重写hashCode()和equals()方法</p><p>案例</p><pre><code>Student类package ceshi;public class Student &#123;    private String name;    private int age;```public Student() &#123;&#125;public Student(String name, int age) &#123;    this.name = name;    this.age = age;&#125;public String getName() &#123;    return name;&#125;public void setName(String name) &#123;    this.name = name;&#125;public int getAge() &#123;    return age;&#125;public void setAge(int age) &#123;    this.age = age;&#125;//重写快捷键：Fn+Alt+insert，选择equals() and hashCode()@Overridepublic boolean equals(Object o) &#123;    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    Student student = (Student) o;    if (age != student.age) return false;    return name != null ? name.equals(student.name) : student.name == null;&#125;@Overridepublic int hashCode() &#123;    int result = name != null ? name.hashCode() : 0;    result = 31 * result + age;    return result;&#125;```&#125;</code></pre><p>测试类</p><pre><code>package ceshi;import java.util.HashSet;public class HashSetDemo &#123;    public static void main(String[] args) &#123;        HashSet&lt;Student&gt; hs = new HashSet&lt;&gt;();        Student s1 = new Student(&quot;y1&quot;,10);        Student s2 = new Student(&quot;y2&quot;,20);        Student s3 = new Student(&quot;y3&quot;,30);        Student s4 = new Student(&quot;y3&quot;,30);            hs.add(s1);        hs.add(s2);        hs.add(s3);        hs.add(s4);            for(Student s: hs) &#123;            System.out.println(s.getName()+&quot;,&quot;+s.getAge());            /*y3,30            y2,20            y1,10            y3,30；s4内容和s3重复并存入了，需要重写hashCode()和equals()            */                //重写后            /*            y1,10            y3,30            y2,20*/        &#125;    &#125;&#125;</code></pre><h2 id="7-6-LinkedHashSet集合概述和特点"><a href="#7-6-LinkedHashSet集合概述和特点" class="headerlink" title="7.6 LinkedHashSet集合概述和特点"></a>7.6 LinkedHashSet集合概述和特点</h2><p>LinkedHashSet集合特点</p><ul><li>哈希表和链表实现的Set接口， 具有可预测的迭代次序</li><li>由链表保证元素有序, 也就是说元索的存储和取出顺序是一致的</li><li>由哈希表保证元索唯一， 也就是说没有重复的元素</li></ul><pre><code>package ceshi;import java.util.LinkedHashSet;public class LinkedHashSetDemo &#123;    public static void main(String[] args) &#123;        LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();        linkedHashSet.add(&quot;java&quot;);        linkedHashSet.add(&quot;python&quot;);        linkedHashSet.add(&quot;scala&quot;);        linkedHashSet.add(&quot;scala&quot;);            for(String s:linkedHashSet) &#123;            System.out.println(s);            /*java            python            scala*/        &#125;    &#125;&#125;</code></pre><h2 id="7-7-TreeSet集合概述和特点"><a href="#7-7-TreeSet集合概述和特点" class="headerlink" title="7.7 TreeSet集合概述和特点"></a>7.7 TreeSet集合概述和特点</h2><p>TreeSet集合特点</p><ol><li><p>元素有序, 这里的顺序不是指存储和取出的顺序,而是按照一定的规则进行排序，具体排序方式取决于构造方法</p></li><li><p>TreeSet()：根据其元素的自然排序进行排序</p></li><li><p>TreeSet(Comparator comparator)：根据指定的比较器进行排序</p></li><li><p>没有带索引的方法，所以不能使用普通for循环遍历</p></li><li><p>由于是Set集合，所以不包含重复元素的集合</p></li></ol><pre><code>package ceshi;import java.util.TreeSet;public class TreeSetDemo &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();```    //jdk5以后添加元素自动装箱int》integer    ts.add(10);    ts.add(40);    ts.add(30);    ts.add(50);    ts.add(20);    ts.add(30);    for(Integer i:ts) &#123;        System.out.println(i);        /*        10        20        30        40        50*/    &#125;&#125;```&#125;</code></pre><h2 id="7-8-自然排序Comarable的使用"><a href="#7-8-自然排序Comarable的使用" class="headerlink" title="7.8 自然排序Comarable的使用"></a>7.8 自然排序Comarable的使用</h2><p>存储学生对象并遍历，创建TreeSet集合使用无参构造方法</p><p>要求:按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</p><p>结论：</p><p>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的<br>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法<br>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写<br>Student类</p><pre><code>package ceshi;public class Student implements Comparable&lt;Student&gt;&#123; //实现接口    private String name;    private int age;    public Student() &#123;    &#125;        public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;        public int getAge() &#123;        return age;    &#125;        public void setAge(int age) &#123;        this.age = age;    &#125;        @Override    public int compareTo(Student s) &#123;//        return 0; //返回0说明元素是重复的，只能存一个元素//        return 1; //整数是升序排序//        return -1; //负数是倒叙排序        //按照年龄排序        int num = this.age-s.age; //this是s2,s是s1        //年龄相同时，按照名字字母排序        int num2 = num==0 ? this.name.compareTo(s.name):num;        return num2;    &#125;&#125;</code></pre><p>测试</p><pre><code>package ceshi;import java.util.TreeSet;public class TreeSetDemo &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;();        Student s1 = new Student(&quot;y1&quot;,10);        Student s2 = new Student(&quot;y3&quot;,30);        Student s3 = new Student(&quot;y2&quot;,20);        Student s4 = new Student(&quot;y4&quot;,40);            Student s5 = new Student(&quot;a4&quot;,40); //判断按字母排序            Student s6 = new Student(&quot;y4&quot;,40); //判断会存储重复值吗            ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);        ts.add(s5);        ts.add(s6);            for(Student s:ts) &#123;            System.out.println(s.getName()+&quot;,&quot;+s.getAge());            /*y1,10            y2,20            y3,30            a4,40            y4,40*/        &#125;    &#125;&#125;</code></pre><h2 id="7-9-比较器排序Comparator-kəmˈpɜrətər-的使用"><a href="#7-9-比较器排序Comparator-kəmˈpɜrətər-的使用" class="headerlink" title="7.9 比较器排序Comparator[kəmˈpɜrətər]的使用"></a>7.9 比较器排序Comparator[kəmˈpɜrətər]的使用</h2><p>存储学生对象并遍历，创建TreeSet集合使用带参构造方法<br>要求:按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序<br>结论<br>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元索进行排序的<br>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(To1,T o2)方法<br>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p><pre><code>package ceshi;public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;        public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;        public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;        public int getAge() &#123;        return age;    &#125;        public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><p>测试</p><pre><code>package ceshi;import java.util.Comparator;import java.util.TreeSet;public class TreeSetDemo &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student s1, Student s2) &#123;                int num = s1.getAge() - s2.getAge();                int num2 = num==0? s1.getName().compareTo(s2.getName()):num;                return num2;            &#125;        &#125;);        Student s1 = new Student(&quot;y2&quot;,20);        Student s2 = new Student(&quot;y1&quot;,10);        Student s3 = new Student(&quot;y3&quot;,30);        Student s4 = new Student(&quot;y4&quot;,40);            ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);            for(Student s:ts) &#123;            System.out.println(s.getName()+&quot;,&quot;+s.getAge());        &#125;    &#125;&#125;</code></pre><p>7.10 案例：不重复随机数</p><pre><code>package ceshi;import java.util.HashSet;import java.util.Random;import java.util.Set;import java.util.TreeSet;public class SetDemo &#123;    public static void main(String[] args) &#123;//        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();        Random r = new Random();        //判断集合是否《10        while(set.size()&lt;10) &#123;            int number = r.nextInt(20)+1;            set.add(number); //把随机数添加到集合        &#125;            for (Integer i:set) &#123;            System.out.print(i+&quot; &quot;); //1(哈希set集合）：16 17 2 20 8 9 10 11 14 15            //2（TreeSet集合)：1 3 4 5 6 7 8 10 16 19         &#125;    &#125;&#125;</code></pre><h1 id="8-Map集合"><a href="#8-Map集合" class="headerlink" title="8 Map集合"></a>8 Map集合</h1><ol><li>HashMap: 元素按照键是无序，不重复，无索引，值不做要求</li><li>LinkedHashMap: 元素按照键是有序，不重复，无索引，值不做要求</li></ol><h2 id="8-1-Map集合概述和特点"><a href="#8-1-Map集合概述和特点" class="headerlink" title="8.1 Map集合概述和特点"></a>8.1 Map集合概述和特点</h2><ul><li>Map集合是一种双列集合，每个元素包含两个值</li><li>Interface Map&lt;K,V&gt;； K：键的类型，V：值的类型</li><li>Map集合的每个元素的格式：key &#x3D; value(键值对元素)</li><li>Map集合也被称为“键值对集合”</li><li>Map集合特点：</li><li>Map 集合的键是无序，不重复，无索引的</li><li>Map 集合后面重复的键对应的元素会覆盖前面的整个元素</li></ul><p>创建Map集合对象：<br>多态的方式<br>具体的实现类HashMap</p><pre><code>package ceshi;import java.util.HashMap;import java.util.Map;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;y1&quot;,&quot;10&quot;);        map.put(&quot;y2&quot;,&quot;20&quot;);        map.put(&quot;y2&quot;,&quot;30&quot;); //键和前面相同时，会替换前面的值        map.put(&quot;y3&quot;,&quot;30&quot;);        System.out.println(map); //&#123;y1=10, y3=30, y2=30&#125;    &#125;&#125;</code></pre><h2 id="8-2-Map集合的基本方法"><a href="#8-2-Map集合的基本方法" class="headerlink" title="8.2 Map集合的基本方法"></a>8.2 Map集合的基本方法</h2><p>方法名说明</p><ol><li>public V put(K key, V value)添加元素</li><li>public V remove(Object key)根据键删除键值对元素</li><li>public void clear()移除所有键值对元素</li><li>public boolean containKey(Object key) [kənˈteɪn]判断集合是否包含指定的键</li><li>public boolean containValue(Object value)判断集合是否包含指定的值</li><li>public boolean isEmpty()判断集合是否为空</li><li>public int size()集合的长度，也就是集合中键值对个数</li></ol><pre><code>package ceshi;import java.util.HashMap;import java.util.Map;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        //1,public V put(K key, V value) 添加元素        map.put(&quot;y1&quot;,&quot;10&quot;);        map.put(&quot;y2&quot;,&quot;20&quot;);        map.put(&quot;y3&quot;,&quot;30&quot;);        System.out.println(map); //&#123;y1=10, y2=20, y3=30&#125;            //2,public V remove(Object key) 根据键删除键值对元素        /*map.remove(&quot;y2&quot;);        System.out.println(map); //&#123;y1=10, y3=30&#125;        */            //3,public void clear() 移除所有键值对元素       /* map.clear();        System.out.println(map); //&#123;&#125;        */            //4,public boolean containKey(Object key) [kənˈteɪn] 判断集合是否包含指定的键        /*System.out.println(map.containsKey(&quot;y2&quot;)); //ture        System.out.println(map.containsKey(&quot;y4&quot;)); //false*/            //5,public boolean containValue(Object value) 判断集合是否包含指定的值//        System.out.println(map.containsValue(&quot;10&quot;)); //true        //6,public boolean isEmpty() 判断集合是否为空//        System.out.println(map.isEmpty()); //false        //7,public int size() 集合的长度，也就是集合中键值对个数        System.out.println(map.size()); //3    &#125;&#125;</code></pre><h2 id="8-3-Map集合的获取方法（重点）"><a href="#8-3-Map集合的获取方法（重点）" class="headerlink" title="8.3 Map集合的获取方法（重点）"></a>8.3 Map集合的获取方法（重点）</h2><p>方法名说明</p><ol><li>public V get(Object key)根据键获取值</li><li>public Set<K> keySet()获取所有键的集合，存储到Set集合中</li><li>public Collection<V> values()获取所有值的集合，存储到Collection集合中</li><li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()获取所有键值对对象的集合（Set集合）</li></ol><pre><code>package ceshi;import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        //public V put(K key, V value) 添加元素        map.put(&quot;y1&quot;,&quot;10&quot;);        map.put(&quot;y2&quot;,&quot;20&quot;);        map.put(&quot;y3&quot;,&quot;30&quot;);        System.out.println(map); //&#123;y1=10, y2=20, y3=30&#125;            //1,public V get(Object key) 根据键获取值        System.out.println(map.get(&quot;y1&quot;)); //10        System.out.println(map.get(&quot;y4&quot;)); //null            //2,public Set&lt;K&gt; keySet() 获取所有键的集合，存储到Set集合中        Set&lt;String&gt; key = map.keySet();        for(String s:key) &#123;            System.out.println(s);            /*y1            y2            y3*/        &#125;            //3,public Collection&lt;V&gt; values() 获取所有值的集合，存储到Collection集合中        Collection&lt;String&gt; vlaues = map.values();        for(String s:vlaues) &#123;            System.out.println(s);            /*10            20            30*/        &#125;            //4,public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 获取所有键值对对象的集合（Set集合）        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();        for(Map.Entry&lt;String, String&gt; s:entries) &#123;            System.out.println(s);            /*            y1=10            y2=20            y3=30*/        &#125;    &#125;&#125;</code></pre><h2 id="8-4-Map集合的遍历"><a href="#8-4-Map集合的遍历" class="headerlink" title="8.4 Map集合的遍历"></a>8.4 Map集合的遍历</h2><p>Map 集合遍历有三种方式：</p><ol><li>“键找值”的方式遍历</li><li>“键值对”的方式遍历</li><li>Lambda 表达式（JDK1.8开始之后的新技术）</li></ol><h3 id="8-4-1-“键找值”的方式遍历（常用）"><a href="#8-4-1-“键找值”的方式遍历（常用）" class="headerlink" title="8.4.1 “键找值”的方式遍历（常用）"></a>8.4.1 “键找值”的方式遍历（常用）</h3><ol><li>1、获取所有键的集合：用keySet()方法实现</li><li>2、遍历键的集合，获取到每一个键：用增强for遍历实现</li><li>3、根据键去找值：在增强for中，用get(Object key)方法实现</li></ol><pre><code>package ceshi;import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        //public V put(K key, V value) 添加元素        map.put(&quot;y1&quot;, &quot;10&quot;);        map.put(&quot;y2&quot;, &quot;20&quot;);        map.put(&quot;y3&quot;, &quot;30&quot;);        System.out.println(map); //&#123;y1=10, y2=20, y3=30&#125;            //1、获取所有键的集合：用keySet()方法实现        Set&lt;String&gt; keySet = map.keySet();            //2、遍历键的集合，获取到每一个键：用增强for遍历实现        for (String key : keySet) &#123;            //3、根据键去找值：在增强for中，用get(Object key)方法实现            String value = map.get(key);            System.out.println(key + &quot;=&quot; + value);            /*            y1=10            y2=20            y3=30*/        &#125;    &#125;&#125;</code></pre><h3 id="8-4-2-“键值对”的方式遍历"><a href="#8-4-2-“键值对”的方式遍历" class="headerlink" title="8.4.2 “键值对”的方式遍历"></a>8.4.2 “键值对”的方式遍历</h3><ol><li>获取所有键值对对象的集合：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</li><li>遍历键值对对象的集合，得到每一个键值对对象：用增强for实现，得到每一个Map.Entry</li><li>根据键值对对象获取键和值：在增强for中，用geKey()得到键；用getValue()得到值</li></ol><pre><code>package ceshi;import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        //public V put(K key, V value) 添加元素        map.put(&quot;y1&quot;, &quot;10&quot;);        map.put(&quot;y2&quot;, &quot;20&quot;);        map.put(&quot;y3&quot;, &quot;30&quot;);        System.out.println(map); //&#123;y1=10, y2=20, y3=30&#125;            //1、获取所有键值对对象的集合：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();            //2、遍历键值对对象的集合，得到每一个键值对对象：用增强for实现，得到每一个Map.Entry        for(Map.Entry&lt;String, String&gt; me:entrySet) &#123;            //3、根据键值对对象获取键和值：在增强for中，用geKey()得到键；用getValue()得到值            String key = me.getKey();            String value = me.getValue();            System.out.println(key+&quot;=&quot;+value);            /*            y1=10            y2=20            y3=30*/        &#125;    &#125;&#125;</code></pre><h3 id="8-4-3-Lambda-ˈlaemdə-表达式方式遍历"><a href="#8-4-3-Lambda-ˈlaemdə-表达式方式遍历" class="headerlink" title="8.4.3 Lambda [ˈlæmdə] 表达式方式遍历"></a>8.4.3 Lambda [ˈlæmdə] 表达式方式遍历</h3><pre><code>package ceshi;import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        //public V put(K key, V value) 添加元素        map.put(&quot;y1&quot;, &quot;10&quot;);        map.put(&quot;y2&quot;, &quot;20&quot;);        map.put(&quot;y3&quot;, &quot;30&quot;);        System.out.println(map); //&#123;y1=10, y2=20, y3=30&#125;            map.forEach((k , v) -&gt; &#123;            System.out.println(k+&quot;=&quot;+v);            /*            y1=10            y2=20            y3=30*/        &#125;);    &#125;&#125;</code></pre><h2 id="8-5-Map集合存储自定义类型"><a href="#8-5-Map集合存储自定义类型" class="headerlink" title="8.5 Map集合存储自定义类型"></a>8.5 Map集合存储自定义类型</h2><p>Map集合的键和值都可以存储自定义类型<br>如果希望Map集合认为自定义类型的键对象重复了，必须重写对象的hashCode()和equals()方法</p><h2 id="8-6-LinkedHashMap（HashMap子类）"><a href="#8-6-LinkedHashMap（HashMap子类）" class="headerlink" title="8.6 LinkedHashMap（HashMap子类）"></a>8.6 LinkedHashMap（HashMap子类）</h2><p>LinkedHashMap集合是有序不重复的键值对集合</p><pre><code>public class LinkedHashMapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String , Integer&gt; map = new LinkedHashMap&lt;&gt;();        map.put(&quot;y1&quot;,10);        map.put(&quot;y2&quot;,20);        map.put(&quot;y3&quot;,30);         map.put(&quot;y3&quot;,100); //键不变，只是替换其值                System.out.println(map);// &#123;y1=10, y2=20, y3=100&#125;       &#125;&#125;</code></pre><h2 id="8-7-TreeMap"><a href="#8-7-TreeMap" class="headerlink" title="8.7 TreeMap"></a>8.7 TreeMap</h2><p>TreeMap 集合按照键是可排序不重复的键值对集合(默认升序)</p><h2 id="8-8-案例"><a href="#8-8-案例" class="headerlink" title="8.8 案例"></a>8.8 案例</h2><h3 id="8-8-1-集合遍历"><a href="#8-8-1-集合遍历" class="headerlink" title="8.8.1 集合遍历"></a>8.8.1 集合遍历</h3><pre><code>package ceshi;import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        //创建HashMap集合对象        HashMap&lt;String,Student&gt; hm =new HashMap&lt;&gt;();        Student s1 = new Student(&quot;y1&quot;,10);        Student s2 = new Student(&quot;y2&quot;,20);        Student s3 = new Student(&quot;y3&quot;,30);            hm.put(&quot;itheima1&quot;,s1);        hm.put(&quot;itheima2&quot;,s2);        hm.put(&quot;itheima3&quot;,s3);            //键找值        Set&lt;String&gt; keySet = hm.keySet();        for(String key:keySet) &#123;            Student value = hm.get(key);            System.out.println(key+&quot;,&quot;+value.getName()+&quot;,&quot;+value.getAge());            /*itheima3,y3,30            itheima1,y1,10            itheima2,y2,20*/        &#125;        System.out.println(&quot;---------&quot;);            //键值对        Set&lt;Map.Entry&lt;String, Student&gt;&gt; entrySet= hm.entrySet();        for(Map.Entry&lt;String, Student&gt; me:entrySet) &#123;            String key = me.getKey();            Student value = me.getValue();            System.out.println(key+&quot;,&quot;+value.getName()+&quot;,&quot;+value.getAge());            /*itheima3,y3,30            itheima1,y1,10            itheima2,y2,20*/        &#125;        &#125;&#125;</code></pre><h3 id="8-8-2-集合嵌套之-ArrayList嵌套HashMap"><a href="#8-8-2-集合嵌套之-ArrayList嵌套HashMap" class="headerlink" title="8.8.2 集合嵌套之 ArrayList嵌套HashMap"></a>8.8.2 集合嵌套之 ArrayList嵌套HashMap</h3><pre><code>package ceshi;import java.util.*;public class MapDemo &#123;    public static void main(String[] args) &#123;        //1,创建ArrayList集合对象        ArrayList&lt;HashMap&lt;String,String&gt;&gt; array = new ArrayList&lt;&gt;();        //2,创建HashMap集合，并添加键值对元素        HashMap&lt;String,String&gt; hm1 = new HashMap&lt;&gt;();        hm1.put(&quot;y1&quot;,&quot;10&quot;);        HashMap&lt;String,String&gt; hm2 = new HashMap&lt;&gt;();        hm1.put(&quot;y2&quot;,&quot;20&quot;);        HashMap&lt;String,String&gt; hm3 = new HashMap&lt;&gt;();        hm1.put(&quot;y3&quot;,&quot;30&quot;);            //3,把HashMap作为元素添加到Arraylist        array.add(hm1);        array.add(hm2);        array.add(hm3);            //遍历Arraylist        for(HashMap&lt;String,String&gt; hm:array) &#123;            Set&lt;String&gt; keySet = hm.keySet();            for(String key:keySet) &#123;                String value = hm.get(key);                System.out.println(key+&quot;,&quot;+value);                /*y1,10                y2,20                y3,30*/            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="8-8-3-统计字符串中每个字符出现的次数"><a href="#8-8-3-统计字符串中每个字符出现的次数" class="headerlink" title="8.8.3 统计字符串中每个字符出现的次数"></a>8.8.3 统计字符串中每个字符出现的次数</h3><h1 id="9-泛型"><a href="#9-泛型" class="headerlink" title="9 泛型"></a>9 泛型</h1><h2 id="9-1-泛型的概述和好处"><a href="#9-1-泛型的概述和好处" class="headerlink" title="9.1 泛型的概述和好处"></a>9.1 泛型的概述和好处</h2><p>泛型：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数</p><p>一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢?顾名思义，就是将类型由原来的具体的类型参数化，然后在使用&#x2F;调用时传入具体的类型</p><p>这种参数类型可以用在类、方法和接口中,分别被称为泛型类、泛型方法、泛型接口</p><p>泛型定义格式：</p><pre><code>&lt;类型&gt;:指定一种类型的格式。这里的类型可以看成是形参&lt;类型1,类型2…&gt;:指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参将来具体调用时候给定的类型可以看成是实参, 并粗实参的类型只能是引用数据类型JDK 1.7开始之后，泛型后面的申明可以省略不写</code></pre><p>泛型和集合都只能支持引用数据类型，不支持基本数据类型</p><pre><code>ArrayList&lt;String&gt; lists = new ArrayList&lt;String&gt;();ArrayList&lt;String&gt; lists = new ArrayList&lt;&gt;(); // JDK 1.7开始之后，泛型后面的申明可以省略不写!!</code></pre><p>泛型的好处：<br>把运行的错误提前到编译时期<br>避免了强制类型转换</p><pre><code>Collection&lt;String&gt; c = new ArrayList&lt;&gt;();        c.add(&quot;java&quot;);//        c.add(100); //报错//        c.add(false); //报错</code></pre><h2 id="9-2-泛型类"><a href="#9-2-泛型类" class="headerlink" title="9.2 泛型类"></a>9.2 泛型类</h2><p>泛型类的概念：使用了泛型定义的类就是泛型类<br>常用泛型变量：T、E、V、K等形式的参数用来表示泛型<br>格式</p><pre><code>修饰符 class 类名&lt;泛型变量&gt;&#123;&#125;</code></pre><pre><code>//范例public class Generic&lt;T&gt; &#123;&#125;</code></pre><ol><li>泛型类的核心思想：是把出现泛型变量的地方全部替换成传输的真实数据类型</li></ol><p>泛型类</p><pre><code>package ceshi;public class Generic&lt;T&gt; &#123;    private T t;    public T getT() &#123;        return t;    &#125;    public void setT(T t) &#123;        this.t = t;    &#125;&#125;</code></pre><p>测试类</p><pre><code>package ceshi;public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic&lt;String&gt; g1 = new Generic&lt;&gt;();        g1.setT(&quot;y1&quot;);        Generic&lt;Integer&gt; g2 = new Generic&lt;&gt;();        g2.setT(20);            System.out.println(g1.getT()+&quot;,&quot;+g2.getT()); //y1,20            Generic&lt;Boolean&gt; g3 = new Generic&lt;&gt;();        g3.setT(true);        System.out.println(g3.getT()); //true    &#125;&#125;</code></pre><h2 id="9-3-泛型方法"><a href="#9-3-泛型方法" class="headerlink" title="9.3 泛型方法"></a>9.3 泛型方法</h2><p>泛型方法定义格式</p><pre><code>修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名)&#123;&#125;//范例public &lt;T&gt; void show(T t) &#123;&#125;</code></pre><p>泛型方法定义</p><pre><code>package ceshi;/*public class Generic &#123;    public void show(String s) &#123;        System.out.println(s);    &#125;    public void show(Integer i) &#123;        System.out.println(i);    &#125;    public void show(Boolean b) &#123;        System.out.println(b);    &#125;&#125;*///泛型类改进/*public class Generic&lt;T&gt; &#123;    public void show(T t) &#123;        System.out.println(t);    &#125;&#125;*///泛型方法public class Generic &#123;    public &lt;T&gt; void show (T t) &#123;        System.out.println(t);    &#125;&#125;</code></pre><pre><code>测试类package ceshi;public class GenericDemo &#123;    public static void main(String[] args) &#123;        /*Generic g1 = new Generic();        g1.show(&quot;y1&quot;);        g1.show(30);        g1.show(true);*/        //泛型类        /*Generic&lt;String&gt; g1 = new Generic&lt;&gt;();        g1.show(&quot;y1&quot;);            Generic&lt;Integer&gt; g2 = new Generic&lt;&gt;();        g2.show(10);*/            //泛型方法        Generic g = new Generic();        g.show(&quot;y1&quot;);        g.show(10);        g.show(true);        g.show(13.14);        /*y1        10        true        13.14*/        &#125;&#125;</code></pre><h2 id="9-4-泛型接口"><a href="#9-4-泛型接口" class="headerlink" title="9.4 泛型接口"></a>9.4 泛型接口</h2><p>泛型接口定义格式</p><pre><code>修饰符 interface 接口名称&lt;类型&gt; &#123;&#125;//范例public interface Generic&lt;T&gt; &#123;&#125;</code></pre><p>泛型接口</p><pre><code>package ceshi;public interface Generic&lt;T&gt; &#123;    void show(T t);&#125;</code></pre><p>实现类</p><pre><code>package ceshi;public class GenericImpl&lt;T&gt; implements Generic&lt;T&gt;&#123;    @Override    public void show(T t) &#123;        System.out.println(t);    &#125;&#125;</code></pre><p>测试类</p><pre><code>package ceshi;public class GenericDemo &#123;    public static void main(String[] args) &#123;        GenericImpl g1 = new GenericImpl();        g1.show(&quot;y1&quot;);        g1.show(10);    &#125;&#125;</code></pre><h2 id="9-5-类型通配符"><a href="#9-5-类型通配符" class="headerlink" title="9.5 类型通配符"></a>9.5 类型通配符</h2><p>为了表示各种泛型List的父类，可以使用类型通配符</p><p>类型通配符: &lt;?&gt;</p><pre><code>List&lt;?&gt;：表示元素类型未知的List,它的元素可以匹配任何的类型这种带通配符的List仅表示它是各种泛型List的父类,并不能把元素添加到其中如果说我们不希望List&lt;?&gt;是任何泛型List的父类,只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</code></pre><p>类型通配符 上限: &lt;? extends类型&gt;<br>List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型<br>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p><p>类型通配符 下限:：&lt;?super 类型&gt;<br>List&lt;? super Number&gt;：它表示的类型是Number或者其父类型</p><pre><code>package ceshi;import java.util.ArrayList;import java.util.List;public class GenericDemo &#123;    public static void main(String[] args) &#123;        //类型通配符: &lt;?&gt;        List&lt;?&gt; list1 = new ArrayList&lt;Number&gt;();        List&lt;?&gt; list2 = new ArrayList&lt;String&gt;();        List&lt;?&gt; list3 = new ArrayList&lt;Integer&gt;();        //类型通配符上限: &lt;? extends类型&gt;//        List&lt;? extends Number&gt; list4 = new ArrayList&lt;Object&gt;(); 报错，超过上限        List&lt;? extends Number&gt; list5 = new ArrayList&lt;Number&gt;();        List&lt;? extends Number&gt; list6 = new ArrayList&lt;Integer&gt;();        //类型通配符 下限:：&lt;?super 类型&gt;        List&lt;? super Number&gt; list7 = new ArrayList&lt;Object&gt;();        List&lt;? super Number&gt; list8 = new ArrayList&lt;Number&gt;();//        List&lt;? super Number&gt; list9 = new ArrayList&lt;Integer&gt;(); 报错    &#125;&#125;</code></pre><h2 id="9-6-可变参数"><a href="#9-6-可变参数" class="headerlink" title="9.6 可变参数"></a>9.6 可变参数</h2><p>可变参数又称参数个数可变,用作方法的形参出现，那么方法参数个数就是可变的了<br>格式：修饰符 返回值类型 方法名(数据类型…变量名){ }<br>范例：public static int sum(int…a) {}<br>注意事项<br>这里的变量其实是一个数组<br>一个方法有多个参数，包含可变参数，可变参数放最后<br>范例：public static int sum(int b,int…a) {}</p><pre><code>package ceshi;import java.util.ArrayList;import java.util.List;public class GenericDemo &#123;    public static void main(String[] args) &#123;        System.out.println(sum(10,20));        System.out.println(sum(10,20,30));        System.out.println(sum(10,20,30,40));        /*        30        60        100*/    &#125;    public static int sum(int...a) &#123; //a为数组        int sum =0;        for(int i:a) &#123;            sum +=i;        &#125;        return sum;    &#125;    //一个方法有多个参数，可变参数放最后    /*public static int sum(int b,int...a) &#123;        return 0;    &#125;*/&#125;</code></pre><h2 id="9-7-可变参数的使用"><a href="#9-7-可变参数的使用" class="headerlink" title="9.7 可变参数的使用"></a>9.7 可变参数的使用</h2><p>1、Arrays工具类中有一个静态方法:</p><p>public static <T> List<T> asList(T… a)：返回由指定数组支持的固定大小的列表<br>返回的集合不能做增删操作，可以做修改<br>2、List接口中有一个静态方法:（JDK9以上）</p><p>public static <E> List<E> of(E… elements)：返回包含任意数元素的不可变列表<br>返回的集合不能做增删改操作<br>3、Set接口中有一个静态方法: （JDK9以上）</p><ul><li>public static <E> Set<E> of(E…. elements)：返回一个包含任意数量元素的不可变集合</li></ul><p>在给元素的时候，不能给重复值<br>返回的集合不能做增删操作，没有修改方法</p><pre><code>package ceshi;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Set;public class GenericDemo &#123;    public static void main(String[] args) &#123;        //1、public static &lt;T&gt; List&lt;T&gt; asList(T... a)：返回由指定数组支持的固定大小的列表/*        List&lt;String&gt; list = Arrays.asList(&quot;java&quot;, &quot;python&quot;, &quot;scala&quot;);        System.out.println(list); //[java, python, scala]//        list.add(&quot;javase&quot;); //UnsupportedOperationException;不支持请求操作//        list.remove(&quot;java&quot;); //UnsupportedOperationException;不支持请求操作        list.set(0,&quot;javase&quot;);        System.out.println(list); //[javase, python, scala]*/        //2、public static &lt;E&gt; List&lt;E&gt; of(E... elements)：返回包含任意数元素的不可变列表        List&lt;String&gt; list = List.of(&quot;java&quot;,&quot;python&quot;,&quot;scala&quot;,&quot;java&quot;)        System.out.println(list); //[javase, python, scala,java]                //list.add(&quot;javaee&quot;); //UnsupportedOperationException        //list.remove(&quot;java&quot;); //UnsupportedOperationException        //list.set(0,&quot;javaee&quot;) //UnsupportedOperationException                //3、public static &lt;E&gt; Set&lt;E&gt; of(E.... elements)：返回-一个包含任意数量元素的不可变集合        //Set&lt;String&gt; set = Arrays.of(&quot;java&quot;, &quot;python&quot;, &quot;scala&quot;,&quot;java&quot;); //set集合不能重复        Set&lt;String&gt; set = Arrays.of(&quot;java&quot;, &quot;python&quot;, &quot;scala&quot;);        System.out.println(set); //[java, python, scala]                //set.add(&quot;javaee&quot;); //UnsupportedOperationException        //set.remove(&quot;java&quot;); //UnsupportedOperationException        &#125;&#125;****</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> -- 蓝桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.0linux基础</title>
      <link href="/2024/03/10/1-0linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/10/1-0linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/.1.0linux%E5%9F%BA%E7%A1%80_0.png" alt="1.0linux基础_0"></p><p><img src="/1.0linux%E5%9F%BA%E7%A1%80_1.png" alt="1.0linux基础_1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> -- 大三下ros操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux实验2</title>
      <link href="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/"/>
      <url>/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/</url>
      
        <content type="html"><![CDATA[<h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h2 id="1-Ubuntu-常用命令使用"><a href="#1-Ubuntu-常用命令使用" class="headerlink" title="1.Ubuntu 常用命令使用"></a>1.Ubuntu 常用命令使用</h2><h3 id="进行-mkdir-和-cd-等命令的操作，首先建立临时目录-test，并进入该目录。"><a href="#进行-mkdir-和-cd-等命令的操作，首先建立临时目录-test，并进入该目录。" class="headerlink" title="进行 mkdir 和 cd 等命令的操作，首先建立临时目录~&#x2F;test，并进入该目录。"></a>进行 mkdir 和 cd 等命令的操作，首先建立临时目录~&#x2F;test，并进入该目录。</h3><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307160347600.png" alt="image-20240307160347600"></p><h3 id="使用-touch-创建文件"><a href="#使用-touch-创建文件" class="headerlink" title="使用 touch 创建文件"></a>使用 touch 创建文件</h3><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307160938322.png" alt="image-20240307160938322"></p><h3 id="进行-ls-cp-mv-rm-chmod-等命令的操作，查看文件列表、新建、拷贝、修改或删除文件，并查看／修改文件权限"><a href="#进行-ls-cp-mv-rm-chmod-等命令的操作，查看文件列表、新建、拷贝、修改或删除文件，并查看／修改文件权限" class="headerlink" title="进行 ls, cp, mv, rm, chmod 等命令的操作，查看文件列表、新建、拷贝、修改或删除文件，并查看／修改文件权限"></a>进行 ls, cp, mv, rm, chmod 等命令的操作，查看文件列表、新建、拷贝、修改或删除文件，并查看／修改文件权限</h3><h4 id="cp命令-复制文件"><a href="#cp命令-复制文件" class="headerlink" title="cp命令 复制文件"></a>cp命令 复制文件</h4><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307161324875.png" alt="image-20240307161324875"></p><h4 id="cp命令复制目录"><a href="#cp命令复制目录" class="headerlink" title="cp命令复制目录"></a>cp命令复制目录</h4><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307161635267.png" alt="image-20240307161635267"></p><h4 id="chmod修改权限"><a href="#chmod修改权限" class="headerlink" title="chmod修改权限"></a>chmod修改权限</h4><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307162028295-1709799628926-8.png" alt="image-20240307162028295"></p><h4 id="rm删除命令"><a href="#rm删除命令" class="headerlink" title="rm删除命令"></a>rm删除命令</h4><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307162213967.png" alt="image-20240307162213967"></p><h4 id="mv-移动、重命名"><a href="#mv-移动、重命名" class="headerlink" title="mv 移动、重命名"></a>mv 移动、重命名</h4><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307162810235.png" alt="image-20240307162810235"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307162900099.png" alt="image-20240307162900099"></p><h4 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h4><p>文件内容查找练习，尝试执行 find &#x2F;usr&#x2F;src&#x2F; -name *.c | xargs grep “#include” | cat –<br>n，并解释这条命令。<br>在&#x2F;usr&#x2F;src 目录下查找所有包含“#include”字符串的 C 文件，对其进行编号输出</p><h4 id="系统信息查看命令练习"><a href="#系统信息查看命令练习" class="headerlink" title="系统信息查看命令练习"></a>系统信息查看命令练习</h4><p>查看系统版本<br>发行版本号 </p><p>lsb_release -a</p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307165634854.png" alt="image-20240307165634854"></p><p>内核版本及系统位 </p><p>uname -a</p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307165656234.png" alt="image-20240307165656234"></p><p>内核版本及 gcc 版本</p><p>cat &#x2F;proc&#x2F;version</p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307165718184.png" alt="image-20240307165718184"></p><p>查看硬件信息<br>cpu 信息</p><p>cat &#x2F;proc&#x2F;cpuinfo or lscpu</p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307165854386.png" alt="image-20240307165854386"></p><p>内存信息</p><p>sudo dmidecode -t memory</p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307170133105.png" alt="image-20240307170133105"></p><p>运行时信息</p><p>top 实时 CPU&amp;内存使用情况</p><p>free 当前内存占用情况</p><p>ps -aux 查看当前进程状态（CPU、内存占用、开启时间）</p><p>kill 根据进程 pid 杀死指定进程，可以配合参数-9 强制杀死</p><h2 id="2、Vim-的使用"><a href="#2、Vim-的使用" class="headerlink" title="2、Vim 的使用"></a>2、Vim 的使用</h2><h1 id="（1）将-vim-tutor-命令生成的文档另存为-vimtcp-文件"><a href="#（1）将-vim-tutor-命令生成的文档另存为-vimtcp-文件" class="headerlink" title="（1）将 vim tutor 命令生成的文档另存为 vimtcp 文件"></a>（1）将 vim tutor 命令生成的文档另存为 vimtcp 文件</h1><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307170510901.png" alt="image-20240307170510901"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307170351410.png" alt="image-20240307170351410"></p><h2 id="下面的内容-w-tcp-相当于又创建一个文件名-tcp-的文件，并将当前内容写入-tcp-文件，原本的-tutor-文件仍然存"><a href="#下面的内容-w-tcp-相当于又创建一个文件名-tcp-的文件，并将当前内容写入-tcp-文件，原本的-tutor-文件仍然存" class="headerlink" title="下面的内容:w tcp 相当于又创建一个文件名 tcp 的文件，并将当前内容写入 tcp 文件，原本的 tutor 文件仍然存"></a>下面的内容:w tcp 相当于又创建一个文件名 tcp 的文件，并将当前内容写入 tcp 文件，原本的 tutor 文件仍然存</h2><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307170640148.png" alt="image-20240307170640148"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307170728174.png" alt="image-20240307170728174"></p><p>尝试输入一段英文</p><pre><code>vim tutor</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307170929196.png" alt="image-20240307170929196"></p><p>N和n</p><h2 id="尝试查找一串字符"><a href="#尝试查找一串字符" class="headerlink" title="尝试查找一串字符"></a>尝试查找一串字符</h2><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307171141384.png" alt="image-20240307171141384"></p><h2 id="尝试替换其中一串"><a href="#尝试替换其中一串" class="headerlink" title="尝试替换其中一串"></a>尝试替换其中一串</h2><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307171332658.png" alt="image-20240307171332658"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307171341242.png" alt="image-20240307171341242"></p><p>注意：作用范围分为当前行、全文、选区等等（指令间没有空格）。<br>当前行：<br>:s&#x2F;hello&#x2F;bar&#x2F;g<br>全文：<br>:%s&#x2F;world&#x2F;bar&#x2F;g</p><h2 id="（5）尝试复制／删除其中一行或几行"><a href="#（5）尝试复制／删除其中一行或几行" class="headerlink" title="（5）尝试复制／删除其中一行或几行"></a>（5）尝试复制／删除其中一行或几行</h2><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307171918335.png" alt="image-20240307171918335"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307172016667.png" alt="image-20240307172016667"></p><p>（6）尝试复制／删除其中的一个单词或几个字符</p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240307172442209.png" alt="image-20240307172442209"></p><p>注意：选择文本需要使用按键箭头选择，鼠标选择无效。</p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308015127348.png" alt="image-20240308015127348"></p><p>（7）尝试存盘</p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308015207532.png" alt="image-20240308015207532"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308015236195.png" alt="image-20240308015236195"></p><h2 id="3、其它远程命令使用（选做）"><a href="#3、其它远程命令使用（选做）" class="headerlink" title="3、其它远程命令使用（选做）"></a>3、其它远程命令使用（选做）</h2><p>远程连接 ssh重装 ssh 服务，生成证书</p><pre><code>sudo apt-get remove openssh-serversudo apt-get install openssh-server</code></pre><p>修改 sshd_config 文件，确保可以使用用户名密码连接</p><pre><code>sudo vi /etc/ssh/sshd_config</code></pre><p>Port 22 #默认即可，如果有端口占用可以自己修改</p><pre><code>PasswordAuthentication yes # 允许用户名密码方式登录</code></pre><p>重启 ssh 服务</p><pre><code>sudo service ssh restart</code></pre><p>远程连接</p><pre><code>ssh root@192.168.37.123</code></pre><p>语法：ssh [user@]host[ port][;host[ port]]</p><p>如果没启动，通过以下命令启动即可</p><pre><code>sudo service ssh start</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308021238116.png" alt="image-20240308021238116"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308021811760.png" alt="image-20240308021811760"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308022647678.png" alt="image-20240308022647678"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308023209915.png" alt="image-20240308023209915"></p><ol><li>以管理员身份打开命令提示符或PowerShell。你可以在开始菜单中搜索“cmd”或“PowerShell”，然后右键点击选择以管理员身份运行。</li><li>输入以下命令来关闭Windows Defender防火墙：</li></ol><pre><code>bashCopy Codenetsh advfirewall set allprofiles state off</code></pre><ol><li>按下 Enter 键执行命令。这将关闭所有网络配置文件（公用、专用和域）的防火墙。</li></ol><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308023804155.png" alt="image-20240308023804155"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308023946440.png" alt="image-20240308023946440"></p><pre><code>SHA256:lqDy8zquBCBrvdVeJZ8qcCoZfpeffrlXcMu36mGVrOY root@DESKTOP-ICLQUL1The key&#39;s randomart image is:+---[RSA 3072]----+|                 ||                 ||o     .  . .     ||o..  ... .+ .....||o..o.o oS. o  ++.||...o= =.o .   o+.||  .=oo = .  .=. o|| .  +o. o .o+... ||  .ooo. .+..+E.  |+----[SHA256]-----+</code></pre><h1 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h1><pre><code>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDBxBpM7FWR1ALCywQudyXZXLUBt2cw3S9KA/vWoKHM+c797dMy92U5iXfPH7Jy0BnwY8CYrhfFWfZsiCyw0clXxamN1f5M55Hxm8AVpGdrozUnvf4X2jJVdFLg2hJnymiocnEJ5rHreuxDRPd05WyidQf3UxUjwrY3bLPl3OXVQa4EVuSDrTIppX83Oa3lLZUZtbXiFSJeAjcda5Z6odYyddSi6L8675xgwu0sprMxdKZtCWzvRA428DIORuu7TQaESrPo9qJWztjbcWF4IoQ61UZFNf9nt3IVqR9T4iI1NRxNnmY0nN5XqatsGYyNKqU45Mw+aCuTShqj/R7FR+d1bxULiKQ+k7AJK9+qx+i0SRuQJtEtuDeHwRATXOndA6/SVcYqbBmi3qcGnAcGkGc3dI3ukeC9j7Gwt8Kepl1U8sKemLNHBE93C0/psIAQ0GKN9djoWmVRXiGuf4HsPWABmWokLVRfq56s/lG4PhmO5yphU6KpMDjhxhxqzFYJlbc= root@DESKTOP-I</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308024925045.png" alt="image-20240308024925045"></p><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308025303829.png" alt="image-20240308025303829"></p><p>请注意，关闭防火墙会降低计算机的安全性，因此在不需要时应尽快重新打开防火墙。</p><p>如果你想要重新启用防火墙，可以使用以下命令：</p><pre><code>netsh advfirewall set allprofiles state on</code></pre><p>执行完毕后，防火墙将重新启用。</p><p>也可以用 xshell </p><p>远程拷贝文件：scp</p><p>从远程复制文件到本地</p><pre><code>scp root@DESKTOP-ICLQUL1:tcp /home</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308025956210.png" alt="image-20240308025956210"></p><p>从本地复制文件到远程</p><pre><code>scp /mnt/d/Wsl2_Ubuntu/1.jpg root@DESKTOP-ICLQUL1:tcp</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308030511569.png" alt="image-20240308030511569"></p><p>创建目录</p><pre><code>ssh root@DESKTOP-ICLQUL1 &quot;mkdir -p /path/to/source/directory&quot;</code></pre><p>从远程复制目录到本地 -r</p><pre><code> scp -r root@DESKTOP-ICLQUL1:/path/to/source/directory /mnt/d/Wsl2_Ubuntu</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308031042059.png" alt="image-20240308031042059"></p><p>从本地复制目录到远程 -r</p><pre><code>scp -r /path/to/source/directory root@DESKTOP-ICLQUL1:/mnt/d/Wsl2_Ubuntu</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308031311141.png" alt="image-20240308031311141"></p><p>文件下载：wget</p><p>下载普通文件</p><pre><code>wget http://p1.qhimgs4.com/t01ce0387e64e3428ca.jpg</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308031337709.png" alt="image-20240308031337709"></p><p>以指定文件名保存文件</p><pre><code>wget -O girl.jpg http://p1.qhimgs4.com/t01ce0387e64e3428ca.jpg</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308031358273.png" alt="image-20240308031358273"></p><p>断点续传</p><pre><code>wget -c http://p1.qhimgs4.com/t01ce0387e64e3428ca.jpg</code></pre><p><img src="/2024/03/07/linux%E5%AE%9E%E9%AA%8C2/image-20240308031433411.png" alt="image-20240308031433411"></p><h2 id="五、思考题"><a href="#五、思考题" class="headerlink" title="五、思考题"></a>五、思考题</h2><p>1、 写出 Ubuntu 的更改文件权限的命令，并实现对文件 test.py 的权限更改为可读写和可执行？</p><p>更改文件权限，您可以使用 <code>chmod</code> 命令。下面是更改文件 <code>test.py</code> 的权限为可读写和可执行的命令：</p><pre><code>chmod +rwx test.py</code></pre><p>这条命令中的符号 <code>+</code> 表示添加权限，<code>r</code> 表示可读，<code>w</code> 表示可写，<code>x</code> 表示可执行。所以 <code>+rwx</code> 表示添加读、写、执行权限。</p><p>如果您只想赋予特定权限而不是添加，您可以使用类似如下的命令：</p><pre><code>chmod u+rwx test.py</code></pre><p>这条命令中的 <code>u</code> 表示用户（owner），<code>+rwx</code> 表示添加读、写、执行权限</p><p>2、使用 Vim 创建一个 test.py 文件并写入打印 hello 的程序？</p><ol><li>打开终端。</li><li>输入以下命令以使用 Vim 创建并编辑 <code>test.py</code> 文件：</li></ol><pre><code>vim test.py</code></pre><ol><li>在 Vim 编辑器中，按下 <code>i</code> 键进入插入模式（Insert Mode）。</li><li>输入以下 Python 代码：</li></ol><pre><code>print(&quot;hello&quot;)</code></pre><ol><li>按下 <code>Esc</code> 键退出插入模式。</li><li>输入 <code>:wq!</code> 并按下 <code>Enter</code> 键保存并退出 Vim 编辑器。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> -- 大三下ros操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux笔记</title>
      <link href="/2024/03/07/linux%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/07/linux%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux快速入门-Ubuntu"><a href="#Linux快速入门-Ubuntu" class="headerlink" title="Linux快速入门(Ubuntu)"></a>Linux快速入门(Ubuntu)</h2><h2 id="Linux应用领域"><a href="#Linux应用领域" class="headerlink" title="Linux应用领域"></a>Linux应用领域</h2><h3 id="服务器领域"><a href="#服务器领域" class="headerlink" title="服务器领域"></a>服务器领域</h3><ul><li>Linux 在服务器领域的应用是其重要分支</li><li>Linux 免费、稳定、高效等特点在这里得到了很好的体现</li><li>早期因为维护、运行等原因同样受到了很大的限制</li><li>近些年来 Linux 服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛</li></ul><h3 id="嵌入式领域"><a href="#嵌入式领域" class="headerlink" title="嵌入式领域"></a>嵌入式领域</h3><ul><li>近些年来 Linux 在嵌入式领域的应用得到了飞速的提高</li><li>Linux 运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达</li><li>到几百 KB 等特点，使其近些年来在嵌入式领域的应用得到非常大的提高</li></ul><p>Tip</p><p>主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、等都是其应用领域，得到了<br>Google、三星、摩托罗拉、NEC 等公司的大力推广</p><h3 id="个人桌面领域"><a href="#个人桌面领域" class="headerlink" title="个人桌面领域"></a>个人桌面领域</h3><ul><li>此领域是传统 Linux 应用最薄弱的环节</li><li>传统 Linux 由于界面简单、操作复杂、应用软件少的缺点，一直被 Windows 所压制</li><li>近些年来随着 Ubuntu、Fedora 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，</li><li>Linux 在个人桌面领域的占有率在逐渐的提高</li></ul><h3 id="移动设备操作系统"><a href="#移动设备操作系统" class="headerlink" title="移动设备操作系统"></a>移动设备操作系统</h3><p><img src="/.image-20240308221233101.png" alt="image-20240308221233101"></p><p>各种品牌的Android手机</p><p><img src="/2024/03/07/linux%E7%AC%94%E8%AE%B0/image-20240308221249312.png" alt="image-20240308221249312"></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="windows-文件系统"><a href="#windows-文件系统" class="headerlink" title="windows 文件系统"></a>windows 文件系统</h3><p>在 Windows 下，打开 “计算机”，我们看到的是一个个的驱动器盘符：</p><p><img src="/2024/03/07/linux%E7%AC%94%E8%AE%B0/image-20240308221318125.png" alt="image-20240308221318125"></p><h5 id="每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示："><a href="#每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示：" class="headerlink" title="每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示："></a>每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示：</h5><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><p>在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）：</p><p><img src="/2024/03/07/linux%E7%AC%94%E8%AE%B0/image-20240308221332326.png" alt="image-20240308221332326"></p><p>Ubuntu 没有盘符这个概念，只有一个根目录 &#x2F;，所有文件都在它下面</p><p><img src="/2024/03/07/linux%E7%AC%94%E8%AE%B0/image-20240308221405537.png" alt="image-20240308221405537"></p><h4 id="用户根目录"><a href="#用户根目录" class="headerlink" title="用户根目录"></a>用户根目录</h4><p>位于 &#x2F;home&#x2F;user，称之为用户工作目录或家目录，表示方式：</p><pre><code>/home/user或者~</code></pre><p>Note</p><pre><code>/home/user`中的`user`是用户目录名，目前我们的用户是`itcast</code></pre><p>目录 描述</p><pre><code>/ 根目录。一般根目录下只存放目录，在/home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 linux 下有且只有一个根目录，所有的东西都是从这里开始 home 目录^ 当在终端里输入/bin，/usr/bin 可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等/boot 放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub/dev 存放/mntlinux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom/etc 系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有，/etc/inittab，/etc/fstab，/etc/init.d，/etc/X11，/etc/sysconfig，/etc/xinetd.d/home 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下~ 表示当前用户的家目录，~edu 表示用户 edu 的家目录/lib /usr/lib/usr/local/lib 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助/lost+fount 系统异常产生错误时，会将一些遗失的片段放置于此目录下/mnt，/media 光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载/opt 给主机额外安装软件所摆放的目录/proc 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等/root 系统管理员root的家目录/sbin/usr/sbin/usr/local/sbin放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员root 使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用/tmp 一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下/srv 服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www内/usr 应用程序存放目录/usr/bin 存放应用程序/usr/share 存放共享数据/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件/usr/local 存放软件升级包/usr/share/doc 系统说明文件存放目录/usr/share/man 程序说明文件存放目录/var 放置系统执行过程中经常变化的文件/var/log 随时更改的日志文件/var/spool/mail 邮件存放的目录/var/run 程序或服务启动后，其 PID 存放在该目录下</code></pre><h4 id="linux主要目录速查表"><a href="#linux主要目录速查表" class="headerlink" title="linux主要目录速查表"></a>linux主要目录速查表</h4><p><img src="/2024/03/07/linux%E7%AC%94%E8%AE%B0/image-20240308221554589.png" alt="image-20240308221554589"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Note</p><p>特别关注:</p><pre><code>用户目录/home/user或~</code></pre><p>其他的作为后续查询使用</p><h2 id="终端命令行"><a href="#终端命令行" class="headerlink" title="终端命令行"></a>终端命令行</h2><h3 id="为啥要学Linux终端命令"><a href="#为啥要学Linux终端命令" class="headerlink" title="为啥要学Linux终端命令"></a>为啥要学Linux终端命令</h3><h5 id="序号-命令-作用-对应英文"><a href="#序号-命令-作用-对应英文" class="headerlink" title="序号 命令 作用 对应英文"></a>序号 命令 作用 对应英文</h5><pre><code>1 ls 查看当前文件夹下的内容 list2 pwd 查看当前所在文件夹 print wrok directory3 cd [目录名] 切换文件夹 change directory4 touch [文件名] 如果文件不存在，新建文件 touch5 mkdir [目录名] 创建目录 make directory6 rm [文件名] 删除指定的文件名 remove7 clear 清屏 clear</code></pre><h5 id="很多人可能在电视或电影中看到过类似的场景，黑客面对一个黑色的屏幕，上面飘着密密麻麻的字"><a href="#很多人可能在电视或电影中看到过类似的场景，黑客面对一个黑色的屏幕，上面飘着密密麻麻的字" class="headerlink" title="很多人可能在电视或电影中看到过类似的场景，黑客面对一个黑色的屏幕，上面飘着密密麻麻的字"></a>很多人可能在电视或电影中看到过类似的场景，黑客面对一个黑色的屏幕，上面飘着密密麻麻的字</h5><h5 id="符，梆梆一顿敲，就完成了窃取资料的任务。"><a href="#符，梆梆一顿敲，就完成了窃取资料的任务。" class="headerlink" title="符，梆梆一顿敲，就完成了窃取资料的任务。"></a>符，梆梆一顿敲，就完成了窃取资料的任务。</h5><pre><code>Linux 刚出世时没有什么图形界面，所有的操作全靠命令完成，就如同电视里的黑客那样，充满了神秘与晦涩。近几年来，尽管 Linux 发展得非常迅速，图形界面越来越友好，但是在真正的开发过程中，Linux 命令行的应用还是占有非常重要的席位，而且许多Linux功能在命令行界面要比图形化界面下运行的快。可以说不会命令，就不算会 Linux。在职场中，大量的 服务器维护工作 都是在 远程 通过 SSH 客户端 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成。如 磁盘操作、文件存取、目录操作、进程管理、文件权限设定等Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已</code></pre><p>学习终端命令的技巧</p><pre><code>不需要硬背，不需要硬背，不需要硬背！常用命令，用的多了，自然就记住了不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时查资料就可以</code></pre><h3 id="牢记于指尖"><a href="#牢记于指尖" class="headerlink" title="牢记于指尖"></a>牢记于指尖</h3><h5 id="以下命令使用频率可以说是最高的，不断地练习，让他们变成你的肌肉记忆吧"><a href="#以下命令使用频率可以说是最高的，不断地练习，让他们变成你的肌肉记忆吧" class="headerlink" title="以下命令使用频率可以说是最高的，不断地练习，让他们变成你的肌肉记忆吧"></a>以下命令使用频率可以说是最高的，不断地练习，让他们变成你的肌肉记忆吧</h5><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><pre><code>在敲出 文件／目录／命令 的前几个字母之后，按下 tab 键如果输入的没有歧义，系统会自动补全如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令</code></pre><p>小技巧</p><pre><code>按 ↑／↓ 光标键可以在曾经使用过的命令之间来回切换如果想要退出选择，不想执行当前的命令，可以按 ctrl + c</code></pre><h3 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h3><p>Note</p><pre><code>command：命令名，相应功能的英文单词或单词的缩写[-options]：选项，可用来对命令进行控制，也可以省略parameter：传给命令的参数，可以是 零个、一个 或者 多个</code></pre><h3 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h3><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><p>假如一个命令叫做command，显示 command 命令的帮助信息，一般命令参数会有长格式或短格式供选<br>择，分别用–和-为前缀</p><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>查阅某个command命令的使用手册</p><p>Tip</p><pre><code>man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明</code></pre><p>使用 man 时的操作键：</p><pre><code>command [-options] [parameter]command --helpcommand -hman command</code></pre><h5 id="操作键-功能"><a href="#操作键-功能" class="headerlink" title="操作键 功能"></a>操作键 功能</h5><h5 id="空格键-显示手册页的下一屏"><a href="#空格键-显示手册页的下一屏" class="headerlink" title="空格键 显示手册页的下一屏"></a>空格键 显示手册页的下一屏</h5><pre><code>Enter键 一次滚动手册页的一行b 回滚一屏f 前滚一屏q 退出/word 搜索word字符串</code></pre><h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><p>对于一些命令，如果不是很熟悉，通过查看help或者是man还是不知道什么含义时，我们可以通过百<br>度搜素。</p><p>Linux的终端命令不是用来背诵的，只是个工具，反复查询几次就会了。</p><h2 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h2><pre><code>lsclearcdpwdmkdirrmcpmvtouch</code></pre><h3 id="ls-文件及文件夹查看"><a href="#ls-文件及文件夹查看" class="headerlink" title="ls 文件及文件夹查看"></a>ls 文件及文件夹查看</h3><p>ls是英文单词list的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于DOS下的dir<br>命令。Linux文件或者目录名称最长可以有 265 个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开<br>头的文件为隐藏文件，需要用 -a 参数才能显示。</p><p><strong>常用示例：</strong></p><pre><code>ls -a 查看当前所有文件和目录，包含隐藏文件和目录ls -l 以列表形式查看所有文件和目录ll 等同于ls -al 即等同于以上两个命令结合</code></pre><p><strong>ls常用参数：</strong></p><h5 id="参数-含义"><a href="#参数-含义" class="headerlink" title="参数 含义"></a>参数 含义</h5><pre><code>-a 显示指定目录下所有子目录与文件，包括隐藏文件-l 以列表方式显示文件的详细信息-h 配合 -l 以人性化的方式显示文件大小，即文件大小可以用mb</code></pre><h5 id="输出信息含义："><a href="#输出信息含义：" class="headerlink" title="输出信息含义："></a>输出信息含义：</h5><h5 id="通配符："><a href="#通配符：" class="headerlink" title="通配符："></a>通配符：</h5><p>与DOS下的文件操作类似，在Unix&#x2F;Linux系统中，也同样允许使用特殊字符来同时引用多个文件名，这<br>些特殊字符被称为通配符。只要和文件或文件夹描述相关的地方几乎都可以使用通配符。常用的通配符<br>方式</p><pre><code>ls te* 查看所有以te开头的文件及目录ls *.txt 查看所有以.txt结尾的文件及目录ls te[sx]t 将匹配test或text</code></pre><h3 id="clear-清屏命令"><a href="#clear-清屏命令" class="headerlink" title="clear 清屏命令"></a>clear 清屏命令</h3><p>有时候控制台内容太多，可以用clear命令清空一下控制台</p><p>也可使用快捷键：Ctrl + l ( “l” 为字母L的小写 )。</p><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd 切换目录"></a>cd 切换目录</h3><p>在使用Unix&#x2F;Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。 <strong>Linux所有的<br>目录和文件名大小写敏感</strong></p><p>cd（change directory）后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用<br>户的主目录。</p><pre><code>poplar@PoplarTang:~/Lesson/Test$ ls -altotal 0drwxrwxrwx 1 poplar poplar 512 May 9 10:.drwxrwxrwx 1 poplar poplar 512 May 9 10: ..drwxrwxrwx 1 poplar poplar 512 May 9 10:59 TestDirdrwxrwxrwx 1 poplar poplar 512 May 9 10:59 a-rw-rw-rw- 1 poplar poplar 0 May 9 10:59 haha.txt</code></pre><h5 id="命"><a href="#命" class="headerlink" title="命"></a>命</h5><h5 id="令"><a href="#令" class="headerlink" title="令"></a>令</h5><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h5><pre><code>cd切换到当前用户的主目录(/home/用户目录)， 用户登陆时，默认的目录就是用户的主目录。cd~ 切换到当前用户的主目录(/home/用户目录)cd. 切换到当前目录cd..</code></pre><h5 id="切换到上级目录"><a href="#切换到上级目录" class="headerlink" title="切换到上级目录"></a>切换到上级目录</h5><pre><code>cd - 可进入上次所在的目录cd / 切换到系统根目录/</code></pre><p>如果路径是从根路径开始的，则路径的前面需要加上 “ &#x2F; ”，如 “ &#x2F;mnt ”，通常进入某个目录里的文件<br>夹，前面不用加 “ &#x2F; ”。</p><h3 id="pwd-显示当前路径"><a href="#pwd-显示当前路径" class="headerlink" title="pwd 显示当前路径"></a>pwd 显示当前路径</h3><p>使用pwd命令可以显示当前的工作目录，该命令很简单，但又很常用，直接输入pwd即可，后面不带参<br>数。</p><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a>mkdir 创建目录</h3><p>通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。</p><p>需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目<br>录具有写权限。</p><p><strong>常用示例：</strong></p><pre><code>mkdir TestDirmkdir -p a/b/c/d</code></pre><h3 id="touch-创建文件"><a href="#touch-创建文件" class="headerlink" title="touch 创建文件"></a>touch 创建文件</h3><pre><code>ty@ubuntu:~/Downloads$ pwd/home/ty/Downloadspoplar@PoplarTang:~/Lesson/Test$ mkdir TestDirpoplar@PoplarTang:~/Lesson/Test$ mkdir -p a/b/c/dpoplar@PoplarTang:~/Lesson/Test$ tree.├── TestDir├── a│ └── b│ └── c│ └── d└── haha.txt5 directories, 1 file</code></pre><h5 id="参数-含义-1"><a href="#参数-含义-1" class="headerlink" title="参数 含义"></a>参数 含义</h5><pre><code>-f 强制删除，忽略不存在的文件，无需提示-r 递归地删除目录下的内容，删除文件夹时必须加此参数 也可使用rmdir删除一个空目录</code></pre><h5 id="选"><a href="#选" class="headerlink" title="选"></a>选</h5><h5 id="项-含义"><a href="#项-含义" class="headerlink" title="项 含义"></a>项 含义</h5><pre><code>-a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录^ 简单而言，保持文件原有属性。-r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件^ 目标文件必须为一个目录名。</code></pre><p>用户可以通过touch来创建一个空的文件：</p><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><pre><code>会在当前路径下创建名字为hello.txt的空文件Linux系统中没有严格的后缀（格式），所以创建文件时可以命名为任意的文件名</code></pre><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h3><p>可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以<br>在rm后使用-i参数以逐个确认要删除的文件。</p><p>常用参数及含义如下表所示：</p><h5 id="常用示例："><a href="#常用示例：" class="headerlink" title="常用示例："></a>常用示例：</h5><pre><code>rm xxx.txt aaa.txt 删除文件：（可一次删除多个）rm -r test_dir删除目录rmdir test_dir 使用rmdir也可以删除目录, 但必须保证被删除目录里为空</code></pre><h3 id="cp-拷贝文件及目录"><a href="#cp-拷贝文件及目录" class="headerlink" title="cp 拷贝文件及目录"></a>cp 拷贝文件及目录</h3><p>cp（copy）命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命<br>令。</p><p>常用选项说明：</p><h5 id="常用示例：-1"><a href="#常用示例：-1" class="headerlink" title="常用示例："></a>常用示例：</h5><pre><code>cp file.txt abc/将当前目录的file.txt拷贝到abc目录cp abc/*.txt. 将abc目录下的所有txt文件拷贝到当前目录cp -r abc aaa 将abc目录拷贝为aaa目录（包含所有子目录及文件）</code></pre><h3 id="mv-移动、重命名"><a href="#mv-移动、重命名" class="headerlink" title="mv 移动、重命名"></a>mv 移动、重命名</h3><p>用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。</p><pre><code>touch hello.txt</code></pre><h5 id="选-1"><a href="#选-1" class="headerlink" title="选"></a>选</h5><h5 id="项"><a href="#项" class="headerlink" title="项"></a>项</h5><h5 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h5><pre><code>-f 禁止交互式操作，如有覆盖也不会给出提示-i确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖 系统会询问是否重写，要求用户回答以避免误覆盖文件-v 显示移动进度</code></pre><h5 id="常用选项说明："><a href="#常用选项说明：" class="headerlink" title="常用选项说明："></a>常用选项说明：</h5><h5 id="常用示例：-2"><a href="#常用示例：-2" class="headerlink" title="常用示例："></a>常用示例：</h5><pre><code>mv a.md abc.txt 将a.md重命名为abc.txtmv abc.txt ./aaa 将abc.txt移动到当前的aaa目录中</code></pre><h3 id="echo-控制台输出"><a href="#echo-控制台输出" class="headerlink" title="echo 控制台输出"></a>echo 控制台输出</h3><p>向控制台输出HelloWorld信息</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="&gt; 输出重定向"></a>&gt; 输出重定向</h3><p>Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</p><p>test.txt 如果不存在，则创建，存在则覆盖其内容</p><p>注意：&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部</p><h3 id="cat-查看-合并文件内容"><a href="#cat-查看-合并文件内容" class="headerlink" title="cat 查看&amp;合并文件内容"></a>cat 查看&amp;合并文件内容</h3><pre><code>cat xxx.py 可以用来快速查看某个文件内容，输出到控制台cat test.txt &gt;&gt; haha.txt 将test.txt的内容追加到haha.txt中cat 1.txt 2.txt &gt; 1_2.txt将1.txt 2.txt内容合并到1_2.txt中</code></pre><h3 id="tar-归档管理¶"><a href="#tar-归档管理¶" class="headerlink" title="tar 归档管理¶"></a>tar 归档管理¶</h3><p>计算机中的数据经常需要备份，tar是Unix&#x2F;Linux中最常用的备份工具，此命令可以把一系列文件归档<br>到一个大文件中，也可以把档案文件解开以恢复数据。</p><p><strong>tar使用格式：</strong></p><p>tar命令很特殊，其参数前面可以使用“-”，也可以不使用。</p><p><strong>常用参数：</strong></p><pre><code>echo &quot;HelloWorld&quot;ls &gt; test.txttar [参数] 打包文件名 文件</code></pre><h5 id="参数-含义-2"><a href="#参数-含义-2" class="headerlink" title="参数 含义"></a>参数 含义</h5><pre><code>-c 生成档案文件，创建打包文件-x 解开档案文件-z 压缩/解压, 此选项只针对tar.gz为结尾的文件-v 列出归档解档的详细过程，显示进度-t 列出档案中包含的文件-f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</code></pre><p>注意：除了f需要放在参数的最后，其它参数的顺序任意。</p><p><strong>常用命令：</strong></p><pre><code>打包并压缩当前目录所有文件tar -czvf xxx.tar.gz *以.txt结尾的文件tar -czvf xxx.tar.gz *.txt打包指定目录或文件tar -czvf xxx.tar.gz my-file my-dir解压缩包解包到当前目录：tar -xzvf xxx.tar.gz解包到指定目录：tar -xzvf xxx.tar.gz -C my-dir （需要先创建my-dir目录）</code></pre><h3 id="zip、unzip-文件压缩解压"><a href="#zip、unzip-文件压缩解压" class="headerlink" title="zip、unzip 文件压缩解压"></a>zip、unzip 文件压缩解压</h3><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p><p><strong>压缩文件</strong> ：zip [-r] 目标文件(没有扩展名) 源文件</p><pre><code>文件：zip bak * 当前目录所有文件，也可以指定文件文件夹：zip -r bak * 当前目录所有文件&amp;目录递归</code></pre><p><strong>解压文件</strong> ：unzip -d 解压后目录文件 压缩文件</p><pre><code>解压到指定目录：unzip -d ./target_dir bak.zip解压到当前目录：unzip bak.zip</code></pre><h3 id="scp-远程拷贝文件"><a href="#scp-远程拷贝文件" class="headerlink" title="scp 远程拷贝文件"></a>scp 远程拷贝文件</h3><h5 id="从远程复制-文件-到本地"><a href="#从远程复制-文件-到本地" class="headerlink" title="从远程复制 文件 到本地"></a>从远程复制 文件 到本地</h5><h5 id="从本地复制-文件-到远程"><a href="#从本地复制-文件-到远程" class="headerlink" title="从本地复制 文件 到远程"></a>从本地复制 文件 到远程</h5><pre><code>从远程复制 目录 到本地 -rscp root@192.168.16.66:/home/poplar/xxx.tar.gz /home/test/scp /home/test/xxx.png root@192.168.16.66:/home/poplar/从本地复制 目录 到远程 -r</code></pre><h3 id="wget-文件下载"><a href="#wget-文件下载" class="headerlink" title="wget 文件下载"></a>wget 文件下载</h3><h5 id="下载普通文件"><a href="#下载普通文件" class="headerlink" title="下载普通文件"></a>下载普通文件</h5><h5 id="以指定文件名保存文件"><a href="#以指定文件名保存文件" class="headerlink" title="以指定文件名保存文件"></a>以指定文件名保存文件</h5><h5 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h5><h3 id="tree-目录树状结构"><a href="#tree-目录树状结构" class="headerlink" title="tree 目录树状结构"></a>tree 目录树状结构</h3><p>使用tree命令可以查看指定目录的树状结构</p><p>Warning</p><p>有的系统默认未安装tree，需要先使用sudo apt install tree安装后才可以使用tree命令</p><h3 id="which-查看命令位置"><a href="#which-查看命令位置" class="headerlink" title="which 查看命令位置"></a>which 查看命令位置</h3><p>有时我们想知道被执行的命令在哪个目录，以方便切换或更新不同版本，如Python。可以使用which<br>命令</p><pre><code>scp -r root@192.168.16.66:/home/poplar/day01 /home/test/scp -r /home/test/day01 root@192.168.16.66:/home/poplar/wget http://p1.qhimgs4.com/t01ce0387e64e3428ca.jpgwget -O girl.jpg http://p1.qhimgs4.com/t01ce0387e64e3428ca.jpgwget -c http://p1.qhimgs4.com/t01ce0387e64e3428ca.jpgpoplar@PoplarTang:~/Lesson/day01$ tree.├── Test.sh├── TestDir│ └── test.sh├── a│ └── b│ └── c│ └── d│ └── haha.txt├── haha.txt├── hhh.sh├── pics│ ├── 20190213185356_sczsq.jpg│ ├── 20190216212132_uvtxf.thumb.700_0.gif│ └── url-list.txt├── test.txt└── ttt.txt</code></pre><h5 id="命令-含义"><a href="#命令-含义" class="headerlink" title="命令 含义"></a>命令 含义</h5><pre><code>reboot 重新启动操作系统shutdown –r now 重新启动操作系统，shutdown会给别的用户提示shutdown -h now 立刻关机，其中now相当于时间为 0 的状态shutdown -h 20:25 系统在今天的20:25 会关机shutdown -h +10 系统再过十分钟后自动关机</code></pre><h3 id="reboot、shutdown-关机重启"><a href="#reboot、shutdown-关机重启" class="headerlink" title="reboot、shutdown 关机重启"></a>reboot、shutdown 关机重启</h3><h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><h3 id="ping-测试网络是否联通"><a href="#ping-测试网络是否联通" class="headerlink" title="ping 测试网络是否联通"></a>ping 测试网络是否联通</h3><p>可以执行ping baidu.com以查看是否连接了互联网</p><p>可以执行ping 192.168.1.123以查看局域网中的其他设备是否联通</p><h3 id="ifconfig-查看ip地址"><a href="#ifconfig-查看ip地址" class="headerlink" title="ifconfig 查看ip地址"></a>ifconfig 查看ip地址</h3><pre><code>poplar@PoplarTang:~/Lesson$ which python/usr/bin/pythonpoplar@PoplarTang:~/Lesson$ which ls/bin/ls</code></pre><h3 id="ssh-连接远程电脑"><a href="#ssh-连接远程电脑" class="headerlink" title="ssh 连接远程电脑"></a>ssh 连接远程电脑</h3><p>提示是否接受签名证书：输入yes，回车即可.</p><p>如果远程电脑是新装电脑，有可能会因为ssh服务证书问题而无法连接，可以通过在远程电脑上重装ssh<br>服务解决。</p><p><strong>1. 重装ssh服务，生成证书</strong></p><p><strong>修改sshd_config文件，确保可以使用用户名密码连接</strong></p><pre><code>Port 22 #默认即可，如果有端口占用可以自己修改PasswordAuthentication yes # 允许用户名密码方式登录</code></pre><p>**2. 重启ssh服务</p><ol><li>检查sshd服务是否存活**</li></ol><h5 id="4-连接远程电脑"><a href="#4-连接远程电脑" class="headerlink" title="4.连接远程电脑"></a>4.连接远程电脑</h5><pre><code>ssh root@192.168.37.sudo apt-get remove openssh-serversudo apt-get install openssh-serversudo vi /etc/ssh/sshd_configsudo service ssh restartps -e | grep ssh# 或sudo service ssh status[ u/g/o/a ] 含义u user 表示该文件的所有者g group 表示与该文件的所有者属于同一组( group )者，即用户组o other 表示其他以外的人a all 表示这三者皆是</code></pre><h5 id="±-含义"><a href="#±-含义" class="headerlink" title="[ ±&#x2F;&#x3D; ] 含义"></a>[ ±&#x2F;&#x3D; ] 含义</h5><h5 id="增加权限"><a href="#增加权限" class="headerlink" title="+ 增加权限"></a>+ 增加权限</h5><h5 id="撤销权限"><a href="#撤销权限" class="headerlink" title="- 撤销权限"></a>- 撤销权限</h5><h5 id="设定权限"><a href="#设定权限" class="headerlink" title="&#x3D; 设定权限"></a>&#x3D; 设定权限</h5><pre><code>rwx 含义rread 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。w write 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。x excute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。</code></pre><p>提示是否接受签名证书：输入yes，回车</p><h2 id="用户及权限操作"><a href="#用户及权限操作" class="headerlink" title="用户及权限操作"></a>用户及权限操作</h2><h3 id="chmod-修改文件权限"><a href="#chmod-修改文件权限" class="headerlink" title="chmod 修改文件权限"></a>chmod 修改文件权限</h3><p>使用ls -l可以查看文件&amp;目录的权限</p><p>使用chmod可以修改文件权限</p><p>有两种使用格式：字母法与数字法。</p><h4 id="字母法权限修改：rwx"><a href="#字母法权限修改：rwx" class="headerlink" title="字母法权限修改：rwx"></a>字母法权限修改：rwx</h4><pre><code>chmod u/g/o/a +/-/= rwx 文件</code></pre><h5 id="常用的操作如下"><a href="#常用的操作如下" class="headerlink" title="常用的操作如下"></a>常用的操作如下</h5><pre><code>ssh itcast@192.168.150.# 修改一个文件所属用户的权限为可读可写chmod u=rw 1.py# 为文件添加所有人可执行权限chmod a+x 1.py</code></pre><h5 id="字母-说明"><a href="#字母-说明" class="headerlink" title="字母 说明"></a>字母 说明</h5><pre><code>r 读取权限，数字代号为 &quot;4&quot;w 写入权限，数字代号为 &quot;2&quot;x 执行权限，数字代号为 &quot;1&quot;</code></pre><ul><li>不具任何权限，数字代号为 “0”</li></ul><h5 id="如果需要同时进行设定拥有者、同组者以及其他人的权限，参考如下："><a href="#如果需要同时进行设定拥有者、同组者以及其他人的权限，参考如下：" class="headerlink" title="如果需要同时进行设定拥有者、同组者以及其他人的权限，参考如下："></a>如果需要同时进行设定拥有者、同组者以及其他人的权限，参考如下：</h5><h4 id="数字法权限修改：-421"><a href="#数字法权限修改：-421" class="headerlink" title="数字法权限修改： 421"></a>数字法权限修改： 421</h4><p>“rwx” 这些权限也可以用数字来代替</p><p>如执行：chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r filename 就等同于：chmod u&#x3D;7,g&#x3D;5,o&#x3D;4 filename</p><pre><code>chmod 751 file：文件所有者：读、写、执行权限同组用户：读、执行的权限其它用户：执行的权限</code></pre><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><h5 id="如果想递归所有目录加上相同权限，需要加上参数“-R-”。"><a href="#如果想递归所有目录加上相同权限，需要加上参数“-R-”。" class="headerlink" title="如果想递归所有目录加上相同权限，需要加上参数“ -R ”。"></a>如果想递归所有目录加上相同权限，需要加上参数“ -R ”。</h5><p>如：chmod 777 test&#x2F; -R 递归 test 目录下所有文件加 777 权限</p><h3 id="passwd-修改用户密码"><a href="#passwd-修改用户密码" class="headerlink" title="passwd 修改用户密码"></a>passwd 修改用户密码</h3><p>在Unix&#x2F;Linux中，超级用户可以使用passwd命令为普通用户设置或修改用户密码。用户也可以直接使<br>用该命令来修改自己的密码，而无需在命令后面使用用户名。</p><pre><code>非超级用户只能修改自己的密码超级管理员用户root，可以修改其他用户密码</code></pre><h5 id="为了系统安全起见，要使用比较复杂的口令，最好使用-8-位以上的口令，并且口令中包含有大写、小写"><a href="#为了系统安全起见，要使用比较复杂的口令，最好使用-8-位以上的口令，并且口令中包含有大写、小写" class="headerlink" title="为了系统安全起见，要使用比较复杂的口令，最好使用 8 位以上的口令，并且口令中包含有大写、小写"></a>为了系统安全起见，要使用比较复杂的口令，最好使用 8 位以上的口令，并且口令中包含有大写、小写</h5><h5 id="字母和数字"><a href="#字母和数字" class="headerlink" title="字母和数字"></a>字母和数字</h5><h3 id="whoami-我是谁"><a href="#whoami-我是谁" class="headerlink" title="whoami 我是谁"></a>whoami 我是谁</h3><pre><code>whoami可以获取当前登录账户的用户名poplar@PoplarTang:~$ passwdOld password:******New password:*******Re-enter new password:*******root@PoplarTang:/home/poplar# passwd poplarNew password:*******Re-enter new password:*******</code></pre><h3 id="exit-退出登录账户"><a href="#exit-退出登录账户" class="headerlink" title="exit 退出登录账户"></a>exit 退出登录账户</h3><h5 id="如果是图形界面，退出当前终端；"><a href="#如果是图形界面，退出当前终端；" class="headerlink" title="如果是图形界面，退出当前终端；"></a>如果是图形界面，退出当前终端；</h5><pre><code>如果是使用ssh远程登录，退出登陆账户；如果是切换后的登陆用户，退出则返回上一个登陆账号。</code></pre><h3 id="su-切换到普通用户"><a href="#su-切换到普通用户" class="headerlink" title="su 切换到普通用户"></a>su 切换到普通用户</h3><pre><code>su username 切换到username用户，当前路径不变</code></pre><h3 id="sudo-su-切换到管理员账号"><a href="#sudo-su-切换到管理员账号" class="headerlink" title="sudo su 切换到管理员账号"></a>sudo su 切换到管理员账号</h3><pre><code>sudo su 或sudo -s Linux 下切换到root的命令</code></pre><h2 id="系统信息命令"><a href="#系统信息命令" class="headerlink" title="系统信息命令"></a>系统信息命令</h2><h3 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h3><h5 id="发行版本号"><a href="#发行版本号" class="headerlink" title="发行版本号"></a>发行版本号</h5><h5 id="内核版本及系统位数"><a href="#内核版本及系统位数" class="headerlink" title="内核版本及系统位数"></a>内核版本及系统位数</h5><pre><code>内核版本及gcc版本</code></pre><h3 id="查看硬件信息"><a href="#查看硬件信息" class="headerlink" title="查看硬件信息"></a>查看硬件信息</h3><pre><code>cpu信息</code></pre><h5 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h5><h3 id="运行时信息"><a href="#运行时信息" class="headerlink" title="运行时信息"></a>运行时信息</h3><pre><code>top实时CPU&amp;内存使用情况free当前内存占用情况ps -aux查看当前进程状态（CPU、内存占用、开启时间）kill根据进程pid杀死指定进程，可以配合参数- 9 强制杀死</code></pre><h2 id="其他命令手册参考"><a href="#其他命令手册参考" class="headerlink" title="其他命令手册参考"></a>其他命令手册参考</h2><pre><code>su - username`切换到username用户，当前路径变更为`/home/usernamelsb_release -auname -acat /proc/versioncat /proc/cpuinfo` or `lscpusudo dmidecode -t memory</code></pre><p>Linux命令大全：<a href="http://man.linuxde.net/">http://man.linuxde.net/</a></p><p>菜鸟Linux命令：<a href="https://www.runoob.com/linux/linux-command-manual.html">https://www.runoob.com/linux/linux-command-manual.html</a></p><h1 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h1><h2 id="模式及切换"><a href="#模式及切换" class="headerlink" title="模式及切换"></a>模式及切换</h2><h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><h5 id="切换到编辑模式"><a href="#切换到编辑模式" class="headerlink" title="切换到编辑模式"></a>切换到编辑模式</h5><pre><code>i 插入方式进入编辑模式a 追加方式进入编辑模式R 替换方式进入编辑模式o 当前行下一行开始位置开始编辑O 当前行上一行开始位置开始编辑切换到末行模式：输入冒号:编辑模式切换到命令模式：按下esc末行模式切换到命令模式：按下esc</code></pre><h2 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h2><h5 id="在命令模式输入冒号-进入末行模式"><a href="#在命令模式输入冒号-进入末行模式" class="headerlink" title="在命令模式输入冒号:进入末行模式"></a>在命令模式输入冒号:进入末行模式</h5><pre><code>w 保存q 退出x 保存并退出set nu 显示行号set nonu 隐藏行号查找指定字符/anywords按n定位下一个，shfit+n定位上一个</code></pre><h2 id="命令模式-1"><a href="#命令模式-1" class="headerlink" title="命令模式"></a>命令模式</h2><pre><code>在任意状态按下esc进入命令模式复制粘贴yy 复制p 粘贴3yy 复制 3 行2p 粘贴 2 遍剪切dd3dd剪切 3 行撤销u 撤销Ctrl + r 反撤销删除dd 删除当前行dG 删除当前行到文件末尾dH 删除当前行到文件开头基本控制上k下j左h右l锚定符gg跳到当前文档首行G 跳到当前文档末行^ 跳到当前行首$ 跳到当前行尾</code></pre><h2 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h2><pre><code>Shell是一个命令解释器，是用户访问Linux操作系统内核服务的桥梁。分类窗口shell -&gt; gnome, kde， explorer.exe命令行shell -&gt; bash, cmd.exe, powershell.exeshell历史sh -&gt; ksh -&gt; csh -&gt; bash</code></pre><h2 id="Shell-初体验"><a href="#Shell-初体验" class="headerlink" title="Shell-初体验"></a>Shell-初体验</h2><h5 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h5><h5 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h5><pre><code>执行Shell脚本</code></pre><h2 id="Shell脚本（Shell-Script）"><a href="#Shell脚本（Shell-Script）" class="headerlink" title="Shell脚本（Shell Script）"></a>Shell脚本（Shell Script）</h2><pre><code>Shell脚本是为Shell编写的脚本程序Shell命令执行特点： 逐行输入命令，逐行确认</code></pre><h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><pre><code>#!/bin/shecho &quot;Hello world!&quot;echo &quot;666&quot;chmod +x test.sh./test.shorsh ./test.sh</code></pre><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>使用source执行加载shell脚本，可以保证环境一致性，将shell脚本中定义的环境变量在当前环境也生<br>效。</p><h1 id="Shell-基本语法"><a href="#Shell-基本语法" class="headerlink" title="Shell 基本语法"></a>Shell 基本语法</h1><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><h5 id="注意等号左右两边-不能有空格"><a href="#注意等号左右两边-不能有空格" class="headerlink" title="注意等号左右两边 不能有空格"></a>注意等号左右两边 不能有空格</h5><p>机器人端自动运行脚本：lidar_nav_sh.sh</p><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><pre><code>$(cd dirname $0;pwd)在命令行状态下单纯执行 $ cd dirname $0 是毫无意义的。因为他返回当前路径的&quot;.&quot;。* 这个命令写在脚本文件里才有作用，他返回这个脚本文件放置的目录，并可以根据这个目录来定位所要运行程序的相对位置（绝对位置除外）。 *比如在/home/itcast/test/下新建test.sh内容如下：1.1. 命名：要有意义，eg. `xxx.sh`2. 首行：必须是命令解释器 eg. `#!/bin/bash`3. 注释：简单描述脚本信息 eg. `# 测试命令输入`4. 执行：`sh 脚本文件.sh` or `bash 脚本文件.sh` or `./xxx.sh`5. 规范：成对符号成对写 `() [] &#123;&#125; &quot;&quot; `source xxx.sh#!/bin/bashCURRENT=$(cd `dirname $0`; pwd)IP=`ifconfig labornet | grep &quot;inet addr:&quot; | awk &#39;&#123;print $2&#125;&#39; | cut -c 6-`source /opt/ros/kinetic/setup.bashsource /root/catkin_ws/devel/setup.bashexport ROS_MASTER_URI=http://$IP:11311/export ROS_IP=$IPcd $CURRENTrm slam.logstdbuf -oL roslaunch $CURRENT/lidar_nav.launch &amp;&gt; $CURRENT/slam.log#roslaunch $CURRENT/slam.launch &gt;&gt;$CURRENT/slam.logcd `dirname $0`echo `pwd````shell#然后返回到/home/itcast 执行sh test/test.sh</code></pre><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h5><h5 id="这样就可以知道一些和脚本一起部署的文件的位置了，只要知道相对位置就可以根据这个目录来"><a href="#这样就可以知道一些和脚本一起部署的文件的位置了，只要知道相对位置就可以根据这个目录来" class="headerlink" title="这样就可以知道一些和脚本一起部署的文件的位置了，只要知道相对位置就可以根据这个目录来"></a>这样就可以知道一些和脚本一起部署的文件的位置了，只要知道相对位置就可以根据这个目录来</h5><h5 id="定位，而可以不用关心绝对位置。这样脚本的可移植性就提高了，扔到任何一台服务器，（如果"><a href="#定位，而可以不用关心绝对位置。这样脚本的可移植性就提高了，扔到任何一台服务器，（如果" class="headerlink" title="定位，而可以不用关心绝对位置。这样脚本的可移植性就提高了，扔到任何一台服务器，（如果"></a>定位，而可以不用关心绝对位置。这样脚本的可移植性就提高了，扔到任何一台服务器，（如果</h5><h5 id="是部署脚本）都可以执行。"><a href="#是部署脚本）都可以执行。" class="headerlink" title="是部署脚本）都可以执行。"></a>是部署脚本）都可以执行。</h5><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h5 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h5><h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><h2 id="Shell变量-1"><a href="#Shell变量-1" class="headerlink" title="Shell变量 1"></a>Shell变量 1</h2><h5 id="存储动态值的抽象概念；变量名不变，变量值可变"><a href="#存储动态值的抽象概念；变量名不变，变量值可变" class="headerlink" title="存储动态值的抽象概念；变量名不变，变量值可变"></a>存储动态值的抽象概念；变量名不变，变量值可变</h5><h5 id="变量分类-："><a href="#变量分类-：" class="headerlink" title="变量分类 ："></a>变量分类 ：</h5><h5 id="本地变量：在本地有效"><a href="#本地变量：在本地有效" class="headerlink" title="本地变量：在本地有效"></a>本地变量：在本地有效</h5><h5 id="全局变量：在当前系统下，所有环境都有效"><a href="#全局变量：在当前系统下，所有环境都有效" class="headerlink" title="全局变量：在当前系统下，所有环境都有效"></a>全局变量：在当前系统下，所有环境都有效</h5><pre><code>内置变量：bash中默认包含一些变量，可直接使用</code></pre><h3 id="本地变量¶"><a href="#本地变量¶" class="headerlink" title="本地变量¶"></a>本地变量¶</h3><h4 id="普通变量¶"><a href="#普通变量¶" class="headerlink" title="普通变量¶"></a>普通变量¶</h4><h5 id="变量名-变量值：变量值必须是一个整体，中间不能有特殊字符"><a href="#变量名-变量值：变量值必须是一个整体，中间不能有特殊字符" class="headerlink" title="变量名&#x3D;变量值：变量值必须是一个整体，中间不能有特殊字符"></a>变量名&#x3D;变量值：变量值必须是一个整体，中间不能有特殊字符</h5><h5 id="变量名-’变量值’：看到的内容和输出的内容一致"><a href="#变量名-’变量值’：看到的内容和输出的内容一致" class="headerlink" title="变量名&#x3D;’变量值’：看到的内容和输出的内容一致"></a>变量名&#x3D;’变量值’：看到的内容和输出的内容一致</h5><h5 id="变量名-”变量值”：如果在变量A的变量值范围内，有可以解析的变量B，那么就首先解析变量B，"><a href="#变量名-”变量值”：如果在变量A的变量值范围内，有可以解析的变量B，那么就首先解析变量B，" class="headerlink" title="变量名&#x3D;”变量值”：如果在变量A的变量值范围内，有可以解析的变量B，那么就首先解析变量B，"></a>变量名&#x3D;”变量值”：如果在变量A的变量值范围内，有可以解析的变量B，那么就首先解析变量B，</h5><pre><code>将B的结果和其他内容组合后，再赋值给A eg./home/itcast/test# 我是单行注释#第一种 &lt;&lt; EOF&lt;&lt; EOFyour comment 1comment 2blahEOF&lt;&lt; EOF这里是多行注释!作者：poplar时间： 2019 年 5 月 5 日20:53:21联系：xxx@itcast.cnEOF#第二种 即 : + 空格 + 单引号, 不推荐: &#39;这里是多行注释!作者：poplar时间： 2019 年 5 月 5 日20:53:21联系：xxx@itcast.cn&#39;</code></pre><h4 id="命令变量"><a href="#命令变量" class="headerlink" title="命令变量"></a>命令变量</h4><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><h5 id="注意等号左右两边-不能有空格-1"><a href="#注意等号左右两边-不能有空格-1" class="headerlink" title="注意等号左右两边 不能有空格"></a>注意等号左右两边 不能有空格</h5><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><h5 id="1-、执行命令"><a href="#1-、执行命令" class="headerlink" title="1 、执行命令"></a>1 、执行命令</h5><h5 id="2-、将命令执行后的结果，赋值给变量名"><a href="#2-、将命令执行后的结果，赋值给变量名" class="headerlink" title="2 、将命令执行后的结果，赋值给变量名"></a>2 、将命令执行后的结果，赋值给变量名</h5><p><strong>eg.</strong></p><h4 id="如何查看变量"><a href="#如何查看变量" class="headerlink" title="如何查看变量"></a>如何查看变量</h4><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h5 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h5><h5 id="定义一个本地变量"><a href="#定义一个本地变量" class="headerlink" title="定义一个本地变量"></a>定义一个本地变量</h5><pre><code>使用export声明这个本地变量为全局变量1. 如果export在一个文件中，则需要使用source filename.sh使其生效2. 删除变量：poplar@PoplarTang:~/Lesson$ val_b=itcastpoplar@PoplarTang:~/Lesson$ val_a=&#39;hello $val_b&#39;poplar@PoplarTang:~/Lesson$ echo $val_ahello $val_bpoplar@PoplarTang:~/Lesson$ val_a=&quot;hello $val_b&quot;poplar@PoplarTang:~/Lesson$ echo $val_ahello itcast变量名=`命令`变量名=$(命令)aa=&#39;ls&#39;$aawo=$(whoami)echo $woecho $变量名echo &quot;aaa $&#123;变量名&#125; bbb ccc&quot;itcast1=haha666export itcast1# 合并为 1 步export itcast2=test123env | grep itcast# outputitcast2=test123itcast1=haha666</code></pre><h5 id="系统全局变量："><a href="#系统全局变量：" class="headerlink" title="系统全局变量："></a>系统全局变量：</h5><p>在vim ~&#x2F;.bashrc文件添加一下类似命令：</p><pre><code>unset itcast1export itcast2=test123</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> -- 大三下ros操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240310224320764.png" alt="image-20240310224320764"></p><p><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240310224455685.png" alt="image-20240310224455685"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>离散数学</title>
      <link href="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
      <url>/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227224910888-1709045351667-5.png" alt="image-20240227224910888"></p><p><img src="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227224918298.png" alt="image-20240227224918298"></p><h2 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h2><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227225800164.png" alt="image-20240227225800164"></p><p><img src="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227225806982.png" alt="image-20240227225806982"></p><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227225426319.png" alt="image-20240227225426319"></p><p><img src="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227225426319.png" alt="image-20240227225426319"></p><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227230954624.png" alt="image-20240227230954624"></p><p><img src="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227231001739.png" alt="image-20240227231001739"></p><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227231021534.png" alt="image-20240227231021534"></p><p><img src="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227231023100.png" alt="image-20240227231023100"></p><p>命题联结词</p><blockquote><p><strong>否定，合取，析取，蕴含(条件)、等值</strong></p></blockquote><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227225920996.png" alt="image-20240227225920996"></p><p><img src="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227225925163.png" alt="image-20240227225925163"></p><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227225942300.png" alt="image-20240227225942300"></p><p><img src="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227225946119.png" alt="image-20240227225946119"></p><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227234831447.png" alt="image-20240227234831447"></p><p><img src="/2024/02/27/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240227234833876.png" alt="image-20240227234833876"></p><p>需要注意的有：</p><ol><li>条件（蕴含）：当且仅当 P 为真，Q 为假时，P→Q 为假；否则， P→Q 均为真。<br>条件 → 决定了哪个作为前件，哪个作为后件。</li><li>双条件（等值）：当且仅当P、Q相同的时候，P↔Q为真，否则为假。</li><li>优先级：</li></ol><blockquote><p>否定 &gt; 合取 &gt; 析取 &gt; 条件 &gt; 双条件</p></blockquote><p><img src="/./%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/image-20240228000539248.png" alt="image-20240228000539248"></p><h2 id="一阶逻辑"><a href="#一阶逻辑" class="headerlink" title="一阶逻辑"></a>一阶逻辑</h2><h2 id="集合的基本概念和运算"><a href="#集合的基本概念和运算" class="headerlink" title="集合的基本概念和运算"></a>集合的基本概念和运算</h2><h2 id="二元关系和函数"><a href="#二元关系和函数" class="headerlink" title="二元关系和函数"></a>二元关系和函数</h2><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h2 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java基础知识总结</title>
      <link href="/2024/02/02/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2024/02/02/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/02/02/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/image.png" alt="image"></p><p><img src="/2024/02/02/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/image1.png" alt="image1"></p><p><img src="/2024/02/02/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/image2.png" alt="image2"></p><p><img src="/2024/02/02/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/image3.png" alt="image3"></p><p><img src="/2024/02/02/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/image4.png" alt="image4"></p>]]></content>
      
      
      
        <tags>
            
            <tag> --java基础总结（全点） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥总结</title>
      <link href="/2024/01/31/%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/31/%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="输入模板"><a href="#输入模板" class="headerlink" title="输入模板"></a>输入模板</h1><pre><code class="java">import java.util.Scanner;public class Oj &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        // 输入字符串        String str = scanner.next(); // 读取输入的字符串        // 读取整行输入        String line = scanner.nextLine();        // 输入基本类型        int num = scanner.nextInt(); // 读取输入的整数    &#125;&#125;</code></pre><p><img src="/./%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/662E827A-FA32-4464-B0BD-40087F429E98.jpg" alt="img"></p><p><img src="/2024/01/31/%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/662E827A-FA32-4464-B0BD-40087F429E98-1706786300306-3.jpg" alt="img"></p><h1 id="输出模板"><a href="#输出模板" class="headerlink" title="输出模板"></a>输出模板</h1><pre><code class="java">public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int num = scanner.nextInt();        //输出//使用System.out.println()方法：        System.out.println(&quot;Hello, World!&quot;);//使用System.out.print()方法：        System.out.print(&quot;Hello, World!&quot;);//使用System.out.printf()方法进行格式化输出：        System.out.printf(&quot;The number is: %d&quot;, num);    &#125;&#125;</code></pre><h1 id="格式化输出详细介绍"><a href="#格式化输出详细介绍" class="headerlink" title="格式化输出详细介绍"></a>格式化输出详细介绍</h1><p>System.out.format(); System.out.printf();<br>俩者用法一致，下面以format举例说明。<br>当我们需要格式化输出一些数据，只是使用System.out.println();就有点不够用了，这时就需要用到format方法了</p><p>System.out提供了格式化的输出方法format，format的第一个参数是一个模板，模板面有一些占位符，再通过后面的参数替换模板中的占位符完成整个信息的输出</p><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><p>常用占位符：</p><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td>%d</td><td>格式化输出整数</td></tr><tr><td>%f</td><td>格式化输出浮点数</td></tr><tr><td>%e</td><td>格式化科学计数法的浮点数</td></tr><tr><td>%s</td><td>格式化输出字符串</td></tr></tbody></table><pre><code class="java">        int x=5;        System.out.println(&quot;x=&quot;+x);        String name=&quot;LiLi&quot;;        int age=8;        char sex=&#39;男&#39;;        double grade=28.8;        System.out.format(&quot;姓名:%s, 年龄:%d, 性别:%c, 成绩:%.1f\n&quot;, name, age, sex, grade);</code></pre><p>其中%c,%s等就叫做占位符，分别代表字符和字符串，它们将被后边出现的对应的变量的值替换掉。像%.1f是%f中又添加了.f 表示输出一个1位的小数。</p><h3 id="fomat"><a href="#fomat" class="headerlink" title="fomat"></a>fomat</h3><p>format 是一个用于格式化字符串的函数或方法，它可以在程序中将变量的值插入到字符串中，从而得到一个格式化后的字符串。</p><h3 id="格式化整数"><a href="#格式化整数" class="headerlink" title="格式化整数"></a>格式化整数</h3><p>既可以格式化基本数据类型，也可以格式化它们的包装类</p><pre><code>%d :格式化十进制整数%o :格式化八进制整数%x :格式化小写十六进制整数，如：abc58%X :格式化大写十六进制整数，如：ABC58</code></pre><p>修饰符</p><pre><code>“+”：格式化正整数时强制添加上正好，如%+d可将123格式化位+123“,”：格式化整数时按“千”分组，例如：%,d可将1234567890格式化位1,234,567,890它俩可以组合使用，如：%+,d</code></pre><p>数据的宽度</p><pre><code>%md或%-md指定格式化整数的长度最少为m如%6d可将123格式化为“ 123”，左边三个空格，即如果数字的长度不足6，则在格式化的数字左边添加空格使得整体长度为6（左边添加空格即右对齐）%-6d使得结果左对齐，即在右边添加空格，如%-6d可将123格式化为“123 ”，右边三个空格</code></pre><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code class="java">//格式化字符串        int n = 500000000;        System.out.format(&quot;     500000000的八进制整数:%o&quot;,n);//八进制整数        System.out.format(&quot;     500000000的十进制整数:%d&quot;,n);//十进制整数        System.out.format(&quot;     500000000的十六进制整数小写:%x&quot;,n);//十六进制整数小写        System.out.format(&quot;     500000000的十六进制整数大写:%X&quot;,n);//十六进制整数大写        System.out.println();        System.out.println(&quot;    ---修饰符---&quot;);        System.out.format(&quot;     500000000的格式化正整数:%+d&quot;,n);        System.out.format(&quot;     500000000的格式化分组整数:%+,d&quot;,n);        System.out.println(&quot;    ---数据的宽度---&quot;);        int n1 = 123;        System.out.format(&quot;     左对齐%-6d&quot;,n1);</code></pre><p><img src="/./%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/image-20240201190927852.png" alt="image-20240201190927852"></p><p><img src="/2024/01/31/%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/image-20240201190939191.png" alt="image-20240201190939191"></p><h3 id="格式化浮点数"><a href="#格式化浮点数" class="headerlink" title="格式化浮点数"></a>格式化浮点数</h3><p>既可以格式化基本数据类型，也可以格式化它们的包装类</p><p>修饰符</p><pre><code>“+” ：格式化正数时添加正号“,”：将正数部分按千分位它俩可以组合使用，如：%+,f</code></pre><p>限制小数位数与宽度</p><pre><code>“%.nf”可以限制小数的位数为n（遵循四舍五入）“%mf”可以规定数据的宽度为m，长度不足补空格，默认居右（%-mf，居左）组合使用：System.out.printf(&quot;%7.3f&quot;,0.1235);结果：0.124 （还有俩个空格，“.”也占一个长度）</code></pre><h1 id="基本数据类型和字符串"><a href="#基本数据类型和字符串" class="headerlink" title="基本数据类型和字符串"></a>基本数据类型和字符串</h1><h3 id="1-常用基本数据类型"><a href="#1-常用基本数据类型" class="headerlink" title="1.常用基本数据类型"></a>1.常用基本数据类型</h3><table><thead><tr><th>数据类型</th><th>内存</th><th>取值（十进制）</th></tr></thead><tbody><tr><td>int</td><td>32位</td><td>-10^10~10^10</td></tr><tr><td>long</td><td>64位</td><td>-10^19~10^19</td></tr><tr><td>double</td><td>64位</td><td>4.9<em>10^-324~1.79</em>10^3084.9E-324~1.79E308</td></tr><tr><td>char</td><td>16位</td><td></td></tr><tr><td>boolean</td><td>1位</td><td></td></tr></tbody></table><h3 id="Java的八种基本类型：（按字节来分）"><a href="#Java的八种基本类型：（按字节来分）" class="headerlink" title="Java的八种基本类型：（按字节来分）"></a>Java的八种基本类型：（按字节来分）</h3><p>boolean  布尔型  1个字节 8bit（8位）</p><p>byte   字节类型  1个字节</p><p>char   字符类型  2个字节</p><p>short   短整型   2个字节</p><p>int     整型    4个字节</p><p>float   浮点型（单精度）4个字节</p><p>long   长整型   8个字节</p><p>double  双精度类型 8个字节</p><p>Java中默认的整数类型是int，如果要定义为long ，则要在数值后加上L或者l</p><p>默认的浮点型是双精度浮点，如果要定义float，则要在数值后面加上f或者F</p><p>一个字节等于8位，1个字节等于256个数。2^8</p><p>一个英文字母或者阿拉伯数字占一个字节</p><p>一个汉字占2个字节</p><table><thead><tr><th align="left"><strong>数据类型</strong></th><th align="left"><strong>默认值</strong></th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">0</td></tr><tr><td align="left">short</td><td align="left">0</td></tr><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">0L</td></tr><tr><td align="left">float</td><td align="left">0.0f</td></tr><tr><td align="left">double</td><td align="left">0.0d</td></tr><tr><td align="left">char</td><td align="left">‘u0000’</td></tr><tr><td align="left">String (or any object)</td><td align="left">null</td></tr><tr><td align="left">boolean</td><td align="left">false</td></tr></tbody></table><h3 id="2-字符串（String类）"><a href="#2-字符串（String类）" class="headerlink" title="2.字符串（String类）"></a>2.字符串（String类）</h3><h4 id="（1）创建"><a href="#（1）创建" class="headerlink" title="（1）创建"></a>（1）创建</h4><pre><code class="java">String str=new String();//为什么不用实例化可以使用String类？//String底层是通过string数据类型实现的String str=&quot;&quot;;</code></pre><h4 id="（2）操作方法"><a href="#（2）操作方法" class="headerlink" title="（2）操作方法"></a>（2）操作方法</h4><pre><code class="java">// 连接字符串和其他类型String s1 = &quot;Hello&quot;;String s2 = &quot;World&quot;;String str1 = s1 + s2;      // 与字符串连接int in = 42;String str2 = in + s1;      // 与int类型连接String str3 = String.valueOf(in); // int转String// 注意：以下这行是错误的，需要使用String.valueOf方法或者直接将int转换为String// String str4 = in;// 获取信息// 1. 长度int length = str1.length();// 2. 查找字符串int indexOfA = str1.indexOf(&quot;a&quot;);               // 查找字符串a首次出现的位置int lastIndexOfA = str1.lastIndexOf(&quot;a&quot;);       // 查找字符串a最后出现的位置int indexOfAB = str1.indexOf(&quot;ab&quot;);             // 查找字符串ab首次出现的位置int lastIndexOfAB = str1.lastIndexOf(&quot;ab&quot;);     // 查找字符串ab最后出现的位置// 3. 获取和截取字符串String subStr1 = str1.substring(3);            // 获取索引为3(包含)~length(不包含)的字符串String subStr2 = str1.substring(3, 6);         // 获取索引为3(包含)~6(不包含)的字符串// 4. 字符串的替换String replacedStr = str1.replace(&quot;a&quot;, &quot;A&quot;);   // 将字符串str1中的a替换为A// 5. 判断字符串的开头或结尾boolean startsWith = str1.startsWith(&quot;Hello&quot;); // 以&quot;Hello&quot;开头返回true，否则falseboolean endsWith = str1.endsWith(&quot;World&quot;);      // 以&quot;World&quot;结尾返回true，否则false// 6. 判断字符串是否相等boolean isEqual = str1.equals(&quot;HelloWorld&quot;);    // 相等返回true，否则false// 7. 字符串比较（按字典顺序）int compareResult = str1.compareTo(&quot;Abc&quot;);     // 比较str1和&quot;Abc&quot;，返回正整数、0、负整数// 8. 字符串的大小写转换String lowerCaseStr = str1.toLowerCase();     // 转换为小写String upperCaseStr = str1.toUpperCase();     // 转换为大写// 9. 字符串的分割String[] arr1 = str1.split(&quot;/&quot;);               // 使用&#39;/&#39;分割字符串String[] arr2 = str1.split(&quot;\\.&quot;);             // 使用&#39;.&#39;分割字符串（&#39;.&#39;是特殊字符需要使用双反斜杠转义）// 注意：除了&#39;.&#39;和&#39;|&#39;等特殊字符，通常不需要额外转义。</code></pre><h3 id="3-数据类型转换"><a href="#3-数据类型转换" class="headerlink" title="3.数据类型转换"></a>3.数据类型转换</h3><pre><code class="java">//1基本数据类型转String类in+&quot;&quot;;//int转String，其他同理//2包装类转String类i.toString();//Integer类转String//String类转基本数据类型和包装类Integer.parseInt(str);//String转int型或Integer,其他同理</code></pre><p>在Java中，您可以使用不同的方式进行数据类型转换，具体取决于您需要执行的转换类型和情况。以下是一些常见的数据类型转换示例：</p><ol><li>隐式类型转换（自动类型转换）： 隐式类型转换是指将一个小范围的数据类型转换为一个大范围的数据类型，这种转换是自动进行的，不需要特殊操作。例如，将一个整数转换为浮点数：</li></ol><pre><code class="java">int myInt = 10;double myDouble = myInt; // 隐式类型转换，将int转换为double</code></pre><ol><li>显式类型转换（强制类型转换）： 显式类型转换是指将一个大范围的数据类型转换为一个小范围的数据类型，这种转换需要使用强制类型转换运算符（例如<code>(类型)</code>）进行。需要注意的是，在这种情况下可能会发生数据丢失。例如，将一个浮点数转换为整数：</li></ol><pre><code class="java">double myDouble = 10.5;int myInt = (int) myDouble; // 显式类型转换，将double转换为int，小数部分被截断</code></pre><ol><li>使用包装类进行转换： 对于基本数据类型，您可以使用包装类来进行类型转换。例如，将字符串转换为整数：</li></ol><pre><code class="java">String str = &quot;123&quot;;int myInt = Integer.parseInt(str); // 使用Integer包装类的parseI</code></pre><ol><li>基本数据类型转换为String类：</li></ol><pre><code class="java">int myInt = 42;String intAsString = myInt + &quot;&quot;; // int转String</code></pre><ol><li>包装类转换为String类：</li></ol><pre><code class="java">Integer myInteger = 123;String integerAsString = myInteger.toString(); // Integer类转String</code></pre><ol><li>String类转换为基本数据类型和包装类：</li></ol><pre><code class="java">String str = &quot;456&quot;;int strAsInt = Integer.parseInt(str); // String转intInteger strAsInteger = Integer.valueOf(str); // String转Integer</code></pre><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ol><li><p>二维数组是最常见的多维数组形式。它可以看作是行和列的矩阵，每个元素由两个索引来确定。</p><p>声明和创建二维数组的语法如下：</p><pre><code class="java">dataType[][] arrayName = new dataType[rows][columns];</code></pre><p>其中，<code>dataType</code> 是数组元素的数据类型，<code>rows</code> 表示行数，<code>columns</code> 表示列数。</p><p>示例：</p><pre><code class="java">int[][] matrix = new int[3][4]; // 创建一个3行4列的二维整数数组</code></pre></li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li><p>初始化二维数组： 二维数组可以通过嵌套的循环进行初始化，或者使用静态初始化方法，将初始值直接赋给数组元素。</p><p>静态初始化示例：</p><pre><code class="java">int[][] matrix = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;</code></pre></li><li><p>访问二维数组元素： 使用两个索引来访问二维数组中的元素，一个索引表示行号，另一个表示列号。例如：</p><pre><code class="java">int value = matrix[1][2]; // 访问第2行第3列的元素，值为6</code></pre></li><li><p>多维数组： Java也支持更高维度的数组，例如三维数组、四维数组等。其声明和访问方式类似，只是需要使用多个索引来访问元素。</p><p>示例：</p><pre><code class="java">int[][][] threeDimensionalArray = new int[2][3][4]; // 创建一个2x3x4的三维整数数组int value = threeDimensionalArray[1][2][3]; // 访问第2个二维数组中的第3</code></pre></li></ol><pre><code class="java">public class ArrayExample &#123;    public static void main(String[] args) &#123;        // 声明和创建数组        int[] numbers = new int[5];                // 初始化数组元素        numbers[0] = 1;        numbers[1] = 2;        numbers[2] = 3;        numbers[3] = 4;        numbers[4] = 5;                // 访问数组元素并打印        for (int i = 0; i &lt; numbers.length; i++) &#123;            System.out.print(numbers[i] + &quot; &quot;);        &#125;        System.out.println(); // 换行                // 使用增强型for-each循环遍历数组元素并打印        for (int num : numbers) &#123;            System.out.print(num + &quot; &quot;);        &#125;        System.out.println(); // 换行                // 创建和处理多维数组（二维数组）        int[][] matrix = new int[3][3];        int value = 1;        for (int i = 0; i &lt; 3; i++) &#123;            for (int j = 0; j &lt; 3; j++) &#123;                matrix[i][j] = value;                value++;            &#125;        &#125;                // 打印二维数组        for (int i = 0; i &lt; 3; i++) &#123;            for (int j = 0; j &lt; 3; j++) &#123;                System.out.print(matrix[i][j] + &quot; &quot;);            &#125;            System.out.println(); // 换行        &#125;                // 使用Arrays类的方法        int[] sortedArray = &#123;5, 2, 9, 1, 5, 6&#125;;        Arrays.sort(sortedArray); // 排序数组        System.out.println(&quot;Sorted Array: &quot; + Arrays.toString(sortedArray));                int[] newArray = Arrays.copyOf(sortedArray, 4); // 复制数组        System.out.println(&quot;Copied Array: &quot; + Arrays.toString(newArray));    &#125;&#125;</code></pre><h2 id="增强性for-each循环"><a href="#增强性for-each循环" class="headerlink" title="增强性for-each循环"></a>增强性for-each循环</h2><p>增强型for循环，是Java编程语言中的一种语法结构，用于遍历数组、集合和其他可迭代对象的元素，以简化代码编写和提高可读性。它在Java 5及更高版本中引入，是一种迭代集合的更方便的方式。</p><p>增强型for-each循环的语法如下：</p><pre><code class="java">for (elementType element : iterable) &#123;    // 执行操作，使用element访问当前元素&#125;</code></pre><p>其中：</p><ul><li><code>elementType</code> 是集合中元素的数据类型。</li><li><code>element</code> 是循环的变量，它代表当前迭代的元素。</li><li><code>iterable</code> 是要遍历的集合、数组或其他可迭代对象。</li></ul><p>使用增强型for-each循环，您可以逐个访问集合中的元素，而不需要手动管理索引或使用传统的for循环。这可以减少编码错误，提高代码的可读性，并使代码更加简洁。</p><p>以下是一个使用增强型for-each循环遍历数组的示例：</p><pre><code class="java">int[] numbers = &#123;1, 2, 3, 4, 5&#125;;for (int num : numbers) &#123;    System.out.println(num);&#125;</code></pre><p>这段代码会依次打印数组<code>numbers</code>中的每个元素，不需要显式指定索引。增强型for-each循环适用于大多数需要遍历集合或数组的情况，并且使代码更易读和维护。</p><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="1-常用包装类"><a href="#1-常用包装类" class="headerlink" title="1.常用包装类"></a>1.常用包装类</h2><pre><code class="java">1.Integer 2.Long 3.Boolean 4.Character 5.Double注意：必须分配内存空间才能使用Integer in=new Integer(&quot;0&quot;);</code></pre><h2 id="2-包装类常用的方法"><a href="#2-包装类常用的方法" class="headerlink" title="2.包装类常用的方法"></a>2.包装类常用的方法</h2><pre><code class="java">//1.比较值大小in.compareTo(otherin);//in&gt;otherin返回正值,in=otherin返回0,in&lt;other返回负值//2.返回一个字符串in.toString();//可转换为字符串//3.返回包装类对象Integer in=Integer.valueOf(33);//返回一个Integer对象//4.以基本类型返回包装类对象Integer in=new Integer(&quot;33&quot;);int i=in.intValue();//5.对象的比较in.equals(otherin);//相等则返回true,否则false//常数Integer.MAX_VALUE;//2^31-1;Integer.MIN_VALUE;//-2^31;</code></pre><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>Java包装类是一种用于将基本数据类型转换为对象的类。它们提供了一种将基本数据类型（如int、double、boolean等）封装为对象的方式，以便可以在需要时进行对象操作。以下是Java包装类的一些常见用法示例：</p><h3 id="自动装箱和拆箱："><a href="#自动装箱和拆箱：" class="headerlink" title="自动装箱和拆箱："></a>自动装箱和拆箱：</h3><p>自动装箱是将基本数据类型自动转换为包装类对象的过程，而拆箱是将包装类对象自动转换回基本数据类型的过程。这些操作在Java 5及更高版本中引入。</p><pre><code class="java">// 自动装箱Integer num = 10; // 将整数10自动装箱为Integer对象// 拆箱int value = num; // 将Integer对象num自动拆箱为基本整数类型</code></pre><h3 id="使用包装类进行类型转换："><a href="#使用包装类进行类型转换：" class="headerlink" title="使用包装类进行类型转换："></a>使用包装类进行类型转换：</h3><p>包装类提供了方法来进行类型转换，例如将字符串转换为整数或将整数转换为字符串。</p><pre><code class="java">// 将字符串转换为整数String str = &quot;123&quot;;int intValue = Integer.parseInt(str);// 将整数转换为字符串int num = 456;String strValue = Integer.toString(num);</code></pre><h3 id="包装类的常用方法："><a href="#包装类的常用方法：" class="headerlink" title="包装类的常用方法："></a>包装类的常用方法：</h3><p>包装类提供了许多常用的方法，例如比较、取值范围、转换等。以下是一些示例：</p><pre><code class="java">Integer a = 5;Integer b = 10;int max = Integer.max(a, b); // 获取两个整数中的最大值int min = Integer.min(a, b); // 获取两个整数中的最小值boolean isEqual = a.equals(b); // 比较两个整数是否相等int intValue = a.intValue(); // 获取Integer对象的整数值</code></pre><h3 id="使用包装类处理特殊值："><a href="#使用包装类处理特殊值：" class="headerlink" title="使用包装类处理特殊值："></a>使用包装类处理特殊值：</h3><p>包装类可以用来表示特殊值，例如<code>null</code>或<code>NaN</code>（不是一个数字）。</p><pre><code class="java">Integer nullValue = null; // 表示空值Double nanValue = Double.NaN; // 表示不是一个数字</code></pre><h1 id="数据处理类"><a href="#数据处理类" class="headerlink" title="数据处理类"></a>数据处理类</h1><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><pre><code class="java">//1.常用的数字常量Math.PI;//常量π//2.指数函数Math.exp(a);//返回e^aMath.sqrt(a);//返回a的平方根Math.cbrt(a);//返回a的立方根Math.pow(a,b);//返回a^b//3.取值Math.max(a,b);//返回a,b当中的最大值Math.min(a,b);//返回a,b当中的最小值Math.abs(a);//返回a的绝对值//4.取整Math.floor(a);//向下取整:5.5-&gt;5Math.ceil(a);//向上取整:5.5-&gt;6Math.rint(a);//四舍五入,返回doubleMath.round(a);//四舍五入,返回int或long(输入float或double)</code></pre><p>2.大数字类</p><pre><code class="java">//注意：使用时必须分配内存，因为是类//大整数类//1.常数BigInteger.ONE;BigInteger.ZERO;BigInteger.valueOf(long a);//2.创建BigInteger Big=new BigInteger(&quot;2&quot;);BigInteger Big=常数;//3.运算Big.add(otherBig);        //加Big.subtract(otherBig);   //减Big.multiply(otherBig);   //乘Big.divide(otherBig);     //除Big.remainder(yushu);Big.mod(yushu);//取模或取余，正数时没区别//4.取值Big.max(otherBig);        //返回两数之间最大值Big.min(otherBig);        //返回两数之间最小值</code></pre><pre><code class="java"> public static void main(String[] args) &#123;        // Math类示例        double pi = Math.PI; // 常量π        double expResult = Math.exp(2.0); // 返回e^2        double sqrtResult = Math.sqrt(25.0); // 返回25的平方根        double cbrtResult = Math.cbrt(8.0); // 返回8的立方根        double powResult = Math.pow(2.0, 3.0); // 返回2^3        int maxResult = Math.max(5, 10); // 返回5和10中的最大值        int minResult = Math.min(5, 10); // 返回5和10中的最小值        double absResult = Math.abs(-7.5); // 返回-7.5的绝对值        double floorResult = Math.floor(5.5); // 向下取整，结果为5.0        double ceilResult = Math.ceil(5.5); // 向上取整，结果为6.0        double rintResult = Math.rint(5.5); // 四舍五入，结果为6.0        long roundResult = Math.round(5.5); // 四舍五入，结果为6        // BigInteger和BigDecimal示例        BigInteger bigInt1 = new BigInteger(&quot;123456789012345678901234567890&quot;);        BigInteger bigInt2 = BigInteger.valueOf(987654321098765432109876543210);        BigInteger sum = bigInt1.add(bigInt2); // 加法        BigInteger difference = bigInt1.subtract(bigInt2); // 减法        BigInteger product = bigInt1.multiply(bigInt2); // 乘法        BigInteger quotient = bigInt1.divide(bigInt2); // 除法        BigInteger remainder = bigInt1.remainder(bigInt2); // 取余        BigDecimal bigDecimal1 = new BigDecimal(&quot;123.456&quot;);        BigDecimal bigDecimal2 = BigDecimal.valueOf(987.654);        BigDecimal sumDecimal = bigDecimal1.add(bigDecimal2); // 加法        BigDecimal differenceDecimal = bigDecimal1.subtract(bigDecimal2); // 减法        BigDecimal productDecimal = bigDecimal1.multiply(bigDecimal2); // 乘法        BigDecimal quotientDecimal = bigDecimal1.divide(bigDecimal2, 2, BigDecimal.ROUND_HALF_UP); // 除法，保留2位小数，四舍五入    &#125;</code></pre><p><img src="/./%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/image-20240201214626576.png" alt="image-20240201214626576"></p><p><img src="/2024/01/31/%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/image-20240201214630775.png" alt="image-20240201214630775"></p><h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><pre><code class="java">Collection的子接口有List和Set//常用方法add(e);        //添加元素remove(e);     //删除元素clear();       //清空集合isEmpty();     //返回boolean判断集合里全部元素是否为空iterator();    //用于遍历size();        //返回int,获取集合元素个数</code></pre><h3 id="（1）List接口"><a href="#（1）List接口" class="headerlink" title="（1）List接口"></a>（1）List接口</h3><pre><code class="java">//list常用操作方法set(i,value);  //修改索引为i的元素值,value为修改值get(i);        //获取索引为i的元素（从0开始）//1.创建集合//根据频繁操作的复杂度选择，一般随便选List&lt;Object&gt; al=new ArrayList&lt;Object&gt;();List&lt;Object&gt; ll=new LinkedList&lt;Object&gt;();</code></pre><pre><code class="java">//2.遍历//(1).forfor(Object x:list)    x;for(int i=0;i&lt;list.size();i++)    list.get(i);//(2)迭代器遍历Iterator&lt;Object&gt; it=list.iterator();while(it.hasNext)    it.next();//注意：List中的Remove和Collection的不一样remove(i)是索引而不是元素值</code></pre><h3 id="（2）Set接口"><a href="#（2）Set接口" class="headerlink" title="（2）Set接口"></a>（2）Set接口</h3><pre><code class="java">//优点：不能包含重复元素，可以去重//1.创建集合Set&lt;Object&gt; hs=new HashSet&lt;Object&gt;();Set&lt;Object&gt; ts=new TreeSet&lt;Object&gt;();//2.遍历//(1)forfor(Object x:set)    x;//(2)迭代器遍历Iterator&lt;Object&gt; it=set.iterator();while(it.hasNext)    it.next();</code></pre><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><pre><code class="java">//常用方法put(key,value);    //添加元素get(key);          //获取元素remove(key);       //删除元素clear();           //清空集合contains(element);//判断是否在集合内通过迭代器//每个key只能映射一个value,可将key和value看成2个集合//1.创建集合Map&lt;Object,Object&gt; hm=new HashMap&lt;Object,Object&gt;();Map&lt;Object,Object&gt; tm=new TreeMap&lt;Object,Object&gt;();//2.遍历//(1)for//遍历key集合for(int x:hm.keySet()) &#123;   System.out.println(&quot;key=&quot;+x+&quot; &quot;+&quot;value=&quot;+hm.get(x));&#125;//(2).迭代器遍历Set&lt;Integer&gt; set=hm.keySet();Iterator it=set.iterator();while(it.hasNext)    it.next();</code></pre><h3 id="3-关于迭代器"><a href="#3-关于迭代器" class="headerlink" title="3.关于迭代器"></a>3.关于迭代器</h3><pre><code class="java">//常用方法it.next()     //返回下一个元素it.hasNext()  //是否有元素it.remove()   //删除元素</code></pre><h2 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h2><pre><code class="java">import java.math.*;import java.util.*;</code></pre><h1 id="java数据结构"><a href="#java数据结构" class="headerlink" title="java数据结构"></a>java数据结构</h1><table><thead><tr><th>数据结构</th><th>特点</th></tr></thead><tbody><tr><td>数组</td><td>固定大小，元素类型相同，快速随机访问</td></tr><tr><td>列表</td><td>动态大小，元素类型相同，支持插入和删除操作</td></tr><tr><td>集合</td><td>无序，不允许重复元素</td></tr><tr><td>映射</td><td>键值对存储，通过键来访问值</td></tr><tr><td>队列</td><td>先进先出（FIFO）</td></tr><tr><td>堆栈</td><td>后进先出（LIFO）</td></tr><tr><td>树</td><td>分层结构，常见的有二叉树、AVL树、红黑树等</td></tr><tr><td>图</td><td>表示各种关系，复杂的数据结构</td></tr><tr><td>链表</td><td>线性结构，包含节点和指向下一个节点的引用</td></tr><tr><td>哈希表</td><td>基于哈希函数的快速查找和插入数据结构</td></tr></tbody></table><p>ava 的 java.util 包中提供了许多这些数据结构的实现，可以根据需要选择合适的类。</p><p>以下是一些常见的 Java 数据结构：</p><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><p>数组（Arrays）是一种基本的数据结构，可以存储固定大小的相同类型的元素。</p><pre><code class="java">int[] array = new int[5];</code></pre><ul><li><strong>特点：</strong> 固定大小，存储相同类型的元素。</li><li><strong>优点：</strong> 随机访问元素效率高。</li><li><strong>缺点：</strong> 大小固定，插入和删除元素相对较慢。</li></ul><h3 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h3><p>Java 提供了多种列表实现，如 ArrayList 和 LinkedList。</p><pre><code class="java">List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();List&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();</code></pre><p><strong>ArrayList:</strong></p><ul><li><strong>特点：</strong> 动态数组，可变大小。</li><li><strong>优点：</strong> 高效的随机访问和快速尾部插入。</li><li><strong>缺点：</strong> 中间插入和删除相对较慢。</li></ul><p><strong>LinkedList:</strong></p><ul><li><strong>特点：</strong> 双向链表，元素之间通过指针连接。</li><li><strong>优点：</strong> 插入和删除元素高效，迭代器性能好。</li><li><strong>缺点：</strong> 随机访问相对较慢。</li></ul><h3 id="集合（Sets）"><a href="#集合（Sets）" class="headerlink" title="集合（Sets）"></a>集合（Sets）</h3><p>集合（Sets）用于存储不重复的元素，常见的实现有 HashSet 和 TreeSet。</p><pre><code class="java">Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();Set&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();</code></pre><p><strong>HashSet:</strong></p><ul><li><strong>特点：</strong> 无序集合，基于HashMap实现。</li><li><strong>优点：</strong> 高效的查找和插入操作。</li><li><strong>缺点：</strong> 不保证顺序。</li></ul><h3 id="映射（Maps）"><a href="#映射（Maps）" class="headerlink" title="映射（Maps）"></a>映射（Maps）</h3><p>映射（Maps）用于存储键值对，常见的实现有 HashMap 和 TreeMap。</p><pre><code class="java">Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();Map&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;();</code></pre><p><strong>HashMap:</strong></p><ul><li><strong>特点：</strong> 基于哈希表实现的键值对存储结构。</li><li><strong>优点：</strong> 高效的查找、插入和删除操作。</li><li><strong>缺点：</strong> 无序，不保证顺序。</li></ul><p><strong>TreeMap:</strong></p><ul><li><strong>特点：</strong> 基于红黑树实现的有序键值对存储结构。</li><li><strong>优点：</strong> 有序，支持按照键的顺序遍历。</li><li><strong>缺点：</strong> 插入和删除相对较慢。</li></ul><h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈（Stack）遵循先进后出（FILO）原则。</p><pre><code class="java">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</code></pre><p><strong>Stack 类:</strong></p><ul><li><strong>特点：</strong> 代表一个栈，通常按照后进先出（LIFO）的顺序操作元素。</li></ul><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列（Queue）遵循先进先出（FIFO）原则，常见的实现有 LinkedList 和 PriorityQueue。</p><pre><code class="java">Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</code></pre><p><strong>Queue 接口:</strong></p><ul><li><strong>特点：</strong> 代表一个队列，通常按照先进先出（FIFO）的顺序操作元素。</li><li><strong>实现类：</strong> LinkedList, PriorityQueue, ArrayDeque。</li></ul><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>堆（Heap）优先队列的基础，可以实现最大堆和最小堆。</p><pre><code class="java">PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</code></pre><h3 id="树（Trees）"><a href="#树（Trees）" class="headerlink" title="树（Trees）"></a>树（Trees）</h3><p>Java 提供了 TreeNode 类型，可以用于构建二叉树等数据结构。</p><pre><code class="java">class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123; val = x; &#125;&#125;</code></pre><h3 id="图（Graphs）"><a href="#图（Graphs）" class="headerlink" title="图（Graphs）"></a>图（Graphs）</h3><p>图的表示通常需要自定义数据结构或使用图库，Java 没有内建的图类。</p><p>以上介绍的只是 Java 中一些常见的数据结构，实际上还有很多其他的数据结构和算法可以根据具体问题选择使用。</p><hr><h2 id="其他一些说明"><a href="#其他一些说明" class="headerlink" title="其他一些说明"></a>其他一些说明</h2><p>以下这些类是传统遗留的，在 Java2 中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。</p><h3 id="枚举（Enumeration）"><a href="#枚举（Enumeration）" class="headerlink" title="枚举（Enumeration）"></a>枚举（Enumeration）</h3><p>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。</p><p>例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。</p><p>关于枚举接口的更多信息，<a href="https://www.runoob.com/java/java-enumeration-interface.html">请参见枚举（Enumeration）</a>。</p><pre><code class="java">import java.util.Enumeration;import java.util.Vector;public class EnumerationExample &#123;    public static void main(String[] args) &#123;        // 创建一个Vector集合        Vector&lt;String&gt; vector = new Vector&lt;&gt;();        vector.add(&quot;Apple&quot;);        vector.add(&quot;Banana&quot;);        vector.add(&quot;Orange&quot;);        // 获取Enumeration对象        Enumeration&lt;String&gt; enumeration = vector.elements();        // 使用Enumeration遍历集合元素        while (enumeration.hasMoreElements()) &#123;            String element = enumeration.nextElement();            System.out.println(element);        &#125;    &#125;&#125;</code></pre><h3 id="位集合（BitSet）"><a href="#位集合（BitSet）" class="headerlink" title="位集合（BitSet）"></a>位集合（BitSet）</h3><p>位集合类实现了一组可以单独设置和清除的位或标志。</p><p>该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p><p>关于该类的更多信息，<a href="https://www.runoob.com/java/java-bitset-class.html">请参见位集合（BitSet）</a>。</p><h3 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h3><p>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。</p><p>和数组一样，Vector对象的元素也能通过索引访问。</p><p>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</p><p>关于该类的更多信息，<a href="https://www.runoob.com/java/java-vector-class.html">请参见向量(Vector)</a></p><h3 id="栈（Stack）-1"><a href="#栈（Stack）-1" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</p><p>你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。</p><p>当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</p><p>关于该类的更多信息，<a href="https://www.runoob.com/java/java-stack-class.html">请参见栈（Stack）</a>。</p><h1 id="Java-Stack-类"><a href="#Java-Stack-类" class="headerlink" title="Java Stack 类"></a>Java Stack 类</h1><p>栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</p><p>堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。</p><pre><code>Stack()</code></pre><p>除了由Vector定义的所有方法，自己也定义了一些方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">boolean empty()  测试堆栈是否为空。</td></tr><tr><td align="left">2</td><td align="left">Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。</td></tr><tr><td align="left">3</td><td align="left">Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。</td></tr><tr><td align="left">4</td><td align="left">Object push(Object element) 把项压入堆栈顶部。</td></tr><tr><td align="left">5</td><td align="left">int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的程序说明这个集合所支持的几种方法</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><pre><code class="java">import java.util.*;public class StackDemo &#123;// 加入元素到栈中，并进行展示static void showpush(Stack&lt;Integer&gt; st, int a) &#123;    st.push(new Integer(a));    System.out.println(&quot;push(&quot; + a + &quot;)&quot;);    System.out.println(&quot;stack: &quot; + st);&#125;// 弹出栈顶元素，并展示结果static void showpop(Stack&lt;Integer&gt; st) &#123;    System.out.print(&quot;pop -&gt; &quot;);    Integer a = (Integer) st.pop();    System.out.println(a);    System.out.println(&quot;stack: &quot; + st);&#125;public static void main(String args[]) &#123;    Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();    System.out.println(&quot;stack: &quot; + st);    showpush(st, 42); // 将元素 42 加入栈中    showpush(st, 66); // 将元素 66 加入栈中    showpush(st, 99); // 将元素 99 加入栈中    showpop(st);      // 弹出栈顶元素并展示    showpop(st);      // 弹出栈顶元素并展示    showpop(st);      // 弹出栈顶元素并展示    try &#123;        showpop(st);  // 弹出栈顶元素并展示，但是此时栈已经为空，会触发 EmptyStackException    &#125; catch (EmptyStackException e) &#123;        System.out.println(&quot;empty stack&quot;); // 捕获 EmptyStackException 异常并打印 &quot;empty stack&quot;    &#125;&#125;&#125;</code></pre><p>以上实例编译运行结果如下：</p><pre><code class="java">stack: [ ]push(42)stack: [42]push(66)stack: [42, 66]push(99)stack: [42, 66, 99]pop -&gt; 99stack: [42, 66]pop -&gt; 66stack: [42]pop -&gt; 42stack: [ ]pop -&gt; empty stack</code></pre><h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><p>字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。</p><p>当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用 Dictionary。</p><p>由于 Dictionary 类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</p><p>关于该类的更多信息，<a href="https://www.runoob.com/java/java-dictionary-class.html">请参见字典（ Dictionary）</a>。</p><p>Dictionary 类在较新的 Java 版本中已经被弃用（deprecated），推荐使用 Map 接口及其实现类，如 HashMap、TreeMap 等，来代替 Dictionary。</p><p>Map 接口及其实现类 可以参考：<a href="https://www.runoob.com/java/java-collections.html">Java 集合框架</a>。</p><h3 id="哈希表（Hashtable）"><a href="#哈希表（Hashtable）" class="headerlink" title="哈希表（Hashtable）"></a>哈希表（Hashtable）</h3><p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</p><p>例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。</p><p>哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</p><p>关于该类的更多信息，<a href="https://www.runoob.com/java/java-hashTable-class.html">请参见哈希表（HashTable）</a>。</p><h3 id="属性（Properties）"><a href="#属性（Properties）" class="headerlink" title="属性（Properties）"></a>属性（Properties）</h3><p>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。</p><p>Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p><p>关于该类的更多信息，<a href="https://www.runoob.com/java/java-properties-class.html">请参见属性（Properties）</a>。</p><h1 id="算法学习路线"><a href="#算法学习路线" class="headerlink" title="算法学习路线"></a>算法学习路线</h1><p><img src="/2024/01/31/%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/image-20240202210725747.png" alt="image-20240202210725747"></p><h1 id="java数据结构与算法"><a href="#java数据结构与算法" class="headerlink" title="java数据结构与算法"></a>java数据结构与算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class="markdown">结构，简单理解就是关系，比如分子结构，就是说组成分子的原子之间的排列方式。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，他们之间存在某种关系，这种数据元素相互之间的关系成为结构（Structure）。数据结构包括三方面的内容：逻辑结构，存储结构和数据的运算。逻辑结构是面向问题的，物理结构是面向计算机的，其基本目标就是将数据及其逻辑关系存储到计算机内存中。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。程序设计=数据结构+算法想要编写一个质量高的程序，必须分析待处理对象的特性及各个处理对象之间存在的关系。</code></pre><p>数据结构三要素</p><ul><li>逻辑结构</li><li>存储结构</li><li>数据的运算</li></ul><p><img src="/./%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/image-20240205201726684.png" alt="image-20240205201726684"></p><p><img src="/2024/01/31/%E8%93%9D%E6%A1%A5%E6%80%BB%E7%BB%93/image-20240205201730225.png" alt="image-20240205201730225"></p><p>线性结构:  一对一的关系</p><p>集合：</p><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1>]]></content>
      
      
      
        <tags>
            
            <tag> --蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索模板</title>
      <link href="/2024/01/25/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/01/25/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><pre><code>（1）剪枝（2）双向广搜（3）记忆化搜索（4）迭代加深（5）启发式搜索</code></pre><h2 id="BFS-和-DFS"><a href="#BFS-和-DFS" class="headerlink" title="BFS 和 DFS"></a>BFS 和 DFS</h2><ul><li>BFS：广度优先搜索</li><li>DFS：深度优先搜索</li></ul><p>这两种搜索算法在图论和树结构中常被使用，用于遍历或搜索图或树的节点。广度优先搜索按层次逐层扩展，而深度优先搜索则通过沿着树的深度尽可能远的搜索。这两种算法在不同的情况下有不同的应用场景</p><h2 id="搜索是暴力法的具体实现"><a href="#搜索是暴力法的具体实现" class="headerlink" title="搜索是暴力法的具体实现"></a>搜索是暴力法的具体实现</h2><table><thead><tr><th>DFS</th><th>BFS</th></tr></thead><tbody><tr><td>适合求方案总数</td><td>适合求解最短路，连通性问题</td></tr><tr><td>利用递归来实现</td><td>利用队列来实现</td></tr><tr><td>试探搜索</td><td>地毯搜索</td></tr><tr><td>沿着一条路走到黑</td><td>总是先w试距离初始状态最近的状态</td></tr></tbody></table><h2 id="DFS-递归实现"><a href="#DFS-递归实现" class="headerlink" title="DFS (递归实现)"></a>DFS (递归实现)</h2><p>递归思想：不断重复调用自己</p><p>俩个过程：递归前进和递归后退（回溯）</p><p>大问题拆分小问题 求小问题的解载返回大问题上直到求出大问题的解</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/./%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/image-20240125154246556.png" alt="image-20240125154246556"></h4><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><pre><code class="java">x</code></pre><h2 id="BFS-最短路径"><a href="#BFS-最短路径" class="headerlink" title="BFS(最短路径)"></a>BFS(最短路径)</h2>]]></content>
      
      
      
        <tags>
            
            <tag> -- 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯寒假模板总结</title>
      <link href="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/./%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240120092756517.png" alt="image-20240120092756517"></p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240120092756517.png" alt="image-20240120092756517"></p><p><img src="/./%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240120101629096.png" alt="image-20240120101629096"><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240120101630012.png" alt="image-20240120101630012"></p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h1 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>当我们使用 <code>Scanner</code> 类的 <code>nextInt()</code> 方法读取整数时，会在输入缓冲区留下换行符。这会导致接下来使用 <code>nextLine()</code> 方法时直接读取到这个换行符，而不是我们想要的输入。</p><p>让我用代码演示一下这种情况：</p><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入一个整数：&quot;);        int num = scanner.nextInt(); // 读取整数        System.out.println(&quot;你输入的整数是：&quot; + num);        System.out.println(&quot;请输入一行字符串：&quot;);        String str = scanner.nextLine(); // 本来想读取一行字符串，但实际上会读取到之前的换行符        System.out.println(&quot;你输入的字符串是：&quot; + str);        scanner.close();    &#125;&#125;</code></pre><p>如果我们输入如下内容：</p><pre><code>123hello</code></pre><p>输出结果将会是：</p><pre><code class="markdown">请输入一个整数：你输入的整数是：123请输入一行字符串：你输入的字符串是：</code></pre><p>可以看到，由于之前的 <code>nextInt()</code> 留下了一个换行符，导致接下来的 <code>nextLine()</code> 直接读取到了这个换行符，而不是我们期望的输入 “hello”。</p><p>为了解决这个问题，可以在 <code>nextInt()</code> 后面加上一个 <code>nextLine()</code> 来消耗掉这个换行符，保证接下来的 <code>nextLine()</code> 可以正确读取到我们想要的输入。</p><h1 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a>归并排序模板</h1><pre><code class="java">static void mergeSort(int[] a, int[] aa, int x, int y) &#123;    // 如果数组只有一个元素，则返回，不需要排序    if (x == y) return;    // 找到数组的中间位置    int mid = (x + y) &gt;&gt; 1;    // 递归地对左半部分进行排序    mergeSort(a, aa, x, mid);    // 递归地对右半部分进行排序    mergeSort(a, aa, mid + 1, y);    // 合并左右两部分并排序    int i = x, j = mid + 1, k = x;    while (i &lt;= mid &amp;&amp; j &lt;= y) &#123;        // 如果左半部分当前元素小于等于右半部分当前元素，将左半部分的当前元素放入临时数组        if (a[i] &lt;= a[j]) &#123;            aa[k++] = a[i++];        &#125; else &#123;            // 如果右半部分当前元素小于左半部分当前元素，将右半部分的当前元素放入临时数组            aa[k++] = a[j++];            // 计算逆序对数量，即右半部分当前元素与左半部分剩余元素的数量            ans += mid - i + 1;            // 对结果取模，防止溢出            ans %= mod;        &#125;    &#125;    // 处理左半部分剩余元素    while (i &lt;= mid) &#123;        aa[k++] = a[i++];    &#125;    // 处理右半部分剩余元素    while (j &lt;= y) &#123;        aa[k++] = a[j++];    &#125;    // 将临时数组中排好序的元素复制回原数组    for (int index = x; index &lt;= y; index++) &#123;        a[index] = aa[index];    &#125;&#125;</code></pre><p>归并排序是一种分治算法，其基本思想是将待排序数组分割成两部分，分别对这两部分进行排序，然后将两部分合并起来得到有序数组。</p><p>在这段代码中，<code>mergeSort</code>方法实现了归并排序算法。具体步骤包括：</p><ol><li>将数组a在范围[x, y]内进行归并排序。</li><li>如果x等于y，表示当前待排序数组只有一个元素，直接返回。</li><li>计算中间位置mid，以mid为界将数组分为左右两部分，分别继续进行归并排序。</li><li>合并左右两部分：利用i、j、k三个指针分别指向左部分、右部分和辅助数组aa，比较左右两部分的元素大小，并将较小的元素放入辅助数组aa中。</li><li>在合并过程中，如果发现a[i] &gt; a[j]，则累加逆序对数量ans，并对mod取模。</li><li>将剩余未处理的元素依次放入辅助数组aa中。</li><li>最后将aa中的排序结果复制回原数组a。</li></ol><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><pre><code class="java"> //冒泡排序        for(int i=0;i&lt;arr.length-1;i++) &#123;            for(int x=0;x&lt; arr.length-1-i;x++) &#123;                if(arr[x] &gt; arr[x+1]) &#123;                    //当前一个大于后一个时，双方交换位置                    int temp = arr[x];                    arr[x] = arr[x+1];                    arr[x+1] = temp;                &#125;            &#125;        &#125;</code></pre><h1 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h1><pre><code class="java">char[][] arr = &#123;    &#123;&#39;U&#39;, &#39;D&#39;, &#39;D&#39;, &#39;L&#39;, &#39;U&#39;, &#39;U&#39;, &#39;L&#39;, &#39;R&#39;, &#39;U&#39;, &#39;L&#39;&#125;,    &#123;&#39;U&#39;, &#39;U&#39;, &#39;R&#39;, &#39;L&#39;, &#39;L&#39;, &#39;L&#39;, &#39;R&#39;, &#39;R&#39;, &#39;R&#39;, &#39;U&#39;&#125;,    &#123;&#39;R&#39;, &#39;R&#39;, &#39;U&#39;, &#39;U&#39;, &#39;R&#39;, &#39;L&#39;, &#39;D&#39;, &#39;L&#39;, &#39;R&#39;, &#39;D&#39;&#125;,    &#123;&#39;R&#39;, &#39;U&#39;, &#39;D&#39;, &#39;D&#39;, &#39;D&#39;, &#39;U&#39;, &#39;U&#39;, &#39;U&#39;, &#39;U&#39;, &#39;U&#39;&#125;,    &#123;&#39;U&#39;, &#39;R&#39;, &#39;U&#39;, &#39;D&#39;, &#39;L&#39;, &#39;L&#39;, &#39;R&#39;, &#39;R&#39;, &#39;U&#39;, &#39;U&#39;&#125;,    &#123;&#39;D&#39;, &#39;U&#39;, &#39;R&#39;, &#39;L&#39;, &#39;R&#39;, &#39;L&#39;, &#39;D&#39;, &#39;L&#39;, &#39;R&#39;, &#39;L&#39;&#125;,    &#123;&#39;U&#39;, &#39;L&#39;, &#39;L&#39;, &#39;U&#39;, &#39;R&#39;, &#39;L&#39;, &#39;L&#39;, &#39;R&#39;, &#39;D&#39;, &#39;U&#39;&#125;,    &#123;&#39;R&#39;, &#39;D&#39;, &#39;L&#39;, &#39;U&#39;, &#39;L&#39;, &#39;L&#39;, &#39;R&#39;, &#39;D&#39;, &#39;D&#39;, &#39;D&#39;&#125;,    &#123;&#39;U&#39;, &#39;U&#39;, &#39;D&#39;, &#39;D&#39;, &#39;U&#39;, &#39;D&#39;, &#39;U&#39;, &#39;D&#39;, &#39;L&#39;, &#39;L&#39;&#125;,    &#123;&#39;U&#39;, &#39;L&#39;, &#39;R&#39;, &#39;D&#39;, &#39;L&#39;, &#39;U&#39;, &#39;U&#39;, &#39;R&#39;, &#39;R&#39;, &#39;R&#39;&#125;&#125;;</code></pre><h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><pre><code class="java">int[][] myArray = new int[3][3];Scanner sc = new Scanner(System.in);for (int i = 0; i &lt; myArray.length; i++) &#123;    for (int j = 0; j &lt; myArray[i].length; j++) &#123;        myArray[i][j] = sc.nextInt(); // 从标准输入中读取数据并赋值给数组元素    &#125;&#125;</code></pre><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><pre><code class="java">arr = new char[10][10];               // 创建一个 10 行 10 列的字符型二维数组 arr，并将其初始化        for(int i = 0;i&lt;arr.length;i++) &#123;     // 对于 arr 中的每一行            String s = sc.next();             // 从标准输入读入一行字符串            arr[i] = s.toCharArray();         // 将字符串转换为字符数组，并将其赋值给 arr 中的对应行        &#125;</code></pre><pre><code class="java">char[][] arr = new char[10][10]; // 创建一个大小为 10x10 的字符数组String str = &quot;UDDLUULRUL\n&quot; +                &quot;UURLLLRRRU\n&quot; +                &quot;RRUURLDLRD\n&quot; +                &quot;RUDDDDUUUU\n&quot; +                &quot;URUDLLRRUU\n&quot; +                &quot;DURLRLDLRL\n&quot; +                &quot;ULLURLLRDU\n&quot; +                &quot;RDLULLRDDD\n&quot; +                &quot;UUDDUDUDLL\n&quot; +                &quot;ULRDLUURRR&quot;;// 定义一个包含一串字符串的变量String[] arr1 = str.split(&quot;\n&quot;);// 使用换行符 &quot;\n&quot; 将字符串分割成多行，并存储到字符串数组 arr1 中int count = 0;// 定义一个计数器变量，初始值为 0for (int i = 1; i &lt;= 10; i++) &#123;    for (int j = 1; j &lt;= 10; j++) &#123;        arr[i - 1][j - 1] = arr1[i - 1].charAt(j - 1);        // 将每个字符数组 arr1 中的字符赋值给二维字符数组 arr    &#125;&#125;for (char[] row : arr) &#123;    System.out.println(Arrays.toString(row));&#125;// 打印二维字符数组 arr 的内容，每一行以字符串形式打印出来</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre><code>[U, D, D, L, U, U, L, R, U, L][U, U, R, L, L, L, R, R, R, U][R, R, U, U, R, L, D, L, R, D][R, U, D, D, D, D, U, U, U, U][U, R, U, D, L, L, R, R, U, U][D, U, R, L, R, L, D, L, R, L][U, L, L, U, R, L, L, R, D, U][R, D, L, U, L, L, R, D, D, D][U, U, D, D, U, D, U, D, L, L][U, L, R, D, L, U, U, R, R, R]</code></pre><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p> 模运算是大数运算中的常用操作。如果一个数太大，无法直接输出，或者不需要直接输出，可以把它取模后，缩小数值再输出。取模也是哈希的常用技术。</p><p>定义取模运算为 a 除以 m 的余数，记为：amodm&#x3D;a</p><p>对于 a mod m &#x3D; a，必须要求 a 和 m 的正负号一致，都为正数或都为负数；如果正负不同，取模和求余的结果是不同的。另外取模的结果满足 0 ≤ a mod m &lt; m−1，题目会用给定的 m，限制计算结果的范围。</p><p>取模运算的加减乘除</p><p><img src="/./%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240303213526199.png" alt="image-20240303213526199"></p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240303213526199.png" alt="image-20240303213526199"></p><h3 id="java里有快速幂库函数"><a href="#java里有快速幂库函数" class="headerlink" title="java里有快速幂库函数"></a>java里有快速幂库函数</h3><pre><code class="java">import java.math.BigInteger;import java.util.Scanner; public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        BigInteger bigInteger1 = scanner.nextBigInteger();        BigInteger bigInteger2 = scanner.nextBigInteger();        BigInteger bigInteger3 = scanner.nextBigInteger();        System.out.println(bigInteger1.modPow(bigInteger2,bigInteger3));    &#125;&#125;</code></pre><pre><code class="markdown">计算第一个大整数的第二个大整数次方对第三个大整数取模的结果，并将结果打印到标准输出。</code></pre><p>不用函数</p><pre><code class="java">package 模板; // 定义一个包名为&quot;模板&quot;import java.util.Scanner; // 导入 Scanner 类，用于从控制台读取输入public class 快速幂模运算 &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象，用于从控制台读取输入        // 输入三个整数        int b = scanner.nextInt(); // 读取第一个整数        int p = scanner.nextInt(); // 读取第二个整数        int k = scanner.nextInt(); // 读取第三个整数        int ans = 1; // 初始化结果变量为 1        // 使用快速幂算法计算 b^p % k 的结果        while (p != 0) &#123;            if (p % 2 == 1) &#123; // 如果 p 是奇数                ans = (ans * b) % k; // 更新结果变量            &#125;            p &gt;&gt;= 1; // 将 p 右移一位，相当于 p 除以 2            b = (b * b) % k; // 更新 b 的值为 b 的平方取模 k        &#125;        System.out.println(ans); // 输出结果    &#125;&#125;</code></pre><h2 id="单纯取模"><a href="#单纯取模" class="headerlink" title="单纯取模"></a>单纯取模</h2><pre><code class="java">BigInteger result = a.mod(b);</code></pre><h2 id="计算大整数的幂运算后对另一个大整数取模的结果"><a href="#计算大整数的幂运算后对另一个大整数取模的结果" class="headerlink" title="计算大整数的幂运算后对另一个大整数取模的结果"></a>计算大整数的幂运算后对另一个大整数取模的结果</h2><pre><code class="java"> System.out.println(bigInteger1.modPow(bigInteger2,bigInteger3));</code></pre><h2 id="N-q-p-求qp"><a href="#N-q-p-求qp" class="headerlink" title="N &#x3D; q*p 求qp"></a>N &#x3D; q*p 求qp</h2><pre><code class="java">import java.math.BigInteger;public class Main &#123;    public static void main(String[] args) &#123;        // 给定的大整数字符串        String s = &quot;1001733993063167141&quot;;                // 将字符串转换为 BigInteger 对象        BigInteger temp = new BigInteger(s);        BigInteger bigInteger = new BigInteger(s);                // 计算给定大整数的平方根        bigInteger = bigInteger.sqrt();                // 初始化计数器和常量        BigInteger i = new BigInteger(&quot;2&quot;);        BigInteger one = BigInteger.ONE;        BigInteger zero = BigInteger.ZERO;                // 从 2 开始迭代直到平方根        for (; i.compareTo(bigInteger) &lt; 0; ) &#123;            // 检查是否能整除给定的大整数            if (temp.remainder(i).equals(zero)) &#123;                // 如果能整除，则打印出因子                System.out.println(i);            &#125;            // 增加计数器            i = i.add(BigInteger.ONE);        &#125;                // 打印结束标志        System.out.println(&quot;END!&quot;);    &#125;&#125;</code></pre><p><img src="/./%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240316201112511.png" alt="image-20240316201112511"></p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240316201112511.png" alt="image-20240316201112511"></p><p>解决方法</p><pre><code class="java">  i.compareTo(sqrtN)&lt;=0</code></pre><h2 id="大整数的加减乘除"><a href="#大整数的加减乘除" class="headerlink" title="大整数的加减乘除"></a>大整数的加减乘除</h2><pre><code class="java">// 使用 BigInteger.TWO 进行大整数除法，实现对两个 BigInteger 对象相除// 返回商，这里是对 left 和 right 之和进行除以 2 的操作，用于更新二分查找的中间值BigInteger mid = left.add(right).divide(BigInteger.TWO);// 使用 BigInteger.TWO 进行大整数加法，实现对两个 BigInteger 对象的加法操作// 将 left 和 right 相加后除以 2，得到新的中间值，用于更新二分查找的中间值BigInteger mid = left.add(right).divide(BigInteger.TWO);// 使用 BigInteger.TWO 进行大整数减法，实现对两个 BigInteger 对象的减法操作// 将当前中间值 mid 减去 1，向左移动一个单位，用于更新二分查找的右边界BigInteger right = mid.subtract(BigInteger.ONE);// 使用 BigInteger.TWO 进行大整数乘法，实现对两个 BigInteger 对象的乘法操作// 将当前中间值 mid 乘以 2，用于更新二分查找的右边界BigInteger square = mid.multiply(mid);// 使用 BigInteger.TWO 进行大整数除法，实现对两个 BigInteger 对象相除// 将 left 和 right 之和除以 2，用于更新二分查找的中间值BigInteger mid = left.add(right).divide(BigInteger.TWO);//取余和0if (temp.remainder(i).equals(zero)) &#123;</code></pre><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p><img src="/./%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDYyNzQyMTk=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p><strong>样例输入</strong></p><pre><code>2 1 3121 2 3</code></pre><p><strong>样例输出</strong></p><pre><code>1 2 32 4 6</code></pre><pre><code class="java">package 模板;import java.util.Scanner;public class 矩阵乘法 &#123;    public static void main(String[] args) &#123;        //矩阵乘法        //输入数据 N,M,K;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        int M = scanner.nextInt();        int K = scanner.nextInt();        //定义二维数组存放        int [][] k1 = new int[N][M];        int [][] k2 = new int[M][K];        int [][] k3 = new int[N][K];        for (int i = 0;i &lt; N ; i++)&#123;            for(int j = 0;j&lt; M;j++) &#123;                k1[i][j] = scanner.nextInt();            &#125;        &#125;        for (int i = 0; i &lt; M; i++) &#123;            for (int j = 0; j &lt; K; j++) &#123;                k2[i][j] = scanner.nextInt();            &#125;        &#125;        for (int i = 0; i &lt; N; i++) &#123;            for (int j = 0; j &lt; K; j++) &#123;                int sum = 0;                for (int k = 0; k &lt; M; k++) &#123;                    sum = sum + k1[i][k] * k2[k][j];                &#125;                k3[i][j] = sum;            &#125;        &#125;        for (int i = 0; i &lt; N; i++) &#123;            for (int j = 0; j &lt; K; j++) &#123;                System.out.print(k3[i][j] + &quot; &quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre><h2 id="矩阵乘法模板"><a href="#矩阵乘法模板" class="headerlink" title="矩阵乘法模板"></a>矩阵乘法模板</h2><pre><code class="java"> // 矩阵乘法    private static int[][] solve(int[][] a1, int[][] a2) &#123;        int[][] a3 = new int[N + 1][N + 1]; // 存储计算结果        for (int i = 1; i &lt;= N; i++) &#123;            for (int j = 1; j &lt;= N; j++) &#123;                int sum = 0;                for (int k = 1; k &lt;= N; k++) &#123;                    sum = sum + a1[i][k] * a2[k][j]; // 计算矩阵元素乘积的和                &#125;                a3[i][j] = sum; // 存储结果            &#125;        &#125;        return a3; // 返回计算结果    &#125;</code></pre><h2 id="计算矩阵幂次"><a href="#计算矩阵幂次" class="headerlink" title="计算矩阵幂次"></a>计算矩阵幂次</h2><pre><code class="java"> // 计算矩阵的幂次    private static int[][] modPow() &#123;        int[][] ans = new int[N + 1][N + 1]; // 存储计算结果        for (int i = 1; i &lt;= N; i++) &#123;            ans[i][i] = 1; // 单位矩阵        &#125;        while (M &gt; 0) &#123;            if (M % 2 == 1) &#123; // 若幂次是奇数                ans = solve(ans, a); // 计算结果乘以原始矩阵            &#125;            M = M / 2; // 幂次除以 2            a = solve(a, a); // 计算原始矩阵的平方        &#125;        return ans; // 返回计算结果    &#125;</code></pre><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>整数 a 和 b 的最大公约数是指能同时整除 a 和 b 的最大整数 编码时只需要考虑正整数的最大公约数</p><h3 id="java-大数有gcd函数"><a href="#java-大数有gcd函数" class="headerlink" title="java 大数有gcd函数"></a>java 大数有gcd函数</h3><p><img src="/./%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDYyNzQyMTk=,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        // 从标准输入读取两个整数        int a = scanner.nextInt();        int b = scanner.nextInt();        // 调用 gcd 方法计算最大公约数并打印结果        System.out.println(gcd(a, b));    &#125;    // 计算两个整数的最大公约数    private static int gcd(int a, int b) &#123;        // 如果 b 为 0，则返回 a，a 即为最大公约数        if (b == 0) &#123;            return a;        &#125; else &#123;            // 否则递归调用 gcd 方法，传入 b 和 a%b，并返回结果            return gcd(b, a % b);        &#125;    &#125;&#125;</code></pre><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><ol><li>是指几个自然数共有的倍数中除0以外最小的一个数。</li><li>有结论：lcm（a,b）<em>gcd（a,b）&#x3D; a</em>b；</li></ol><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int a = scanner.nextInt();        int b = scanner.nextInt();        System.out.println((a*b)/gcd(a,b));    &#125;    private static int gcd(int a, int b) &#123;        if (b == 0) &#123;            return a;        &#125; else &#123;            return gcd(b, a % b);        &#125;    &#125;&#125;</code></pre><p>等差数列</p><ol><li>最小数量 &#x3D; （最大值-最小值）&#x2F;公差 +1</li><li>公差 &#x3D; 最小公倍数</li><li>思路：首先排序数组，然后找到数组中相邻元素的最大公约数作为等差数列的公差，最后通过等差数列的性质计算出最长等差子序列的长度。</li></ol><pre><code class="java">import java.util.Arrays;import java.util.Scanner;public class Main &#123;    private static int[] a;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        // 读取数组长度        int N = scanner.nextInt();        // 初始化数组        a = new int[N];        // 读取数组元素        for (int i = 0; i &lt; N; i++) &#123;            a[i] = scanner.nextInt();        &#125;           // 对数组元素进行排序        Arrays.sort(a);        // 初始化公共差        int temp = a[1] - a[0];        // 计算数组中所有相邻元素的最大公约数        for (int i = 1; i &lt; N; i++) &#123;            temp = gcd(temp, a[i] - a[i - 1]);        &#125;        // 输出结果：数组中所有元素按照公共差排列的长度        System.out.println((a[N-1]-a[0])/temp+1);    &#125;    // 计算两个数的最大公约数    private static int gcd(int a, int b) &#123;        if (b == 0) &#123;            return a;        &#125; else &#123;            return gcd(b, a % b);        &#125;    &#125;&#125;</code></pre><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><pre><code></code></pre><h3 id="最大最小公倍数"><a href="#最大最小公倍数" class="headerlink" title="最大最小公倍数"></a>最大最小公倍数</h3><p>一定要挑出三个互质的数才能使最小公倍数 最大</p><pre><code class="java">import java.math.BigInteger;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        BigInteger n = new BigInteger(String.valueOf(N));        BigInteger n1 = new BigInteger(String.valueOf(N-1));        BigInteger n2 = new BigInteger(String.valueOf(N-2));        BigInteger n3 = new BigInteger(String.valueOf(N-3));        if (N % 2 == 1) &#123;            System.out.println(n.multiply(n1).multiply(n2));        &#125; else &#123;            if (N % 3 == 0) &#123;                System.out.println(n1.multiply(n2).multiply(n3));            &#125; else &#123;                System.out.println(n.multiply(n1).multiply(n3));            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>贪心（Greedy）可以说是最容易理解的算法思想：把整个问题分解成多个步骤，在每个步骤，都选取当前步骤的最优方案，直到所有步骤结束；在每一步，都不考虑对后续步骤的影响，在后续步骤中也不再回头改变前面的选择。简单地说，其思想就是“走一步看一步”、“目光短浅”。</p><p>虽然贪心法不一定能得到最优解，但是它思路简单、编程容易。因此，如果一个问题确定用贪心法能得到最优解，那么应该使用它。</p><p>贪心法求解的问题，需要满足以下特征：<br>最优子结构性质。当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质，也称此问题满足最优性原理。也就是说，从局部最优能扩展到全局最优。<br>贪心选择性质。问题的整体最优解可以通过一系列局部最优的选择来得到。<br>贪心算法没有固定的算法框架，关键是如何选择贪心策略。</p><p>所谓贪心策略，必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。另外，把贪心法用在“虽然不是最好，但是还不错，我表示满意！”的某些难解问题上，例如旅行商问题，是很难得到最优解的。但是用贪心法常常能得到不错的近似解。如果不一定非要求得最优解，那么贪心的结果，也是很不错的方案。</p><h1 id="折半查找模板"><a href="#折半查找模板" class="headerlink" title="折半查找模板"></a>折半查找模板</h1><pre><code class="java"> public static int binarySearch(String [] a, String  x) &#123;        int low = 0,high = a.length-1;        while(low &lt;= high)&#123;            int mid = (low + high)/2;            if(a[mid].compareTo(x) &lt;0)&#123;                low = mid +1;            &#125;            else if(a[mid].compareTo(x)&gt;0)&#123;                high = mid-1;            &#125;            else                return mid;        &#125;        return -1;    &#125;</code></pre><h1 id="判断质数"><a href="#判断质数" class="headerlink" title="判断质数"></a>判断质数</h1><pre><code class="java"> // 检查一个数是否为质数的方法    static boolean check(int sum) &#123;        if (sum &lt;= 1) &#123;            return false; // 如果 sum 小于等于 1，则返回 false        &#125;        for (int i = 2; i * i &lt;= sum; ++i) &#123; // 循环检查 sum 是否可以被 i 整除            if (sum % i == 0) return false; // 如果可以被整除，则不是质数，返回 false        &#125;        return true; // 否则是质数，返回 true    &#125;</code></pre><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><p>深度优先搜索算法（Depth First Search，简称DFS）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>沿着树的深度来遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p><pre><code class="java">int check(参数)&#123;    if(满足条件)        return 1;    return 0;&#125;void dfs(int step)&#123;        判断边界        &#123;            相应操作        &#125;        尝试每一种可能        &#123;               满足check条件               标记               继续下一步dfs(step+1)               恢复初始状态（回溯的时候要用到）        &#125;&#125;   </code></pre><pre><code class="java">static ans;//全局变量static void dfs(层数，其他参数)&#123;    if(出局判断)&#123;        更新答案；//答案用全局变量表示        return;//返回上一层    &#125;    (剪枝)    for(枚举下一层可能的情况)&#123;//每一种情况        if (used[i] == 0)&#123;//判断有没有使用过            used[i] = 1;//标记已经使用过            dfs(层数+1，其他参数);//下一层            used[i] = 0; //恢复状态        &#125;        return;    &#125;&#125;</code></pre><pre><code class="java">static Set&lt;Integer&gt; st; // 用于存储结果集，其中不会包含重复元素static void dfs(int pos, int sum) &#123;        if (pos == len) &#123; // 如果当前位置等于字符串的长度            if (check(sum)) &#123; // 检查当前生成的数是否为质数                st.add(sum); // 如果是质数，则加入结果集                return;            &#125;            return;        &#125;        for (int i = 0; i &lt; len; ++i) &#123; // 遍历字符串中的每一个字符            if (!vis[i]) &#123; // 如果当前字符未被访问过                sum = sum * 10 + (s.charAt(i) - &#39;0&#39;); // 将当前字符转换为数字并加到 sum 中                vis[i] = true; // 将当前位置标记为已访问                dfs(pos + 1, sum); // 递归调用，继续生成下一个数字                sum /= 10; // 回溯，恢复 sum 的值                vis[i] = false; // 恢复当前位置的访问状态            &#125;        &#125;    &#125;</code></pre><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>全排列</p><pre><code class="java">import java.util.Scanner;public class Main &#123;    // 创建一个数组用于存储输入的数字    public static int[] a = new int[3];    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        // 循环读取输入的数字并存储到数组中        for (int i = 0; i &lt;= 2; i++) &#123;            a[i] = scanner.nextInt();        &#125;        // 调用深度优先搜索函数，从索引 0 到索引 2 进行全排列        dfs(0, 2);    &#125;    // 深度优先搜索函数，用于生成从第 s 到第 t 的全排列    public static void dfs(int s, int t) &#123;        // 如果 s 等于 t，表示已经生成一个完整的排列，可以打印结果并返回        if (s == t) &#123;            for (int i = 0; i &lt;= 2; i++) &#123;                System.out.print(a[i] + &quot; &quot;);            &#125;            System.out.println();            return;        &#125;        // 使用循环进行交换操作，生成全排列        for (int i = s; i &lt;= t; i++) &#123;            // 交换位置，将第 s 个元素与第 i 个元素交换            swap(s, i);            // 递归调用，继续生成剩余部分的排列            dfs(s + 1, t);            // 恢复原来的顺序，用于下一次循环            swap(i, s);        &#125;    &#125;    // 交换数组中两个位置的元素    public static void swap(int i, int j) &#123;        int temp;        temp = a[i];        a[i] = a[j];        a[j] = temp;    &#125;&#125;</code></pre><h2 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h2><p><img src="/./%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDYyNzQyMTk=,size_20,color_FFFFFF,t_70,g_se,x_16-1710617365483-3.png" alt="img"></p><pre><code class="java">import java.util.Scanner;public class Main &#123;    static final int n = 10;    static char[][] mp = new char[n + 2][n + 2];    static boolean[][] vis = new boolean[n + 2][n + 2];    static int[][] solve = new int[n + 2][n + 2]; // solve[i][j]=1表示这个点能走出去；=2表示出不去    static int ans = 0;    static int cnt = 0;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; n; j++)                mp[i][j] = scanner.next().charAt(0);        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; n; j++) &#123;                vis = new boolean[n + 2][n + 2];                if (dfs(i, j)) ans++;            &#125;        System.out.println(&quot;ans=&quot; + ans + &quot;,cnt=&quot; + cnt);    &#125;    static boolean dfs(int i, int j) &#123;        if (i &lt; 0 || i &gt; n - 1 || j &lt; 0 || j &gt; n - 1) return true;        if (solve[i][j] == 1) return true;  // 点(i,j)已经算过了，能出去        if (solve[i][j] == 2) return false; // 点(i,j)已经算过了，出不去        if (vis[i][j]) return false;        cnt++;  // 统计 dfs() 了多少次        vis[i][j] = true;        if (mp[i][j] == &#39;L&#39;) &#123;            if (dfs(i, j - 1)) &#123;                solve[i][j] = 1;                return true;            &#125; else &#123;                solve[i][j] = 2;                return false;            &#125;        &#125;        if (mp[i][j] == &#39;R&#39;) &#123;            if (dfs(i, j + 1)) &#123;                solve[i][j] = 1;                return true;            &#125; else &#123;                solve[i][j] = 2;                return false;            &#125;        &#125;        if (mp[i][j] == &#39;U&#39;) &#123;            if (dfs(i - 1, j)) &#123;                solve[i][j] = 1;                return true;            &#125; else &#123;                solve[i][j] = 2;                return false;            &#125;        &#125;        if (mp[i][j] == &#39;D&#39;) &#123;            if (dfs(i + 1, j)) &#123;                solve[i][j] = 1;                return true;            &#125; else &#123;                solve[i][j] = 2;                return false;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><h1 id="哈希表的使用"><a href="#哈希表的使用" class="headerlink" title="哈希表的使用"></a>哈希表的使用</h1><pre><code class="java">import java.util.HashMap;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt(); // 读取输入的第一个整数，表示第一个数组的长度        int m = scanner.nextInt(); // 读取输入的第二个整数，表示第二个数组的长度        HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); // 创建一个 HashMap，用于存储第一个数组中每个元素出现的次数        for (int i = 0; i &lt; n; i++) &#123;            int x = scanner.nextInt(); // 读取第一个数组中的每个元素            mp.put(x, mp.getOrDefault(x, 0) + 1); // 将元素加入 HashMap，并更新其出现次数        &#125;        int cnt = 0; // 用于统计第二个数组中与第一个数组中元素相同的个数        for (int i = 0; i &lt; m; i++) &#123;            int x = scanner.nextInt(); // 读取第二个数组中的每个元素            if (mp.containsKey(x) &amp;&amp; mp.get(x) &gt; 0) &#123; // 如果该元素在第一个数组中出现，并且出现次数大于 0                mp.put(x, mp.get(x) - 1); // 将其出现次数减 1                cnt++; // 统计个数加 1            &#125;        &#125;        System.out.println(cnt); // 输出统计结果    &#125;&#125;</code></pre><pre><code class="java">import java.util.HashMap;public class Main &#123;    public static void main(String[] args) &#123;        // 创建一个 HashMap 对象        HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();        // 添加键值对        map.put(1, &quot;Java&quot;);        map.put(2, &quot;Python&quot;);        map.put(3, &quot;C++&quot;);        // 获取值        String value = map.get(2);        System.out.println(&quot;Value at key 2: &quot; + value);        // 检查键是否存在        boolean containsKey = map.containsKey(3);        System.out.println(&quot;Key 3 exists: &quot; + containsKey);        // 删除键值对        map.remove(1);        System.out.println(&quot;After removing key 1: &quot; + map);    &#125;&#125;</code></pre><h1 id="双指针找相同元素"><a href="#双指针找相同元素" class="headerlink" title="双指针找相同元素"></a>双指针找相同元素</h1><pre><code class="java">import java.util.Scanner;import java.util.Arrays;public class Main &#123;      public static void main(String[] args) &#123;        // 创建 Scanner 对象，用于从标准输入读取数据        Scanner sc = new Scanner(System.in);        // 读取两个整数，分别表示两个数组的长度        int n = sc.nextInt();        int m = sc.nextInt();        // 创建两个整型数组，分别用于存储两个数组的元素        int a[] = new int[n];        int b[] = new int[m];        // 初始化变量 sum，用于统计相同元素的个数        int sum = 0;        // 读取第一个数组的元素，并存储到数组 a 中        for (int i = 0; i &lt; n; i++) &#123;            a[i] = sc.nextInt();        &#125;        // 读取第二个数组的元素，并存储到数组 b 中        for (int i = 0; i &lt; m; i++) &#123;            b[i] = sc.nextInt();        &#125;        // 使用 Arrays.sort 对数组 a 和 b 进行排序，使其从小到大排列        Arrays.sort(a);        Arrays.sort(b);        // 关闭 Scanner 对象，释放资源        sc.close();        // 始化两个指针 x 和 y，分别指向数组 a 和 b 的起始位置        int x = 0;        int y = 0;                // 遍历数组 a 和 b，统计相同元素的个数        while (x &lt; n &amp;&amp; y &lt; m) &#123;            if (a[x] == b[y]) &#123; // 如果两个元素相等，则相同元素个数加一，并移动两个指针                sum++;                x++;                y++;            &#125; else if (a[x] &lt; b[y]) &#123; // 如果数组 a 的元素小于数组 b 的元素，则将指针 x 向后移动一位                x++;            &#125; else &#123; // 如果数组 a 的元素大于数组 b 的元素，则将指针 y 向后移动一位                y++;            &#125;        &#125;                // 输出相同元素的个数        System.out.println(sum);    &#125;&#125;</code></pre><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h1 id="计算斐波那契数列的第-n-项"><a href="#计算斐波那契数列的第-n-项" class="headerlink" title="计算斐波那契数列的第 n 项"></a>计算斐波那契数列的第 n 项</h1><pre><code class="java"> // 计算斐波那契数列的第 n 项    private static BigInteger fb(int n) &#123;        BigInteger[] fib = new BigInteger[n + 1];        fib[1] = BigInteger.ONE;        fib[2] = BigInteger.ONE;        for (int i = 3; i &lt;= n; i++) &#123;            fib[i] = fib[i - 1].add(fib[i - 2]);        &#125;        return fib[n];    &#125;</code></pre><h2 id="加入记忆化更高效-DP"><a href="#加入记忆化更高效-DP" class="headerlink" title="加入记忆化更高效 DP"></a>加入记忆化更高效 DP</h2><pre><code class="java">public class 斐波那契数列 &#123;    //求第20个数    static int cnt;    static long[] memo; // 使用静态数组作为记忆化存储    static long fib(int n) &#123;        cnt++;        if (n == 1 || n == 2) &#123;            return 1;        &#125;        // 如果已经计算过第 n 个斐波那契数，则直接返回结果        if (memo[n] != 0) &#123;            return memo[n];        &#125;        // 否则进行递归计算，并将结果存储到 memo 数组中        memo[n] = fib(n - 1) + fib(n - 2);        return memo[n];    &#125;    public static void main(String[] args) &#123;        int n = 20;        memo = new long[n + 1]; // 初始化 memo 数组        System.out.println(fib(n));        System.out.println(cnt);    &#125;&#125;</code></pre><h1 id="排列与组合"><a href="#排列与组合" class="headerlink" title="排列与组合"></a>排列与组合</h1><h2 id="字典序模板"><a href="#字典序模板" class="headerlink" title="字典序模板"></a>字典序模板</h2><pre><code class="java">private static boolean next(int[] nums, int[] prev) &#123;        // 从右往左找到第一个递增的数 nums[i]        int i = nums.length - 2;        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;            i--;        &#125;        // 如果找不到递增的数，则说明当前排列已经是最大排列，无法生成下一个排列        if (i &lt; 0) &#123;            return false;        &#125;        // 从右往左找到第一个比 nums[i] 大的数 nums[j]        int j = nums.length - 1;        while (nums[j] &lt;= nums[i]) &#123;            j--;        &#125;        // 交换 nums[i] 和 nums[j]        swap(nums, i, j);        // 对 i 后面的数字进行逆序排列，保证新排列是下一个字典序的排列        reverse(nums, i + 1);        // 检查新生成的排列是否与上一个排列相同，如果相同则继续生成下一个排列        if (prev != null &amp;&amp; Arrays.equals(nums, prev)) &#123;            return next(nums, prev);        &#125;        return true;    &#125;    public static void reverse(int[] nums, int start) &#123;        int i = start;        int j = nums.length - 1;        while (i &lt; j) &#123;            swap(nums, i, j);            i++;            j--;        &#125;    &#125;    private static void swap(int[] nums, int i, int j) &#123;        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;</code></pre><h2 id="递归实现全排列"><a href="#递归实现全排列" class="headerlink" title="递归实现全排列"></a>递归实现全排列</h2><pre><code class="java">public static void fullsort(int []num,int st,int m,int [] cnt,boolean[] used) &#123;        if (st == num.length -1)&#123;            cnt[0]++;            if (cnt[0] == m)&#123;                printArray(num);            &#125;               return;            &#125;        for (int i = st; i&lt;num.length;i++)        &#123;            if (!used[i]) &#123;                used[i] = true;                swap(num, st, i);                fullsort(num, st + 1, m, cnt, used);                swap(num, st, i);                used[i] = false;            &#125;        &#125;    &#125;    public static void swap(int []a,int b,int c) &#123;        int temp = a[b];        a[b] = a[c];        a[c] = temp;    &#125;    public static void printArray(int[] arr) &#123;        for (int i : arr) &#123;            System.out.print(i + &quot; &quot;);        &#125;        System.out.println();    &#125;</code></pre><h2 id="手写排列"><a href="#手写排列" class="headerlink" title="手写排列"></a>手写排列</h2><pre><code class="java">public static void main(String[] args) &#123;        //定义数组//        4选3 循环3次        int cnt = 0;        int []m = &#123;1,2,3,4&#125;;        for (int i = 0; i&lt;4;i++)&#123;            for(int j = 0; j&lt;4;j++)&#123;                if (j != i)&#123;                    for (int k = 0; k&lt;4;k++)&#123;                        if (k != j &amp;&amp; k != i)&#123;                            // 输出排列结果                            cnt++;                            System.out.printf(&quot;%d%d%d，&quot;,  m[i],m[j],m[k]);                        &#125;                    &#125;                &#125;            &#125;        &#125;        System.out.println();        System.out.println(cnt);//        123，124，132，134，142，143，213，214，231，234，241，243，312，314，321，324，341，342，412，413，421，423，431，432，//24        //字典序 从小到大排序</code></pre><h2 id="手写组合"><a href="#手写组合" class="headerlink" title="手写组合"></a>手写组合</h2><pre><code class="java">public static void main(String[] args) &#123;        //组合 n个数选m个        //n!/m!(n-m!)        //4选3        //循环3次不用判断        int []m = &#123;1,2,3,4&#125;;        int cnt = 0;        for (int i = 0; i&lt;4;i++)&#123;            for(int j = i+1; j&lt;4;j++)&#123;                    for (int k = j+1; k&lt;4;k++)&#123;                        cnt++;                        System.out.printf(&quot;%d%d%d，&quot;,  m[i],m[j],m[k]);                    &#125;                &#125;            &#125;        System.out.println();        System.out.println(cnt);//        123，124，134，234，//          4//        字典序 从小到大排序        &#125;</code></pre><h2 id="DFS实现全排列"><a href="#DFS实现全排列" class="headerlink" title="DFS实现全排列"></a>DFS实现全排列</h2><pre><code class="java">public class 全排列 &#123;    static int[] sequences = &#123;1,2,3,4&#125;;//待全排序的序列    public static void main(String[] args) &#123;        dfs(0,sequences.length-1);    &#125;    public static void dfs(int start,int end) &#123;        //递归结束条件        if(start == end)&#123;            System.out.println(Arrays.toString(sequences));//输出一个全排列序列            return;        &#125;        for(int i = start;i&lt;=end;i++)&#123;            swap(sequences, start, i);//把当前第1个数与后面所有数交换位置，注意所以i是从start开始            dfs(start+1, end);            swap(sequences, start, i);//恢复，用于下一次交换        &#125;    &#125;    public static void swap(int[] a,int i,int j)&#123;        int temp = a[i];        a[i] = a[j];        a[j] = temp;    &#125;&#125;</code></pre><h2 id="拼接字符串大小再进行输出"><a href="#拼接字符串大小再进行输出" class="headerlink" title="拼接字符串大小再进行输出"></a>拼接字符串大小再进行输出</h2><pre><code class="java">”231“”342“”1“输出最大”342“”231“”1“</code></pre><pre><code class="java">package 排列和组合;import java.util.Arrays;import java.util.Scanner;public class 拼数字符串比较大小再拼接输出 &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int inputCount = Integer.parseInt(scanner.nextLine());        String[] nums = new String[inputCount];        for (int i = 0; i &lt; inputCount; i++) &#123;            nums[i] = scanner.next();        &#125;        // 记录最大的排列        StringBuilder maxPermutation = new StringBuilder();        // 求全排列        generatePermutations(nums, 0, inputCount - 1, maxPermutation);        // 输出最大的排列        System.out.println(maxPermutation);    &#125;    private static void generatePermutations(String[] nums, int start, int end, StringBuilder maxPermutation) &#123;        if (start == end) &#123;            // 当只有一个元素时，输出排列结果            StringBuilder currentPermutation = new StringBuilder();            for (String num : nums) &#123;                currentPermutation.append(num);            &#125;            // 如果当前排列比记录的最大排列大，则更新最大排列            if (currentPermutation.toString().compareTo(maxPermutation.toString()) &gt; 0) &#123;                maxPermutation.setLength(0);                maxPermutation.append(currentPermutation);            &#125;            return;        &#125;        // 递归地生成全排列        for (int i = start; i &lt;= end; i++) &#123;            // 将第i个元素与第start个元素交换位置            swap(nums, start, i);            // 递归生成以第start+1个元素开头的子数组的全排列            generatePermutations(nums, start + 1, end, maxPermutation);            // 恢复原始顺序，以便下一轮交换            swap(nums, start, i);        &#125;    &#125;    private static void swap(String[] nums, int i, int j) &#123;        String temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;</code></pre><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><pre><code class="markdown">         二分法有「整数二分」和「实数二分」两种情况。实数二分的代码好写不易出错；整数二分的代码因为要考虑整除的问题，代码容易出错。        二分法的效率极高。比如在有序的n个数中找某个数，只需要二分log2​n ​次，也就是说它的时间复杂度是 O(log2​n) 的。例如有 n = 10^7个数，只需要24 次就能找到答案。        总结一下，二分法把一个长度为 n 的有序序列上 O(n) 的查找时间，优化到了O(log2​n)​。注意，这个序列的数字一定要是「有序」的，二分才有意义。在乱序的一堆数字上搞二分，没有任何用处。所以这个数字序列如果是乱序的，应该先排序再二分。        只搜索一个数的话二分法不如直接暴力搜索，但是搜m个数。那么排序再二分就是 O(nlogn+mlogn)，而你的暴力法是 O(mn)的，显然就快多了。</code></pre><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>假设目标值在闭区间<code>[l,r]</code>中</p><pre><code class="java">int binarySearch(int[] nums, int target)&#123;  if(nums == null || nums.length == 0)&#123; //数组为空    return -1;  &#125;  int l = 0, r = nums.length - 1; //设置左右边界  while(l &lt;= r)&#123;     int mid = l + (r-l) / 2; // 等同于mid=(l+r)/2,这种写法是为了防止数组越界,也可以写为(l+r) &gt;&gt;&gt; 1    if(nums[mid] == target)&#123; //最终target=mid,输出mid        return mid;     &#125;else if(nums[mid] &lt; target) &#123; //目标值在(mid,r]之间        l = mid + 1;     &#125;else &#123;  //目标值在[l,mid)之间        r = mid - 1;     &#125;  &#125;  // 最后判断: l&gt;r 即数组不存在  return -1;&#125;</code></pre><p><strong>关于开闭区间问题</strong></p><pre><code class="java">static int bin_search(int[] a, int n, int x) &#123; // a[0]～a[n-1]是单调递增的        int left = 0, right = n ;//注意：不是 n-1，此时是左闭右开的[0,n)        while (left &lt; right) &#123;            int mid = left + (right - left) / 2; // int mid = (left + right) &gt;&gt; 1;            if (a[mid] &gt;= x)                right = mid;            else                left = mid + 1;        &#125; // 终止于left = right        return left; // 返回x的位置，如果不存在则返回x应该插入的位置    &#125;</code></pre><pre><code class="java">static int search_2(int[] arr,int l,int r,int x)&#123;        Arrays.sort(arr);        while (l&lt;r)&#123;            int mid=(l+r+1)/2;            if (check(mid))&#123;                l=mid;            &#125;else&#123;                r=mid-1;            &#125;        &#125;        return l;    &#125;</code></pre><p>二分查找 (left, right)</p><pre><code class="java"> // 二分查找 (left, right)    int binarySearch3(int[] nums, int target) &#123;        if (nums == null || nums.length == 0)            return -1;         int left = 0, right = nums.length - 1;        while (left + 1 &lt; right)&#123;            int mid = left + (right - left) / 2;            if (nums[mid] == target) &#123;                return mid;            &#125; else if (nums[mid] &lt; target) &#123;                //  target 在右区间，在(middle, right)中                left = mid;            &#125; else &#123;                // target 在左区间，在(left, middle)中                right = mid;            &#125;        &#125;        // 当: left + 1 == right        if(nums[left] == target) return left;        if(nums[right] == target) return right;        return -1;    &#125;</code></pre><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><pre><code class="java">double binarySearch(int[] nums,int target)&#123;    // eps 表示精度，取决于题目对精度的要求    double l = 0; double r = nums.length-1;    const double eps = 1e-6; //科学计数法1*10^-6 当区间长度小于eps时退出循环     while (r - l &gt; eps)&#123; //当区间长度大于eps时继续二分        double mid = (l + r) / 2;        if (nums[mid] &gt; target ) r = mid;        else l = mid;    &#125;    return l; //最后while循环退出的时候l和r近似相等&#125;</code></pre><h2 id="分巧克力"><a href="#分巧克力" class="headerlink" title="分巧克力"></a>分巧克力</h2><pre><code class="java">import java.util.Scanner; public class Main &#123;    private static int max = 100000;     public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int N = scanner.nextInt();        int K = scanner.nextInt();        int[] H = new int[max];        int[] W = new int[max];        for (int i = 0; i &lt; N; i++) &#123;            H[i] = scanner.nextInt();            W[i] = scanner.nextInt();        &#125;        int left = 0, right = max;        while (left &lt; right) &#123;            int mid = left + (right - left + 1) / 2;            int temp = 0;            for (int i = 0; i &lt; N; i++) &#123;                temp = temp + (H[i] / mid) * (W[i] / mid);            &#125;            if (temp &gt;= K) &#123;                left = mid;            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        System.out.println(left);    &#125;&#125;</code></pre><h2 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h2><pre><code class="java">double bsearch_3(double left, double right)&#123;    for (int i = 0; i &lt; 100; i++)    &#123;        double mid = (left + right) / 2;        if (check(mid))            left = mid;        else            right = mid;    &#125;    return left;&#125;</code></pre><pre><code class="java">double bsearch_4(double left, double right)&#123;    while(right-left&gt;0.0000001)&#123;        double mid = (left + right) / 2;        if (check(mid))            left = mid;        else            right = mid;    &#125;    return left;&#125;</code></pre><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>对于一个长度为n的数组 a[0]∼a[n−1]，它的前缀和 sum[i] 等于 a[0]∼a[i] 的和。例如：</p><ul><li><p>sum[0] &#x3D; a[0]</p></li><li><p>sum[1] &#x3D; a[0] + a[1]</p></li><li><p>sum[2] &#x3D; a[0] + a[1] + a[2]</p></li><li><p>⋯</p><p>​      利用递推，只要计算 n 次，就能计算出所有的前缀和：sum[i] &#x3D; sum[i-1] + a[i]。当然，我们也能用 sum[] 反推计算出 a[]：a[i] &#x3D; sum[i] - sum[i-1]。</p></li></ul><p>如果预先算出了前缀和，这时想知道 a[i]∼a[j] 的和，可以用sum[j]−sum[i−1]。 可以利用前缀和快速计算出数组中任意一个区间的和。本来复杂度为 O(n)的区间和计算，优化到了 O(1) 的前缀和计算。</p><pre><code class="java">public static void main(String[] args) &#123;    Scanner sc = new Scanner(System.in);    // 读取输入的行数、列数和阈值 L    int N = sc.nextInt(); // 行数    int M = sc.nextInt(); // 列数    int L = sc.nextInt(); // 阈值 L    // 创建二维数组用于存储输入的矩阵    int[][] arr = new int[N + 1][M + 1];    // 输入数组元素    for (int i = 1; i &lt;= N; i++) &#123;        for (int j = 1; j &lt;= M; j++) &#123;            arr[i][j] = sc.nextInt();        &#125;    &#125;    // 计算二维数组的前缀和    for (int i = 1; i &lt;= N; i++) &#123;        for (int j = 1; j &lt;= M; j++) &#123;            // 使用动态规划的思想，计算每个位置的前缀和            arr[i][j] += arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1];        &#125;    &#125;    long cnt = 0; // 计数器，用于统计符合条件的子矩阵数量    // 暴力查询子矩阵，遍历所有可能的子矩阵    for (int i1 = 1; i1 &lt;= N; i1++) &#123;        for (int i2 = i1; i2 &lt;= N; i2++) &#123;            for (int j1 = 1; j1 &lt;= M; j1++) &#123;                for (int j2 = j1; j2 &lt;= M; j2++) &#123;                    // 计算子矩阵中元素总和                    int z = arr[i2][j2] - arr[i2][j1 - 1] - arr[i1 - 1][j2] + arr[i1 - 1][j1 - 1];                    // 如果子矩阵中元素总和不超过 L，则增加计数器                    if (z &lt;= L) &#123;                        cnt++;                    &#125;                &#125;            &#125;        &#125;    &#125;    // 输出符合条件的子矩阵数量    System.out.println(cnt);&#125;</code></pre><p>灵能传输</p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240402201149341.png" alt="image-20240402201149341"></p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240402201209453.png" alt="image-20240402201209453"></p><pre><code>335 -2 340 0 0 031 2 3</code></pre><pre><code class="java">import java.util.*; public class Main &#123;    public static void main(String[] args) &#123;        Scanner cinScanner = new Scanner(System.in);        int T;        T = cinScanner.nextInt(); // 读取测试用例数量        while (T != 0) &#123; // 循环处理每个测试用例            T--;            long in0 = 0, inn = 0; // 记录起始和结束位置            long n;            long s0, sn;            n = cinScanner.nextLong(); // 读取数组长度            long[] a = new long[(int) n + 2]; // 输入数组            long[] s = new long[(int) n + 1]; // 前缀和数组            long[] vis = new long[(int) n + 2]; // 标记数组            long[] ans = new long[(int) n + 2]; // 存储排序后的结果            for (int i = 0; i &lt; n; i++) &#123;                a[i] = cinScanner.nextLong(); // 读取数组元素                s[i + 1] = a[i]; // 计算前缀和                s[i + 1] += s[i];            &#125;            s0 = s[0]; // 获取最小的前缀和            sn = s[(int) n]; // 获取最大的前缀和            if (s0 &gt; sn) &#123; // 保证 s0 是最小的前缀和                long t = s0;                s0 = sn;                sn = t;            &#125;            Arrays.sort(s); // 对前缀和进行排序            // 找到最小和最大前缀和的位置            for (int i = 0; i &lt;= (int) n; i++)                if (s[i] == s0) &#123;                    in0 = i;                    break;                &#125;            for (int i = (int) n; i &gt;= 0; i--)                if (s[i] == sn) &#123;                    inn = i;                    break;                &#125;            int l = 0;            int r = (int) n;            // 从最小前缀和的位置开始向左遍历            for (int i = (int) in0; i &gt;= 0; i -= 2) &#123;                ans[l++] = s[i];                vis[i] = 1; // 标记已经使用的位置            &#125;            // 从最大前缀和的位置开始向右遍历            for (int i = (int) inn; i &lt;= n; i += 2) &#123;                ans[r--] = s[i];                vis[i] = 1; // 标记已经使用的位置            &#125;            // 将未使用的位置填充到结果数组中            for (int i = 0; i &lt;= n; i++)                if (vis[i] == 0)                    ans[l++] = s[i];            long res = 0;            // 计算相邻元素之间的最大差值            for (int i = 1; i &lt;= n; i++)                res = Math.max(Math.abs((ans[i] - ans[i - 1])), res);            System.out.println(res); // 输出结果        &#125;    &#125;&#125;</code></pre><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>判断连通性除了可以用学习过的 BFS、DFS 外，还可以用一个叫”并查集“的算法</p><p>并查集又可以理解为不相交集合上的合并查询</p><p>并查集是一种非常精巧而实用的数据结构，它主要用于处理一些不相交集合的合并和查询问题。经典的应用有：判断连通性、最小生成树 Kruskal 算法、最近公共祖先（Least Common Ancestors, LCA）等。并查集在算法竞赛中也十分常见：一是简单且高效，二是应用很直观，三是容易和其他数据结构和算法结合。</p><h2 id="1、什么是并查集"><a href="#1、什么是并查集" class="headerlink" title="1、什么是并查集"></a>1、什么是并查集</h2><p>首先并查集是一个集合一种数据结构， 主要有两个操作，分别是</p><p>合并（Union）：把两个不相交的集合合并为一个集合。<br>查询（Find）：判断两个元素是否在同一个集合中。<br>主要用于处理不相交集合的合并及判断连接问题。</p><h2 id="2、并查集能做什么"><a href="#2、并查集能做什么" class="headerlink" title="2、并查集能做什么"></a>2、并查集能做什么</h2><p>判断连接问题 （社交网络、关系网）<br>最近公共祖先<br>渗滤<br>图像处理<br>有限状态自动机的等价性<br>Hinley-Milner 的多态类型推断<br>Kruskal 的最小生成树算法<br>游戏(围棋、十六进制)<br>在 Fortran 中的编译语句的等价性问题</p><h3 id="2、并查集实现结构"><a href="#2、并查集实现结构" class="headerlink" title="2、并查集实现结构"></a>2、并查集实现结构</h3><p>并查集的结构有点类似树型结构， 不过与树不同， 指针是指向父节点。并且里面会存在多颗树， 如下图</p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/c8ab44c8397449f7a2d7d2ac0b031db6-1712073803053-4.png" alt="c8ab44c8397449f7a2d7d2ac0b031db6"></p><h2 id="3、算法原理"><a href="#3、算法原理" class="headerlink" title="3、算法原理"></a>3、算法原理</h2><h3 id="3-1、合并（Union）"><a href="#3-1、合并（Union）" class="headerlink" title="3.1、合并（Union）"></a>3.1、合并（Union）</h3><p>即将两个节点合并归属为同一个集合。 假设有两个节点A 和 B， 一般不是将A 和 到 B， 就是将B合并到A。 在实现上其实也就是将 A的根节点的parent指针指向节点B的根节点即可。 不过为了维持这颗树结构的平衡高度， 一般由较矮的节点树 和合并到 较高的节点树。</p><p>如下图， 如果要合并 g 和 b， 先找到g和b的根节点a和e， 然后把e的父指针指向a即可完成合并。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/d75b0713e21c4ff183fb10ca24d2a6d1.png" alt="d75b0713e21c4ff183fb10ca24d2a6d1"></h3><h3 id="3-2、查询（Find"><a href="#3-2、查询（Find" class="headerlink" title="3.2、查询（Find)"></a>3.2、查询（Find)</h3><p>即判断两个节点是否有关系， 通过parent指针不断向上寻找该节点的根节点， 然后判断它们两个的根节点是否一样即可， 如果一样说明属于同一个集合， 反之不是。</p><p>虽然一般查找根节点这个算法非常简单， 但是一般为了性能优化， 减少每次向上搜索的深度， 在查找find根节点的过程中会进行路径压缩。</p><p>压缩路径过程就是， 在向上寻找的过程中如果发现父节点不是根节点， 就把父指针指向爷爷节点， 然后自己直接跳到爷爷节点进行下一次判断，依次类推。 当遍历到根节点后， 整颗路径树就会变得非常的矮壮， 大大降低的搜索的深度。</p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/de5b90997fd24c3cac04250b5672770e.gif" alt="de5b90997fd24c3cac04250b5672770e"></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240404205047417.png" alt="image-20240404205047417"></p><pre><code class="java">package 字符串;import java.util.Scanner;public class 标题统计 &#123;    public static void main(String[] args) &#123;        // TODO Auto-generated method stub        Scanner sc = new Scanner(System.in);        String s = sc.nextLine().replace(&quot; &quot;, &quot;&quot;);        System.out.println(s.length());    &#125;&#125;</code></pre><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1.图的基本概念"></a>1.图的基本概念</h2><p>图是由顶点集合以及顶点间的关系组成的一种数据结构:G &#x3D; {V,E}.(顶点:vertex , 边:edge)</p><p>V是顶点集合 , V &#x3D; {x|x属于某个对象集}.</p><p>E是边集 , E &#x3D; {(x,y)|x , y 属于V}或者E &#x3D; {&lt;x,y&gt;|x , y 属于V}.</p><pre><code>Tips: (x,y)表示x,y 之间的双向通路 , 即(x,y)是无方向的.&lt;x,y&gt;表示x,y之间的有向通路 . 即&lt;x,y&gt;是有向的.</code></pre><ul><li>完全图</li></ul><pre><code>假设有n个顶点 , 对于无向图任意两个顶点之间有且仅有一条边.完全无向图有n*(n-1)/2条边 .(因为每个顶点都重复计算了一次)对于无向图 , 任意两个顶点之间都存在方向相反的两条弧.完全有向图有n*(n-1)条边 .</code></pre><ul><li>领接顶点</li></ul><pre><code>两个顶点 v1 , v2 之间有边相连 , 则称 v1是v2的领接顶点或v2是v1的领接顶点.</code></pre><ul><li>顶点的度</li></ul><pre><code>顶点的度指的是它关联边的条数.有向图中顶点的度=入度(指出顶点的边)与出度(指入顶点的边)之和.</code></pre><ul><li>简单路径与回路</li></ul><pre><code>若路径上 v1,v2...vm均不重复 , 称这样的路径为简单路径. 若路径上第一个顶点 v1与最后一个顶点 vm 重合 , 则称这样的路径为回路或者环.</code></pre><ul><li>连通图</li></ul><pre><code>在无向图中 , 如果图中任意顶点都是连通的 , 则称此图为连通图.</code></pre><ul><li>强连通图</li></ul><pre><code>在有向图中，若在每一对顶点 vi 和 vj 之间都存在一条从 vi 到 vj 的路径，也存在一条从 vj 到 vi 的路径，则称此图是强连通图</code></pre><ul><li>极小连通子图</li></ul><pre><code>既有要保证连通 , 又要保证边数最小.</code></pre><ul><li>生成树</li></ul><pre><code>一个连通图的最小连通子图称作该图的生成树。有n个顶点的连通图的生成树有n个顶点和n-1条边</code></pre><h2 id="2-图的存储结构"><a href="#2-图的存储结构" class="headerlink" title="2.图的存储结构"></a>2.图的存储结构</h2><p>因为图中既有节点又有边(节点与节点之间的关系) , 因此在图的存储中 , 我们可以使用一段连续的数组来存储节点 , 但边的关系存储较为复杂 , 通常有以下两种方式~~</p><h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><p>因为节点与节点之间的关系就是是否连通 , 即为0 或 1 , 因此可以使用一个二维数组(领接矩阵)来保存节点与节点之间的关系.</p><pre><code>无向图的矩阵是对称的 , 第 i 行(列)元素之和就是顶点 i 的度. 有向图的领接矩阵不一定是对称的 , 第 i 行(列)元素之和就是顶点 i 的出度(入度).如果边带权值 , 并且两个顶点之间是连通的 , 上图中的边的关系就用权值代替 ,  如果两个节点不通 , 则用无穷大代替.用领结矩阵存储图的优点是能够快速知道两个节点之间是否连通 , 缺陷是如果顶点较多 , 边较少(领接矩阵较为稀疏) , 矩阵中存储了大量的0 , 比较浪费空间 , 并且要求两个顶点之间的路径不是很好求.有向图的领接矩阵表示法中 , 顶点 i 的出度为: 第 i 行非0元素之和.顶点 i 的入度为: 第 i 列非0元素之和.</code></pre><pre><code class="java">package Review; import java.util.Arrays;import java.util.HashMap;import java.util.HashSet; public class GraphOfMatrix &#123;    private char[] arrayV;//节点数组    private int[][] Matrix;//领接矩阵    private boolean isDirect;//是否是有向图    HashMap&lt;Character, Integer&gt; map;//优化版的写法 , 目的是建立节点数组与其下标之间的映射关系     //构造节点数组和领接矩阵 size表示当前节点的个数    public GraphOfMatrix(int size, boolean isDirect) &#123;        arrayV = new char[size];        Matrix = new int[size][size];        //将领接矩阵的每一位都初始化为无穷大        for (int i = 0; i &lt; size; i++) &#123;            Arrays.fill(Matrix[i], Integer.MIN_VALUE);        &#125;        this.isDirect = isDirect;    &#125;     /**     * 初始化节点数组     *     * @param array     */    public void initArray(char[] array) &#123;         for (int i = 0; i &lt; array.length; i++) &#123;            //要么初始化节点数组 , 要么建立映射关系.二选一            map.put(array[i], i);//            arrayV[i] = array[i];        &#125;    &#125;     /**     * 添加边     *     * @param src    起始节点     * @param dest   终止节点     * @param weight 权值     */    public void addEdg(char src, char dest, int weight) &#123;        //首先要确定起始节点和终止节点在矩阵中的位置        int srcIndex = getIndexOfV(src);        int destIndex = getIndexOfV(dest);        //将节点和节点之间的关系存储在矩阵中        Matrix[srcIndex][destIndex] = weight;        //如果是无向图 , 矩阵对称的位置同样需要赋值        if (!isDirect) &#123;            Matrix[destIndex][srcIndex] = weight;        &#125;    &#125;     /**     * 获取节点数组的下标     *     * @param v     * @return     */    public int getIndexOfV(char v) &#123;        //同样两种写法二选一        return map.get(v);//        for (int i = 0; i &lt; arrayV.length; i++) &#123;//            if (arrayV[i]==v)&#123;//                return i;//            &#125;//        &#125;//        return -1;    &#125;     /**     * 获取顶点的度     *     * @param v 有向图 = 入度+出度     * @return     */    public int getDevOfV(char v) &#123;        int count = 0;        int srcIndex = getIndexOfV(v);        for (int i = 0; i &lt; Matrix.length; i++) &#123;            if (Matrix[srcIndex][i] != Integer.MIN_VALUE) &#123;                count++;            &#125;        &#125;        //计算有向图的出度        if (isDirect) &#123;            for (int i = 0; i &lt; Matrix[0].length; i++) &#123;                if (Matrix[i][srcIndex] != Integer.MIN_VALUE) &#123;                    count++;                &#125;            &#125;        &#125;        return count;    &#125;     //打印领接表    public void printGraph() &#123;        for (int i = 0; i &lt; Matrix.length; i++) &#123;            for (int j = 0; j &lt; Matrix[0].length; j++) &#123;                if (Matrix[i][j] != Integer.MIN_VALUE) &#123;                    System.out.print(Matrix[i][j] + &quot; &quot;);                &#125; else &#123;                    System.out.print(&quot;∞ &quot;);                &#125;            &#125;            System.out.println();        &#125;    &#125;     public static void main(String[] args) &#123;        char[] chars = &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;,&#125;;        graph.GraphOfMatrix graph = new graph.GraphOfMatrix(chars.length, true);        graph.initArray(chars);         graph.addEdge(&#39;A&#39;, &#39;B&#39;, 1);        graph.addEdge(&#39;A&#39;, &#39;D&#39;, 1);        graph.addEdge(&#39;B&#39;, &#39;A&#39;, 1);        graph.addEdge(&#39;B&#39;, &#39;C&#39;, 1);        graph.addEdge(&#39;C&#39;, &#39;B&#39;, 1);        graph.addEdge(&#39;C&#39;, &#39;D&#39;, 1);        graph.addEdge(&#39;D&#39;, &#39;A&#39;, 1);        graph.addEdge(&#39;D&#39;, &#39;C&#39;, 1);         graph.printGraph();        System.out.print(&quot;输入节点的度为: &quot;);        System.out.println(graph.getDevOfV(&#39;A&#39;));        System.out.println(&quot;=============&quot;);    &#125; &#125;</code></pre><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240405155452502.png" alt="image-20240405155452502"></p><h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>使用数组表示节点的集合 , 使用链表表示边的关系 , 每个链表的节点中即存放边的关系也存放权重.</p><p><strong>1. 无向图临接表存储</strong></p><p><strong>A , B , C , D 分别代表 0 , 1 , 2, 3.</strong></p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240405155522354.png" alt="image-20240405155522354"></p><pre><code>若 G 为无向图 , 则所需的存储空间为 O(V + 2E)若 G 为有向图 , 则所需的存储空间为 O(V + E)在有向图的领接表表示中 , 求一个给定顶点的出度/入度 , 只需计算领接表中相应节点的个数.</code></pre><pre><code class="java">package Review; import java.util.ArrayList; public class GraphByNode &#123;    //构造存储边的链表    static class Node &#123;        public int src;//起始位置         public int dest;//目标位置         public int weight;//权值         public Node next;         public Node(int src, int dest, int weight) &#123;            this.src = src;            this.dest = dest;            this.weight = weight;        &#125;    &#125;     //存储节点的数组    public char[] arrayV;    //存在链表的集合    public ArrayList&lt;Node&gt; edgList;    //判断是否为有向图    public boolean isDirect;     //构造领接表    public GraphByNode(int size, boolean isDirect) &#123;        arrayV = new char[size];        edgList = new ArrayList&lt;&gt;(size);        this.isDirect = isDirect;    &#125;     /**     * 初始化顶点数组     *     * @param array     */    public void initArray(char[] array) &#123;        for (int i = 0; i &lt; arrayV.length; i++) &#123;            arrayV[i] = array[i];        &#125;    &#125;     /**     * 添加边     *     * @param src    起点     * @param dest   终点     * @param weight 权重     */    public void addEdge(char src, char dest, int weight) &#123;        int srcIndex = getIndexOfV(src);        int destIndex = getIndexOfV(dest);        addEdgeChild(srcIndex, destIndex, weight);    &#125;     public void addEdgeChild(int srcIndex, int destIndex, int weight) &#123;        //获取链表的头结点        Node cur = edgList.get(srcIndex);        //遍历整个链表查看之前是否已存在该边        while (cur != null) &#123;            if (cur.dest == destIndex) &#123;                //之前存过这条边直接返回                return;            &#125;            cur = cur.next;        &#125;        //之前没有存储过这条边 , 头插法插入链表        Node node = new Node(srcIndex, destIndex, weight);        node.next = edgList.get(srcIndex);        edgList.set(srcIndex, node);    &#125;     /**     * 获取 顶点下标     *     * @param v     * @return     */    public int getIndexOfV(char v) &#123;        for (int i = 0; i &lt; arrayV.length; i++) &#123;            if (arrayV[i] == v) &#123;                return i;            &#125;        &#125;        return -1;    &#125;     /**     * 获取顶点的度     *     * @param v     * @return     */    public int getDevOfV(char v) &#123;        int count = 0;        int srcIndex = getIndexOfV(v);        Node cur = edgList.get(srcIndex);        while (cur != null) &#123;            count++;            cur = cur.next;        &#125;        //以上仅仅计算了出度 , 还需计算入度        //遍历除了自身外 , 每一个顶点对应的链表中节点是否有指向srcIndex的.        if (isDirect) &#123;            //将srcIndex当做目的下标.            int destIndex = srcIndex;            for (int i = 0; i &lt; arrayV.length; i++) &#123;                //出去自身                if (destIndex == i) &#123;                    continue;                &#125;                Node pCur = edgList.get(i);                while (pCur != null) &#123;                    if (pCur.dest == destIndex) &#123;                        count++;                    &#125;                    pCur = pCur.next;                &#125;            &#125;        &#125;        return count;    &#125;     /**     * 打印领接表     */    public void printGraph() &#123;        for (int i = 0; i &lt; arrayV.length; i++) &#123;            System.out.println(arrayV[i] + &quot;-&gt;&quot;);            Node cur = edgList.get(i);            while (cur != null) &#123;                System.out.println(arrayV[cur.dest] + &quot;-&gt;&quot;);                cur = cur.next;            &#125;            System.out.println();        &#125;    &#125;     public static void main(String[] args) &#123;        graph.GraphByNode graph = new graph.GraphByNode(4, false);        char[] array = &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;,&#125;;        graph.initArray(array);         graph.addEdge(&#39;A&#39;, &#39;B&#39;, 1);        graph.addEdge(&#39;A&#39;, &#39;D&#39;, 1);        graph.addEdge(&#39;B&#39;, &#39;A&#39;, 1);        graph.addEdge(&#39;B&#39;, &#39;C&#39;, 1);        graph.addEdge(&#39;C&#39;, &#39;B&#39;, 1);        graph.addEdge(&#39;C&#39;, &#39;D&#39;, 1);        graph.addEdge(&#39;D&#39;, &#39;A&#39;, 1);        graph.addEdge(&#39;D&#39;, &#39;C&#39;, 1);         graph.printGraph();        System.out.println(graph.getDevOfV(&#39;A&#39;));        System.out.println(&quot;=============&quot;);    &#125;&#125;</code></pre><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240405155555827.png" alt="image-20240405155555827"></p><h2 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h2><h3 id="3-1-图的广度优先遍历"><a href="#3-1-图的广度优先遍历" class="headerlink" title="3.1 图的广度优先遍历"></a>3.1 图的广度优先遍历</h3><blockquote><p>广度优先遍历类似于二叉树的层序遍历 , 由于二叉树的层序遍历借助队列 , 那么图的广度优先遍历也要借助队列. 广度优先遍历每次都访问起始节点相邻的所有节点 , 下图中的访问顺序就是B-&gt;A-&gt;C-&gt;D.</p></blockquote><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240405161452974.png" alt="image-20240405161452974"></p><p><strong>Tips:</strong></p><blockquote><p>注意入队和出队都要将visited数组下标置为true , 否则会出现多次打印最后一个元素的情况. </p></blockquote><p><strong>示例代码:</strong> </p><pre><code class="java"> /**     * 广度优先搜索     * @param v     */    public void bfs(char v) &#123;        //获取起始节点的下标        int srcIndex = getIndexOfV(v);        //调用队列        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        //使用visited数组记录节点是否被访问        boolean[] visited = new boolean[arrayV.length];        queue.offer(srcIndex);        while (!queue.isEmpty()) &#123;            int top = queue.poll();            visited[top] = true;//每弹出一个元素visited数组相应下标就置为true            System.out.println(arrayV[top] + &quot;-&gt;&quot;);            for (int i = 0; i &lt; arrayV.length; i++) &#123;//搜索领接矩阵中起始节点行的每一个元素                if (Matrix[top][i] != Integer.MAX_VALUE &amp;&amp; visited[i] != true) &#123;                    queue.offer(i);                    visited[i] = true;//每存入一个元素visited数组相应下标就置为true                &#125;            &#125;        &#125;    &#125;</code></pre><h3 id="3-2-图的深度优先遍历"><a href="#3-2-图的深度优先遍历" class="headerlink" title="3.2 图的深度优先遍历"></a>3.2 图的深度优先遍历</h3><blockquote><p>图的深度优先优先遍历类似于二叉树的前序遍历 , 需要递归实现.从起始位置一条路走到底 , 再返回寻找下一条路.返回时需要一个visited数组记录元素使用遍历过.</p></blockquote><p><strong>图示过程:</strong> </p><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240405161549100.png" alt="image-20240405161549100"></p><p>代码：</p><pre><code class="java">/**     * 深度优先遍历     *     * @param v 起始元素     */    public void dfs(char v) &#123;        int srcIndex = getIndexOfV(v);        boolean[] visited = new boolean[arrayV.length];        dfsChild(srcIndex, visited);    &#125;     public void dfsChild(int srcIndex, boolean[] visited) &#123;        System.out.println(arrayV[srcIndex] + &quot;-&gt;&quot;);        visited[srcIndex] = true;        for (int i = 0; i &lt; Matrix[srcIndex].length; i++) &#123;            if (Matrix[srcIndex][i] != Integer.MAX_VALUE) &#123;                dfsChild(i, visited);            &#125;        &#125;    &#125;</code></pre><h1 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h1><p><img src="/2024/01/20/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240411192531452.png" alt="image-20240411192531452"></p><p><img src="/./%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AF%92%E5%81%87%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20240411192538077.png" alt="image-20240411192538077"></p>]]></content>
      
      
      
        <tags>
            
            <tag> -- 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1月总结</title>
      <link href="/2024/01/13/1%E6%9C%88%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/13/1%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/01/13/1%E6%9C%88%E6%80%BB%E7%BB%93/20240113181756566-1705141300560-27-1705141302653-30.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> -- java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
